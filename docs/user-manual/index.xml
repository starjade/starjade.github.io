<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XWOS – 用户手册</title>
    <link>/docs/user-manual/</link>
    <description>Recent content in 用户手册 on XWOS</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/docs/user-manual/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 软件架构</title>
      <link>/docs/user-manual/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/architecture/</guid>
      <description>
        
        
        &lt;p&gt;XWOS在设计时就充分考虑了代码的复用性、移植性以及与第三方软件的兼容性，
代码被架构成多层结构：构建系统、BSP、操作系统内核、中间件和应用。&lt;/p&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 960px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/user-manual/architecture/xwos-arch_hu40b05087f7d5942e579bfdfe43adab80_195086_950x760_fill_catmullrom_smart1_3.png&#34; width=&#34;950&#34; height=&#34;760&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS架构图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h2 id=&#34;构建系统&#34;&gt;构建系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbs&lt;/code&gt;: 构建系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bsp&#34;&gt;BSP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwcd&lt;/code&gt;: 编译器、CPU、SOC、外设驱动相关的代码
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwcd/ds&lt;/code&gt;: 玄武设备栈，XWOS的驱动框架&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwcd/perpheral&lt;/code&gt;: 基于玄武设备栈，实现的各种外设驱动，代码可被不同SOC共享&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwcd/soc&lt;/code&gt;: 不同SOC的XWOS移植实现层的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbd&lt;/code&gt;: 不同电路板的工程配置、调试脚本、链接脚本、驱动与应用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统内核&#34;&gt;操作系统内核&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos&lt;/code&gt;: 内核
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos/osal&lt;/code&gt;: 操作系统抽象层，统一的内核API，不区分操作系统的具体实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/ospl&lt;/code&gt;: 操作系统移植层，其中定义了内核提供给BSP的回调函数以及BSP提供给内核的接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/lib&lt;/code&gt;: 基本C函数库，包括原子操作库、位操作库、数据结构等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/mm&lt;/code&gt;: 内存管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/mp&lt;/code&gt;: 多核(mp)内核&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos/up&lt;/code&gt;: 单核(up)内核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中间件&#34;&gt;中间件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd&lt;/code&gt;: 中间件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc&lt;/code&gt;: 系统间的通讯机制
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwcq&lt;/code&gt;: 线程间的循环队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/xwmq&lt;/code&gt;: 线程间的消息队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/pcp&lt;/code&gt;: SOC与SOC间的点对点通讯协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/isc/scp&lt;/code&gt;: SOC与SOC间的点对点通讯协议简化版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmd/libc&lt;/code&gt;: 标准C库的适配代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem&lt;/code&gt;: 第三方开源软件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/fs&lt;/code&gt;: 各种开源的文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem/serializing&lt;/code&gt;: 序列化与反序列化
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/serializing/nanopb&lt;/code&gt;: protocol-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwem/vm&lt;/code&gt;: 虚拟机
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwem/vm/lua&lt;/code&gt;: Lua语言虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwam&lt;/code&gt;: 参考代码以及应用代码&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 基本约束</title>
      <link>/docs/user-manual/basic-promise/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/basic-promise/</guid>
      <description>
        
        
        &lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;
&lt;p&gt;XWOS的所有基本类型定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwu8_t&lt;/code&gt; 8位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws8_t&lt;/code&gt; 8位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu16_t&lt;/code&gt; 16位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws16_t&lt;/code&gt; 16位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu32_t&lt;/code&gt; 32位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws32_t&lt;/code&gt; 32位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwu64_t&lt;/code&gt; 64位无符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xws64_t&lt;/code&gt; 64位有符号整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsz_t&lt;/code&gt; 大小值（无符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwssz_t&lt;/code&gt; 大小值（有符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwstk_t&lt;/code&gt; 栈帧（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwptr_t&lt;/code&gt; 指针的整数值（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwreg_t&lt;/code&gt; 寄存器（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsreg_t&lt;/code&gt; 寄存器（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwer_t&lt;/code&gt; 错误码（有符号），通常为负数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsq_t&lt;/code&gt; 序列值/位置/偏移（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwssq_t&lt;/code&gt; 序列值/位置/偏移（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwsid_t&lt;/code&gt; ID（有符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwid_t&lt;/code&gt; ID（无符号），必须与指针位宽一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* xwisr_f)(void)&lt;/code&gt; 中断向量（函数指针）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwirq_t&lt;/code&gt; 中断号（有符号），负的中断号表示系统异常，正的中断号表示外部中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwpr_t&lt;/code&gt; 优先级（有符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbmp_t&lt;/code&gt; 位图（无符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwtm_t&lt;/code&gt; 时间（64位有符号整数，单位：纳秒）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwlfq_t&lt;/code&gt; 无锁队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* ctor_f)(void * /*obj*/)&lt;/code&gt; 构造函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef void (* dtor_f)(void * /*obj*/)&lt;/code&gt; 析构函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef xws64_t (* xwsc_f)(void * /*arg*/, ...)&lt;/code&gt; 系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原子类型&#34;&gt;原子类型&lt;/h2&gt;
&lt;p&gt;类型后缀&lt;code&gt;_t&lt;/code&gt;换成&lt;code&gt;_a&lt;/code&gt;表示此类型的原子类型。
例如：&lt;code&gt;__xwcc_atomic xwsq_t&lt;/code&gt;等价于&lt;code&gt;xwsq_a&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;系统位数&#34;&gt;系统位数&lt;/h2&gt;
&lt;p&gt;XWOS内核支持32位与64位两种CPU。&lt;/p&gt;
&lt;h2 id=&#34;时间&#34;&gt;时间&lt;/h2&gt;
&lt;p&gt;XWOS内核使用64位有符号整数&lt;code&gt;xwtm_t&lt;/code&gt;表示时间，单位为纳秒。&lt;/p&gt;
&lt;h2 id=&#34;对象&#34;&gt;对象&lt;/h2&gt;
&lt;p&gt;XWOS的对象全部继承于&lt;code&gt;struct xwos_object&lt;/code&gt;，定义在&lt;code&gt;xwos/lib/object.h&lt;/code&gt;，XWOS的对象
使用引用计数法管理生命周期。&lt;/p&gt;
&lt;h2 id=&#34;对象描述符&#34;&gt;对象描述符&lt;/h2&gt;
&lt;p&gt;当XWOS的对象初始化时，会为其分配一个唯一的&lt;strong&gt;标签&lt;/strong&gt;，对象的&lt;strong&gt;指针&lt;/strong&gt;和&lt;strong&gt;标签&lt;/strong&gt;组合在一起
被称为&lt;strong&gt;对象描述符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对象描述符是用来解决ABA问题的。因为动态内存算法的原因，当一个对象被销毁释放，然后再重新
申请对象，旧对象和新对象的内存地址很有可能是一样的，指针并不能作为对象的唯一性代表，
还有可能产生野指针的问题。&lt;/p&gt;
&lt;p&gt;解决的方法是为对象分配一个唯一的&lt;strong&gt;标签&lt;/strong&gt;，每次访问对象前，先检查数值是否匹配，由此可确定
对象是否有效。&lt;/p&gt;
&lt;p&gt;对象描述符主要是为高级语言的**垃圾回收(GC, Garbage Collection)**准备的。现代的高级语言
几乎都具备GC特性，用户不需再像C/C++语言那样，申请和释放必须成对出现。例如在Lua语言中，
用户只管申请使用对象，不用关心对象的释放问题，虚拟机的GC机制会自动管理对象的生命周期。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 配置</title>
      <link>/docs/user-manual/configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/configuration/</guid>
      <description>
        
        
        &lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;XWOS所有配置文件都集中于&lt;code&gt;xwbd/电路板名称/cfg&lt;/code&gt;文件夹中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cfg/XuanWuOS.h&lt;/code&gt;：总配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/arch.h&lt;/code&gt;：ARCH配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/cpu.h&lt;/code&gt;：CPU配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/soc.h&lt;/code&gt;：SOC配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/board.h&lt;/code&gt;：电路板配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwos.h&lt;/code&gt;：内核配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwmd.h&lt;/code&gt;：中间件配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwcd.h&lt;/code&gt;：芯片与外设配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwem.h&lt;/code&gt;：第三方组件配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/xwam.h&lt;/code&gt;：应用配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg/oem.h&lt;/code&gt;：OEM模块配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置说明&#34;&gt;配置说明&lt;/h2&gt;
&lt;p&gt;XWOS在设计之初曾考虑过使用现成的配置生成工具，例如Linux内核的Kconfig工具。
但为了降低跨平台开发的工作量和难度，最终选择使用C语言的头文件来描述所有配置。&lt;/p&gt;
&lt;h3 id=&#34;xuanwuosh总配置文件&#34;&gt;&lt;strong&gt;XuanWuOS.h&lt;/strong&gt;：总配置文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;架构文件夹&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_ARCH&lt;/code&gt;：架构，可在&lt;code&gt;xwcd/soc/&lt;/code&gt;中选择&lt;strong&gt;架构文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_SUBARCH&lt;/code&gt;：子架构，可在&lt;strong&gt;架构文件夹&lt;/strong&gt;中选择&lt;strong&gt;子架构文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_COMPILER&lt;/code&gt;：编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU文件夹&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_CPU&lt;/code&gt;：CPU子集，可在&lt;strong&gt;架构文件夹&lt;/strong&gt;中选择&lt;strong&gt;CPU文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOC文件夹&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_SOC&lt;/code&gt;：片上系统，可在&lt;strong&gt;CPU文件夹&lt;/strong&gt;中选择&lt;strong&gt;SOC文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;电路板文件夹&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_BOARD&lt;/code&gt;：电路板，可在&lt;code&gt;xwbd/&lt;/code&gt;中选择&lt;strong&gt;电路板文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接配置&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_LDSCRIPT&lt;/code&gt;：链接脚本的的相对路径，相对于&lt;strong&gt;电路板文件夹&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;makefile配置&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_ELF_MK&lt;/code&gt;：编译ELF的makefile，位于&lt;code&gt;xwbs/&lt;/code&gt;文件夹中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_XWMO_MK&lt;/code&gt;：编译玄武模块的makefile，位于&lt;code&gt;xwbs/&lt;/code&gt;文件夹中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_XWMO_PREBUILT_MK&lt;/code&gt;：导入已编译成静态库的玄武模块的makefile，位于&lt;code&gt;xwbs/&lt;/code&gt;文件夹中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_CORE&lt;/code&gt;：单核与多核的选择，可选择编译&lt;code&gt;xwos/&lt;/code&gt;下的哪种内核
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mp&lt;/strong&gt;：多核&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;up&lt;/strong&gt;：单核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_XWCD&lt;/code&gt;：是否需要引用芯片、驱动库，路径&lt;code&gt;xwcd/&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_XWMD&lt;/code&gt;：是否需要引用中间件库，路径&lt;code&gt;xwmd/&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_XWEM&lt;/code&gt;：是否需要引用第三方组件库，路径&lt;code&gt;xwem/&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_XWAM&lt;/code&gt;：是否需要引用应用组件库，路径&lt;code&gt;xwam/&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XuanWuOS_CFG_OEMPATH&lt;/code&gt;：OEM模块的搜索路径
&lt;ul&gt;
&lt;li&gt;可以是相对于&lt;code&gt;$(XuanWuOS_BRD_DIR)&lt;/code&gt;的相对路径&lt;/li&gt;
&lt;li&gt;可以为绝对路径&lt;/li&gt;
&lt;li&gt;路径可指向XWOS根目录之外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;archharch配置&#34;&gt;&lt;strong&gt;arch.h&lt;/strong&gt;：ARCH配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据大小端选择，只可选择一种配置为&lt;code&gt;1&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LITTLE_ENDIAN&lt;/code&gt;：小端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_BIG_ENDIAN&lt;/code&gt;：大端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;架构位宽，只可选择一种配置为&lt;code&gt;1&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_32BIT&lt;/code&gt;：32位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_64BIT&lt;/code&gt;：64位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点单元
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_FPU&lt;/code&gt;：是否包含浮点单元，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C标准库
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_COMPILER_CLIB&lt;/code&gt;：是否使用编译器的C库，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_COMPILER_ERRNO&lt;/code&gt;：是否使用编译器的&lt;code&gt;errno.h&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位操作与原子操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBOP_&amp;lt;OP&amp;gt;&lt;/code&gt;：是否使用汇编实现的位操作函数&amp;lt;OP&amp;gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBMPOP_&amp;lt;OP&amp;gt;&lt;/code&gt;：是否使用汇编实现的位图操作函数&amp;lt;OP&amp;gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWAOP_&amp;lt;OP&amp;gt;&lt;/code&gt;：是否使用汇编实现的原子操作函数集&amp;lt;OP&amp;gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_LIB_XWBMPAOP_&amp;lt;OP&amp;gt;&lt;/code&gt;：是否使用汇编实现的位图原子操作函数集&amp;lt;OP&amp;gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二进制标记
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_IMAGE_FLAG_OFFSET&lt;/code&gt;：定义文件信息在二进制文件中存放的位置偏移，用于检查文件是否完整&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARCHCFG_IMAGE_TAILFLAG&lt;/code&gt;：定义二进制文件尾的标记字符串，用于检查文件是否完整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpuhcpu配置&#34;&gt;&lt;strong&gt;cpu.h&lt;/strong&gt;：CPU配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPUCFG_CPU_NUM&lt;/code&gt;：CPU数量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPUCFG_L1_CACHELINE_SIZE&lt;/code&gt;：1机缓存的Cache Line大小，仅对有1级缓冲的SOC有效；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sochsoc配置&#34;&gt;&lt;strong&gt;soc.h&lt;/strong&gt;：SOC配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ARM-M
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt;：SOC异常数量，固定为16&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt;：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_RO_IVT&lt;/code&gt;：中断向量表是否为const的，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_NVIC_PRIO_BITNUM&lt;/code&gt;：ARM-M中断优先级寄存器的位数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_NVIC_SUBPRIO_BITIDX&lt;/code&gt;：ARM-M子中断优先级从第几位开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BKPT&lt;/code&gt;：SOC是否提供&lt;strong&gt;断点调试&lt;/strong&gt;指令，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt;：SOC是否提供&lt;strong&gt;CRC32&lt;/strong&gt;计算单元，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt;：SOC是否提供&lt;strong&gt;CRC8&lt;/strong&gt;计算单元，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nuclei RISC-V bumblebee (rv32imac)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_EXC_NUM&lt;/code&gt;：SOC异常数量，固定为16&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_IRQ_NUM&lt;/code&gt;：SOC外设中断数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_RO_IVT&lt;/code&gt;：中断向量表是否为const的，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_BKPT&lt;/code&gt;：SOC是否提供&lt;strong&gt;断点调试&lt;/strong&gt;指令，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC32&lt;/code&gt;：SOC是否提供&lt;strong&gt;CRC32&lt;/strong&gt;计算单元，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_CRC8&lt;/code&gt;：SOC是否提供&lt;strong&gt;CRC8&lt;/strong&gt;计算单元，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;boardh电路板配置&#34;&gt;&lt;strong&gt;board.h&lt;/strong&gt;：电路板配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;系统HOOK
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_IDLE_HOOK&lt;/code&gt;：是否使用空闲任务HOOK，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值&lt;code&gt;1&lt;/code&gt;时，需要提供&lt;code&gt;void board_xwskd_idle_hook(struct xwospl_skd *)&lt;/code&gt;的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_PRE_SWCX_HOOK&lt;/code&gt;：是否使用任务切换前HOOK，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值&lt;code&gt;1&lt;/code&gt;时，需要提供&lt;code&gt;void board_xwskd_pre_swcx_hook(struct xwospl_skd *)&lt;/code&gt;的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_POST_SWCX_HOOK&lt;/code&gt;：是否使用任务切换后HOOK，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值&lt;code&gt;1&lt;/code&gt;时，需要提供&lt;code&gt;void board_xwskd_post_swcx_hook(struct xwospl_skd *)&lt;/code&gt;的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_SYSHWT_HOOK&lt;/code&gt;：是否使用系统滴答定时器中断HOOK，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值&lt;code&gt;1&lt;/code&gt;时，需要提供&lt;code&gt;void board_xwskd_syshwt_hook(struct xwospl_skd *)&lt;/code&gt;的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_THD_STACK_POOL&lt;/code&gt;：是否提供了线程栈的内存池，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值&lt;code&gt;1&lt;/code&gt;时，需要提供&lt;code&gt;xwer_t board_thd_stack_pool_alloc(xwsz_t , xwstk_t **)&lt;/code&gt;
与&lt;code&gt;xwer_t board_thd_stack_pool_free(xwstk_t *)&lt;/code&gt;的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BRDCFG_XWSKD_THD_POSTINIT_HOOK&lt;/code&gt;：是否使用线程初始化后HOOK，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当取值&lt;code&gt;1&lt;/code&gt;时，需要提供&lt;code&gt;void board_thd_postinit_hook(struct xwospl_thd *)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;电路板模块的路径需要按照构建系统的规则转换为配置宏，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwosh内核配置&#34;&gt;&lt;strong&gt;xwos.h&lt;/strong&gt;：内核配置&lt;/h3&gt;
&lt;p&gt;操作系统相关的配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWKNCFG_CHECK_PARAMETERS&lt;/code&gt;：是否开启API参数检查，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWKNCFG_BUG&lt;/code&gt;：是否启用BUG调试，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWKNCFG_RELOCATE_DATA&lt;/code&gt;：是否需要在初始化时将&lt;strong&gt;xwos.data&lt;/strong&gt;的从flash中拷贝到RAM内，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;当链接脚本将&lt;strong&gt;xwos.data&lt;/strong&gt;存放在独立的&lt;strong&gt;section&lt;/strong&gt;时需要定义为&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当链接脚本将&lt;strong&gt;xwos.data&lt;/strong&gt;存放在**.data section**时需要定义为&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;玄武C库：
&lt;ul&gt;
&lt;li&gt;日志
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_LOG&lt;/code&gt;：是否启用Log调试，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWLOG_LEVEL&lt;/code&gt;：最低日志等级；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWLOG_BUFSIZE&lt;/code&gt;：日志格式化缓冲区大小；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子操作
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP8&lt;/code&gt;：是否启用8位原子操作库，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP16&lt;/code&gt;：是否启用16位原子操作库，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP32&lt;/code&gt;：是否启用32位原子操作库，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWAOP64&lt;/code&gt;：是否启用64位原子操作库，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_XWBMPAOP&lt;/code&gt;：是否启用位图原子操作库，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据结构
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_MAP&lt;/code&gt;：是否启用键值对，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CRC
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32&lt;/code&gt;：是否启用CRC32，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32_0X04C11DB7&lt;/code&gt;：是否启用CRC32多项式0x04C11DB7，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC32_0XEDB88320&lt;/code&gt;：是否启用CRC32多项式0xEDB88320，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8&lt;/code&gt;：是否启用CRC8，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X07&lt;/code&gt;：是否启用CRC8多项式0x07，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X31&lt;/code&gt;：是否启用CRC8多项式0x31，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_CRC8_0X9B&lt;/code&gt;：是否启用CRC8多项式0x9B，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;长跳转
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWLIBCFG_SETJMP&lt;/code&gt;：是否启用&lt;code&gt;setjmp()/longjmp()&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存管理
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_STACK_ALIGNMENT&lt;/code&gt;：线程栈对齐的字节数，通常设置为8字节；&lt;/li&gt;
&lt;li&gt;栈的类型，只可选择一种配置为&lt;code&gt;1&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_FD_STACK&lt;/code&gt;：满递减栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_ED_STACK&lt;/code&gt;：空递减栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_FA_STACK&lt;/code&gt;：满递增栈&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_EA_STACK&lt;/code&gt;：满递增栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_MEMSLICE&lt;/code&gt;：是否启用内存切片算法，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_BMA&lt;/code&gt;：是否启用伙伴算法，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMMCFG_MEMPOOL&lt;/code&gt;：是否启用内存池，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MP内核配置
&lt;ul&gt;
&lt;li&gt;调度器
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYSHWT_PERIOD&lt;/code&gt;：硬件定时器周期，单位纳秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_PRIORITY_RT_NUM&lt;/code&gt;：调度器实时优先级数量，数量越小越省内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_IDLE_STACK_SIZE&lt;/code&gt;：空闲任务栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_BH&lt;/code&gt;：是否启用中断底半部，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_BH_STACK_SIZE&lt;/code&gt;：中断底半部栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_THD_MEMSLICE&lt;/code&gt;：是否启用memslice线程对象缓存，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_THD_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建线程对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_THD_LOCAL_DATA_NUM&lt;/code&gt;：线程私有数据的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_SWT&lt;/code&gt;：是否启用软件定时器，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_SWT_MEMSLICE&lt;/code&gt;：是否启用memslice软件定时器对象缓存，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SKD_SWT_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建定时器对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_PLSEM&lt;/code&gt;：是否启用管道信号量，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_RTSEM&lt;/code&gt;：是否启用实时信号量，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_SEM_MEMSLICE&lt;/code&gt;：是否启用memslice信号量对象缓存，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_SEM_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建信号量对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_COND_MEMSLICE&lt;/code&gt;：是否启用memslice条件量对象缓存，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_COND_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建条件量对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_EVT&lt;/code&gt;：是否启用事件，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_SYNC_EVT_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建事件对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_LOCK_MTX_MEMSLICE&lt;/code&gt;：是否启用memslice互斥锁对象缓存，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMPCFG_LOCK_MTX_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建互斥锁对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UP内核配置
&lt;ul&gt;
&lt;li&gt;调度器
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYSHWT_PERIOD&lt;/code&gt;：硬件定时器周期，单位纳秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_PRIORITY_RT_NUM&lt;/code&gt;：调度器实时优先级数量，数量越小越省内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_IDLE_STACK_SIZE&lt;/code&gt;：空闲任务栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_BH&lt;/code&gt;：是否启用中断底半部，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_BH_STACK_SIZE&lt;/code&gt;：中断底半部栈大小；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_PM&lt;/code&gt;：是否启用电源管理，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_THD_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建线程对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_THD_LOCAL_DATA_NUM&lt;/code&gt;：线程私有数据的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_THD_EXIT&lt;/code&gt;：是否启用线程退出，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_SWT&lt;/code&gt;：是否启用软件定时器，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SKD_SWT_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建定时器对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_PLSEM&lt;/code&gt;：是否启用管道信号量，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_PLSEM_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建管道信号量对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_RTSEM&lt;/code&gt;：是否启用实时信号量，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_RTSEM_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建实时信号量对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_COND&lt;/code&gt;：是否启用条件量，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_COND_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建条件量对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_EVT&lt;/code&gt;：是否启用事件，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_SYNC_EVT_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建事件对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_LOCK_MTX&lt;/code&gt;：是否启用互斥锁，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_LOCK_MTX_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建实时互斥锁对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWUPCFG_LOCK_FAKEMTX&lt;/code&gt;：是否启用虚假互斥锁，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwmdh中间件配置&#34;&gt;xwmd.h：：中间件配置&lt;/h3&gt;
&lt;p&gt;中间件模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;表示模块的是否被编译。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_CHECK_PARAMETERS&lt;/code&gt;：是否开启API参数检查，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp&lt;/code&gt;：是否启用点对点通讯协议，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_LOG&lt;/code&gt;：是否开启日志，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_PORT_NUM&lt;/code&gt;：消息通道的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_PRI_NUM&lt;/code&gt;：消息优先级的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_RETRY_PERIOD&lt;/code&gt;：重发消息的周期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_RETRY_NUM&lt;/code&gt;：重发消息的最大次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_MEMBLK_SIZE&lt;/code&gt;：伙伴算法分配器的单位内存块的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_MEMBLK_ODR&lt;/code&gt;：以2的n次方形式表示的伙伴算法分配器内存块的数量，此处配置的是指数n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_RXTHD_PRIORITY&lt;/code&gt;：接收线程的优先级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwpcp_TXTHD_PRIORITY&lt;/code&gt;：发送线程的优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwscp&lt;/code&gt;：是否启用精简的点对点通讯协议，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwscp_LOG&lt;/code&gt;：是否开启日志，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwscp_PERIOD&lt;/code&gt;：重发消息的周期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwscp_MEMBLK_SIZE&lt;/code&gt;：伙伴算法分配器的单位内存块的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwscp_MEMBLK_ODR&lt;/code&gt;：以2的n次方形式表示的伙伴算法分配器内存块的数量，此处配置的是指数n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwscp_THD_PRIORITY&lt;/code&gt;：线程的优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwmq&lt;/code&gt;：是否启用消息队列，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwmq_LOG&lt;/code&gt;：是否开启日志，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwmq_MEMSLICE&lt;/code&gt;：是否启用memslice对象缓存，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwmq_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwcq&lt;/code&gt;：是否启用循环队列，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwcq_LOG&lt;/code&gt;：是否开启日志，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_isc_xwcq_STDC_MM&lt;/code&gt;：是否启用C标准库中&lt;code&gt;malloc()&lt;/code&gt;来动态创建对象，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_libc_newlibac&lt;/code&gt;：是否启用libc/newlib的适配代码，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_libc_newlibac_string&lt;/code&gt;：是否编译&lt;code&gt;string.c&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_libc_newlibac_mem&lt;/code&gt;：是否编译&lt;code&gt;mem.c&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_libc_newlibac_fops&lt;/code&gt;：是否编译&lt;code&gt;fops.c&lt;/code&gt;，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWMDCFG_ramcode&lt;/code&gt;：是否启用Ramcode，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwcdh芯片与外设配置&#34;&gt;xwcd.h：芯片与外设配置&lt;/h3&gt;
&lt;p&gt;芯片与外设模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;表示模块的是否被编译。&lt;/p&gt;
&lt;h3 id=&#34;xwemh第三方软件配置&#34;&gt;xwem.h：第三方软件配置&lt;/h3&gt;
&lt;p&gt;第三方软件模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;表示模块的是否被编译。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_serializing_nanopb&lt;/code&gt;：是否启用protobuf-nanopb，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_fatfs&lt;/code&gt;：是否启用FatFs，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_littlefs&lt;/code&gt;：是否启用littlefs，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_spiffs&lt;/code&gt;：是否启用spiffs，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_fs_dhara&lt;/code&gt;：是否启用dhara，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua&lt;/code&gt;：是否启用Lua语言，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_INT_TYPE&lt;/code&gt;：Lua语言中整数类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_FLOAT_TYPE&lt;/code&gt;：Lua语言中浮点类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_THD_STACK&lt;/code&gt;：Lua交互式解释器线程的栈大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWEMCFG_vm_lua_BRDLIBS&lt;/code&gt;：是否启用BSP中Lua库，取值：&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xwamh应用配置&#34;&gt;xwam.h：应用配置&lt;/h3&gt;
&lt;p&gt;应用模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;表示模块的是否被编译。&lt;/p&gt;
&lt;h3 id=&#34;oemhoem模块配置&#34;&gt;oem.h：OEM模块配置&lt;/h3&gt;
&lt;p&gt;OEM模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;表示模块的是否被编译。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 构建系统</title>
      <link>/docs/user-manual/build-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/build-system/</guid>
      <description>
        
        
        &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;XWOS的构建系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持纯命令行方式编译，可用于持续集成环境中，例如&lt;strong&gt;jenkins&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;可在ubuntu、Windows上运行；&lt;/li&gt;
&lt;li&gt;支持基于Eclipse的IDE：
&lt;ul&gt;
&lt;li&gt;NXP S32DS IDE&lt;/li&gt;
&lt;li&gt;STM32CubeIDE&lt;/li&gt;
&lt;li&gt;NXP MCUXpressoIDE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为了方便集成其他项目的软件，XWOS参考了Android的构建系统，
通过编写&lt;code&gt;xwmo.mk&lt;/code&gt;，可快速集成其他软件，就像&lt;code&gt;Android.mk&lt;/code&gt;一样工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译环境设置&#34;&gt;编译环境设置&lt;/h2&gt;
&lt;h3 id=&#34;xwtool&#34;&gt;xwtool&lt;/h3&gt;
&lt;p&gt;XWOS提供了各平台的gcc和llvm编译工具链，可从百度网盘下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&#34;&gt;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;提取码：xwos&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ubuntu&#34;&gt;ubuntu&lt;/h3&gt;
&lt;h4 id=&#34;安装必要的工具&#34;&gt;安装必要的工具&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo dpkg-reconfigure dash &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 选择“否”&lt;/span&gt;
sudo apt install build-essential
sudo apt-add-repository ppa:kelleyk/emacs
sudo apt-get update
sudo apt install emacs27
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;工具链&#34;&gt;工具链&lt;/h4&gt;
&lt;p&gt;XWOS的工具链可从百度网盘下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&#34;&gt;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;提取码：xwos&lt;/li&gt;
&lt;li&gt;文件：xwtool/ubuntu-x86_64.tar.xz&lt;/li&gt;
&lt;li&gt;解压命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 注意带上选项p，否则解压后脚本可能丢失执行权限&lt;/span&gt;
tar xvfJp ubuntu-x86_64.tar.xz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;文件列表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;lt;安装路径&amp;gt;
├── 60-openocd.rules
├── 80-gdlink.rules
├── 81-daplink.rules
├── 安装说明.md
├── install.sh
├── xwtool
│   ├── armgcc
│   ├── armllvm
│   ├── openocd
│   ├── ppcvlegcc
│   ├── riscvgcc
│   └── xwtoolwd
└── xwtool.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;安装：参考&lt;code&gt;安装说明.md&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;windows&#34;&gt;windows&lt;/h3&gt;
&lt;h4 id=&#34;工具链-1&#34;&gt;工具链&lt;/h4&gt;
&lt;p&gt;XWOS的工具链可从百度网盘下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&#34;&gt;https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;提取码：xwos&lt;/li&gt;
&lt;li&gt;文件：xwtool/windows-x86_64.7z&lt;/li&gt;
&lt;li&gt;文件列表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;lt;安装路径&amp;gt;
├── 安装说明.md
└── xwtool
    ├── armgcc
    ├── armllvm
    └── xwtoolwd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;安装：参考&lt;code&gt;安装说明.md&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ide&#34;&gt;IDE&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;STM32: &lt;a href=&#34;TBD&#34;&gt;STM32CubeIDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;NXP S32K: &lt;a href=&#34;TBD&#34;&gt;S32K&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GD32: &lt;a href=&#34;TBD&#34;&gt;Eclipse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GD32V:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;TBD&#34;&gt;NucleiStudio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译器&#34;&gt;编译器&lt;/h2&gt;
&lt;p&gt;XWOS对不同SOC的编译器支持情况不同，主要取决于上游以及官方的支持情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;TBD&#34;&gt;ARM-M&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOC
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; STM32&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; NXP S32K&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; I.MX.RT&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; GD32&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具链
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; gcc
&lt;ul&gt;
&lt;li&gt;std: gnu11&lt;/li&gt;
&lt;li&gt;libc: newlib&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; g++
&lt;ul&gt;
&lt;li&gt;std: gnu++17&lt;/li&gt;
&lt;li&gt;C++STL: libstdc++, libsupc++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; llvm(clang)
&lt;ul&gt;
&lt;li&gt;std: gnu11&lt;/li&gt;
&lt;li&gt;libc: newlib&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; llvm(clang++)
&lt;ul&gt;
&lt;li&gt;std: gnu++14&lt;/li&gt;
&lt;li&gt;C++STL: libc++.a, libc++abi.a&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;TBD&#34;&gt;芯莱RISC-V&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOC
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; GD32V&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具链
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; gcc
&lt;ul&gt;
&lt;li&gt;std: gnu11&lt;/li&gt;
&lt;li&gt;libc: newlib&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; g++
&lt;ul&gt;
&lt;li&gt;std: gnu++17&lt;/li&gt;
&lt;li&gt;C++STL: libstdc++, libsupc++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; llvm&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;TBD&#34;&gt;PowerPC&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOC
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; MPC560x&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具链
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; gcc
&lt;ul&gt;
&lt;li&gt;std: gnu11&lt;/li&gt;
&lt;li&gt;libc: newlib&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; g++&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; llvm&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;构建流程&#34;&gt;构建流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS的构建是从&lt;code&gt;电路板&lt;/code&gt;目录下执行命令&lt;code&gt;make&lt;/code&gt;开始的。
以&lt;code&gt;$(XuanWuOS_BRD_DIR)&lt;/code&gt;代表此目录。生成的文件全部位于&lt;code&gt;$(WKSPC)&lt;/code&gt;，&lt;code&gt;$(WKSPC)&lt;/code&gt;的
默认路径为&lt;code&gt;$(XuanWuOS_BRD_DIR)/wkspc&lt;/code&gt;，可在在编译之前将环境变量&lt;code&gt;WKSPC&lt;/code&gt;&lt;strong&gt;export&lt;/strong&gt;到环境变量中；&lt;/li&gt;
&lt;li&gt;XWOS的构建系统在构建&lt;strong&gt;内核&lt;/strong&gt;、&lt;strong&gt;xwmd&lt;/strong&gt;模块、&lt;strong&gt;xwcd&lt;/strong&gt;模块、&lt;strong&gt;xwem&lt;/strong&gt;模块、
&lt;strong&gt;xwam&lt;/strong&gt;模块、&lt;strong&gt;oem&lt;/strong&gt;模块时都是独立编译成静态库**.a**，然后再链接。
各个模块的编译配置（头文件、编译器选项）都是完全独立的，可以理解为不同的子工程。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart TD
    make(&amp;quot;make&amp;quot;) --&amp;gt; cfg
    cfg[&amp;quot;生成配置&amp;quot;] --&amp;gt; arch
    arch[&amp;quot;编译arch.a&amp;quot;] --&amp;gt; cpu
    cpu[&amp;quot;编译cpu.a&amp;quot;] --&amp;gt; soc
    soc[&amp;quot;编译soc.a&amp;quot;] --&amp;gt; brd
    brd[&amp;quot;编译brd.a&amp;quot;] --&amp;gt; xwos
    xwos[&amp;quot;编译XWOS内核&amp;quot;] --&amp;gt; xwmd
    xwmd[&amp;quot;编译中间件模块&amp;quot;] --&amp;gt; xwcd
    xwcd[&amp;quot;编译设备模块&amp;quot;] --&amp;gt; bm
    bm[&amp;quot;编译电路板模块&amp;quot;] --&amp;gt; xwem
    xwem[&amp;quot;编译第三方软件模块&amp;quot;] --&amp;gt; xwam
    xwam[&amp;quot;编译应用模块&amp;quot;] --&amp;gt; oem
    oem[&amp;quot;编译OEM模块&amp;quot;] --&amp;gt; elf
    elf[&amp;quot;链接ELF文件&amp;quot;] --&amp;gt; bin
    bin[&amp;quot;生成bin文件&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;生成配置&#34;&gt;生成配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统调用脚本&lt;code&gt;xwbs/util/el/mkcfg.el&lt;/code&gt;处理&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg&lt;/code&gt;下的
所有配置文件，将它们转化成三个文件：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(WKSPC)/XuanWuOS.cfg&lt;/code&gt;，makefile环境变量，之后被makefile引入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(WKSPC)/autogen.h&lt;/code&gt;，自动生成的头文件，被顶级头文件&lt;code&gt;xwos/standard.h&lt;/code&gt;包含&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(WKSPC)/env.rc&lt;/code&gt;，&lt;strong&gt;shell&lt;/strong&gt;环境变量脚本，可通过&lt;code&gt;source&lt;/code&gt;命令引入这个文件，
使得&lt;a href=&#34;#%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD&#34;&gt;辅助功能&lt;/a&gt;生效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译archa&#34;&gt;编译arch.a&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则&lt;code&gt;$(XuanWuOS_ARCH_DIR)/arch.mk&lt;/code&gt;，
编译架构描述层(Arch Description Layer)的源码，
并输出静态库&lt;strong&gt;arch.a&lt;/strong&gt;到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3 id=&#34;编译cpua&#34;&gt;编译cpu.a&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则&lt;code&gt;$(XuanWuOS_CPU_DIR)/arch.mk&lt;/code&gt;，
编译CPU描述层(CPU Description Layer)的源码，
并输出静态库&lt;strong&gt;cpu.a&lt;/strong&gt;到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3 id=&#34;编译soca&#34;&gt;编译soc.a&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则&lt;code&gt;$(XuanWuOS_SOC_DIR)/soc.mk&lt;/code&gt;，
编译SOC描述层(SOC Description Layer)的源码，
并输出静态库&lt;strong&gt;soc.a&lt;/strong&gt;到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3 id=&#34;编译brda&#34;&gt;编译brd.a&lt;/h3&gt;
&lt;p&gt;构建系统会根据编译规则&lt;code&gt;$(XuanWuOS_BRD_DIR)/brd.mk&lt;/code&gt;，
编译电路板描述层(Board Description Layer)的源码，
并输出静态库&lt;strong&gt;brd.a&lt;/strong&gt;到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3 id=&#34;编译xwos内核&#34;&gt;编译XWOS内核&lt;/h3&gt;
&lt;p&gt;构建系统会加载位于&lt;code&gt;xwos/xwos.mk&lt;/code&gt;的编译规则，最后输出静态库&lt;strong&gt;xwos.a&lt;/strong&gt;到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3 id=&#34;编译中间件模块&#34;&gt;编译中间件模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会扫描&lt;code&gt;xwmd/&lt;/code&gt;文件夹以及子文件下的所有&lt;code&gt;xwmo.mk&lt;/code&gt;文件，生成模块列表，
依次将它们编译成**.a**静态库，输出到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;xwmo.mk&lt;/code&gt;文件代表了一个模块，其中定义了模块相关的参数：源代码列表、
附加编译选项、头文件路径等。&lt;/li&gt;
&lt;li&gt;每个中间件模块在&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwmd.h&lt;/code&gt;中都有一个编译开关的宏定义，
定义为&lt;code&gt;1&lt;/code&gt;时表示编译这个模块，&lt;code&gt;0&lt;/code&gt;或&lt;strong&gt;未定义&lt;/strong&gt;表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考&lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译设备模块&#34;&gt;编译设备模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会扫描&lt;code&gt;xwcd&lt;/code&gt;文件夹以及子文件下的所有&lt;code&gt;xwmo.mk&lt;/code&gt;文件，生成模块列表，
依次将它们编译成**.a**静态库，输出到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;xwmo.mk&lt;/code&gt;文件代表了一个模块，其中定义了模块相关的参数：源代码列表、
附加编译选项、头文件路径等。&lt;/li&gt;
&lt;li&gt;每个外设库模块在&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwcd.h&lt;/code&gt;中都有一个编译开关的宏定义，
定义为&lt;code&gt;1&lt;/code&gt;时表示编译这个模块，&lt;code&gt;0&lt;/code&gt;或&lt;strong&gt;未定义&lt;/strong&gt;表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考&lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译电路板模块&#34;&gt;编译电路板模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会扫描&lt;code&gt;$(XuanWuOS_BM_DIR)&lt;/code&gt;文件夹以及子文件下的所有&lt;code&gt;xwmo.mk&lt;/code&gt;文件，生成模块列表，
依次将它们编译成**.a**静态库，输出到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;xwmo.mk&lt;/code&gt;文件代表了一个模块，其中定义了模块相关的参数：源代码列表、
附加编译选项、头文件路径等。&lt;/li&gt;
&lt;li&gt;每个电路板模块在&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/board.h&lt;/code&gt;中都有一个编译开关的宏定义，
定义为&lt;code&gt;1&lt;/code&gt;时表示编译这个模块，&lt;code&gt;0&lt;/code&gt;或&lt;strong&gt;未定义&lt;/strong&gt;表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考&lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译第三方软件模块&#34;&gt;编译第三方软件模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会扫描&lt;code&gt;xwem&lt;/code&gt;文件夹以及子文件下的所有&lt;code&gt;xwmo.mk&lt;/code&gt;文件，生成模块列表，
依次将它们编译成**.a**静态库，输出到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;xwmo.mk&lt;/code&gt;文件代表了一个模块，其中定义了模块相关的参数：源代码列表、
附加编译选项、头文件路径等。&lt;/li&gt;
&lt;li&gt;每个外设库模块在&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwem.h&lt;/code&gt;中都有一个编译开关的宏定义，
定义为&lt;code&gt;1&lt;/code&gt;时表示编译这个模块，&lt;code&gt;0&lt;/code&gt;或&lt;strong&gt;未定义&lt;/strong&gt;表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考&lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译应用模块&#34;&gt;编译应用模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构建系统会扫描&lt;code&gt;xwam&lt;/code&gt;文件夹以及子文件下的所有&lt;code&gt;xwmo.mk&lt;/code&gt;文件，生成模块列表，
依次将它们编译成**.a**静态库，输出到&lt;code&gt;$(WKSPC)/obj&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;xwmo.mk&lt;/code&gt;文件代表了一个模块，其中定义了模块相关的参数：源代码列表、
附加编译选项、头文件路径等。&lt;/li&gt;
&lt;li&gt;每个外设库模块在&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwam.h&lt;/code&gt;中都有一个编译开关的宏定义，
定义为&lt;code&gt;1&lt;/code&gt;时表示编译这个模块，&lt;code&gt;0&lt;/code&gt;或&lt;strong&gt;未定义&lt;/strong&gt;表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考&lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编译oem模块&#34;&gt;编译OEM模块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OEM文件夹路径由配置&lt;code&gt;XuanWuOS_CFG_OEMPATH&lt;/code&gt;指定，此配置位于&lt;code&gt;cfg/XuanWuOS.h&lt;/code&gt;中：
&lt;ul&gt;
&lt;li&gt;可以是相对于&lt;code&gt;$(XuanWuOS_BRD_DIR)&lt;/code&gt;的相对路径&lt;/li&gt;
&lt;li&gt;可以为绝对路径&lt;/li&gt;
&lt;li&gt;路径可指向XWOS根目录之外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构建系统会扫描OEM文件夹以及子文件下的所有&lt;code&gt;xwmo.mk&lt;/code&gt;文件，生成模块列表，
依次将它们编译成**.a**静态库，输出到&lt;code&gt;$(WKSPC)/obj/oem&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;xwmo.mk&lt;/code&gt;文件代表了一个模块，其中定义了模块相关的参数：源代码列表、
附加编译选项、头文件路径等。&lt;/li&gt;
&lt;li&gt;每个外设库模块在&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/oem.h&lt;/code&gt;中都有一个编译开关的宏定义，
定义为&lt;code&gt;1&lt;/code&gt;时表示编译这个模块，&lt;code&gt;0&lt;/code&gt;或&lt;strong&gt;未定义&lt;/strong&gt;表示排除这个模块。&lt;/li&gt;
&lt;li&gt;编译开关的命名规则参考&lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99&#34;&gt;模块编译开关的命名规则&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链接elf文件&#34;&gt;链接ELF文件&lt;/h3&gt;
&lt;p&gt;构建系统最终会将以上生成的所有**.a**静态库链接成**XWOS.elf**文件，
连接脚本由&lt;code&gt;$(XuanWuOS_BRD_DIR)/$(XuanWuOS_CFG_LDSCRIPT)&lt;/code&gt;定义。&lt;/p&gt;
&lt;h3 id=&#34;生成bin文件&#34;&gt;生成bin文件&lt;/h3&gt;
&lt;p&gt;构建系统会将&lt;strong&gt;XWOS.elf&lt;/strong&gt;文件转换成**.bin**文件以及**.hex**文件。&lt;/p&gt;
&lt;h2 id=&#34;构建选项&#34;&gt;构建选项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~V&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;取值：
&lt;ul&gt;
&lt;li&gt;1: 开启选项&lt;/li&gt;
&lt;li&gt;0: 关闭选项（默认值）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用法：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;make ~V&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用：输出完整的编译过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;~D&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取值：
&lt;ul&gt;
&lt;li&gt;1: 开启选项（默认值）&lt;/li&gt;
&lt;li&gt;0: 关闭选项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用法：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;make ~D&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;作用：优化编译，输出体积较小的二进制，但不利于调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;玄武模块&#34;&gt;玄武模块&lt;/h2&gt;
&lt;p&gt;XWOS的设备模块、电路板模块、中间件模块、第三方软件模块以及OEM模块，
都是使用&lt;code&gt;xwmo.mk&lt;/code&gt;来描述编译规则的，将它们统一称为&lt;strong&gt;玄武模块(XWMO)&lt;/strong&gt;。
编译规则&lt;code&gt;xwmo.mk&lt;/code&gt;的原理类似于Android系统中的&lt;code&gt;Android.mk&lt;/code&gt;：每个&lt;strong&gt;玄武模块&lt;/strong&gt;都是
独立编译的，其中定义的编译参数、头文件只对当前有效。&lt;/p&gt;
&lt;p&gt;示例，&lt;code&gt;xwam/example/cxx&lt;/code&gt;的&lt;code&gt;xwmo.mk&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XuanWuOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XuanWuOS.cfg&lt;/span&gt;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含环境变量
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWBS_UTIL_MK_XWMO&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;                            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含一些辅助的Makefile函数
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; mif.c                                     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C源文件&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;                                          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定附加的C编译选项&lt;/span&gt;

&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; task.cxx                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定C++源文件&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; test/literal.cxx test/vector.cxx        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加C++源文件&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; -Wno-unused-value                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C++编译选项&lt;/span&gt;

&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS_llvm&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; -Wno-error&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;gnu-string-literal-operator-template &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 当编译器为llvm时一增加的C++编译选项&lt;/span&gt;

&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;                     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 指定附加的头文件搜索路径，其中使用函数getXwmoDir获得当前xwmo的路径&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XuanWuOS_CFG_XWMO_MK&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用编译Makefile执行编译
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;模块路径命名规则&#34;&gt;模块路径命名规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;由于模块路径需要对应于C语言中的一个宏定义作为编译开关，
因此模块路径需要符合C语言标识符的规则，但可以包含几个特殊符号：
&lt;ul&gt;
&lt;li&gt;路径不能以数字开头；&lt;/li&gt;
&lt;li&gt;路径中每级目录以&lt;code&gt;/&lt;/code&gt;隔开；&lt;/li&gt;
&lt;li&gt;路径中可包含&lt;code&gt;.&lt;/code&gt;，但不能出现&lt;code&gt;../&lt;/code&gt;和&lt;code&gt;./&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;路径中可包含&lt;code&gt;-&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;模块编译开关的命名规则&#34;&gt;模块编译开关的命名规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模块路径只需要转换相对路径部分：
&lt;ul&gt;
&lt;li&gt;中间件模块：取&lt;code&gt;xwmd&lt;/code&gt;（不含）之后的路径；&lt;/li&gt;
&lt;li&gt;设备驱动模块：取&lt;code&gt;xwcd&lt;/code&gt;（不含）之后的路径；&lt;/li&gt;
&lt;li&gt;电路板模块：取&lt;code&gt;$(XuanWuOS_BRD_DIR)/bm&lt;/code&gt;（不含）之后的路径；&lt;/li&gt;
&lt;li&gt;第三方软件模块：取&lt;code&gt;xwem&lt;/code&gt;（不含）之后的路径；&lt;/li&gt;
&lt;li&gt;应用模块：取&lt;code&gt;xwam&lt;/code&gt;（不含）之后的路径；&lt;/li&gt;
&lt;li&gt;OEM模块：取&lt;code&gt;OEM文件夹&lt;/code&gt;（不含）之后的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路径中的&lt;code&gt;_&lt;/code&gt;，需要两个&lt;code&gt;_&lt;/code&gt;来表示；&lt;/li&gt;
&lt;li&gt;路径中的&lt;code&gt;/&lt;/code&gt;被转换成&lt;code&gt;_&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;路径中的&lt;code&gt;.&lt;/code&gt;被转换成&lt;code&gt;_&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;路径中的&lt;code&gt;-&lt;/code&gt;被转换成&lt;code&gt;_&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;增加前缀：
&lt;ul&gt;
&lt;li&gt;中间件模块：&lt;code&gt;XWMDCFG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设备模块：&lt;code&gt;XWCDCFG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;电路板模块：&lt;code&gt;BMCFG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三方软件模块：&lt;code&gt;XWEMCFG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;应用模块：&lt;code&gt;XWAMCFG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OEM模块：&lt;code&gt;OEMCFG&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例：
&lt;ul&gt;
&lt;li&gt;中间件模块：&lt;code&gt;xwmd/isc/xwpcp&lt;/code&gt; –&amp;gt; &lt;code&gt;XWMDCFG_isc_xwpcp&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;设备驱动模块：&lt;code&gt;xwcd/perpheral/ds/i2c/eeprom&lt;/code&gt; –&amp;gt; *&lt;code&gt;XWCDCFG_perpheral_ds_i2c_eeprom&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;电路板模块：&lt;code&gt;xwbd/fk429m/bm/stm32_cube&lt;/code&gt; –&amp;gt; &lt;code&gt;BMCFG_stm32__cube&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;第三方软件模块：&lt;code&gt;xwem/vm/l__u_a-5.4.2&lt;/code&gt; –&amp;gt; &lt;code&gt;XWEMCFG_vm_l____u__a_5_4_2&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;应用模块：&lt;code&gt;xwam/example/cxx&lt;/code&gt; –&amp;gt; &lt;code&gt;XWAMCFG_example_cxx&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;OEM模块：&lt;code&gt;oem/s32ksdk&lt;/code&gt; –&amp;gt; &lt;code&gt;OEMCFG_s32ksdk&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以借助&lt;a href=&#34;#%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD&#34;&gt;辅助功能&lt;/a&gt;中的&lt;code&gt;xwmc&lt;/code&gt;命令生成编译开关的宏标识符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;增加模块&#34;&gt;增加模块&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;中间件模块
&lt;ul&gt;
&lt;li&gt;模块位于&lt;code&gt;xwmd/&lt;/code&gt;目录中；&lt;/li&gt;
&lt;li&gt;编译开关以&lt;code&gt;XWMDCFG&lt;/code&gt;为前缀，位于文件&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwmd.h&lt;/code&gt;，
定义为&lt;code&gt;1&lt;/code&gt;表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设备驱动模块
&lt;ul&gt;
&lt;li&gt;模块位于&lt;code&gt;xwcd/&lt;/code&gt;目录中；&lt;/li&gt;
&lt;li&gt;编译开关以 &lt;code&gt;XWCDCFG&lt;/code&gt;为前缀，位于文件&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwcd.h&lt;/code&gt;，
定义为&lt;code&gt;1&lt;/code&gt;表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;电路板模块
&lt;ul&gt;
&lt;li&gt;模块位于&lt;code&gt;$(XuanWuOS_BRD_DIR)/bm/&lt;/code&gt;目录中；&lt;/li&gt;
&lt;li&gt;编译开关以&lt;code&gt;BMCFG&lt;/code&gt;为前缀，位于文件&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/board.h&lt;/code&gt;，
定义为&lt;code&gt;1&lt;/code&gt;表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三方软件模块
&lt;ul&gt;
&lt;li&gt;模块位于&lt;code&gt;xwem/&lt;/code&gt;目录中；&lt;/li&gt;
&lt;li&gt;编译开关以&lt;code&gt;XWEMCFG&lt;/code&gt;为前缀，位于文件&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwem.h&lt;/code&gt;，
定义为&lt;code&gt;1&lt;/code&gt;表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用模块
&lt;ul&gt;
&lt;li&gt;模块位于&lt;code&gt;xwam/&lt;/code&gt;目录中；&lt;/li&gt;
&lt;li&gt;编译开关以&lt;code&gt;XWAMCFG&lt;/code&gt;为前缀，位于文件&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/xwam.h&lt;/code&gt;，
定义为&lt;code&gt;1&lt;/code&gt;表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OEM模块
&lt;ul&gt;
&lt;li&gt;模块位于配置&lt;code&gt;XuanWuOS_CFG_OEMPATH&lt;/code&gt;指定的路径中；&lt;/li&gt;
&lt;li&gt;编译开关以&lt;code&gt;OEMCFG&lt;/code&gt;为前缀，位于文件&lt;code&gt;$(XuanWuOS_BRD_DIR)/cfg/oem.h&lt;/code&gt;，
定义为&lt;code&gt;1&lt;/code&gt;表示编译模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwmo.mk&lt;/code&gt;模板&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XuanWuOS_WKSPC_DIR&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;&#34;&gt;/XuanWuOS.cfg&lt;/span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含配置文件
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWBS_UTIL_MK_XWMO&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 包含一些Makefile函数，例如下面调用的getXwmoDir
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C源文件&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;            &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加C编译选项&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXSRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# C++源文件&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_CXXFLAGS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加C++编译选项&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_INCDIRS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;call getXwmoDir&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 获取模块路径并附加到头文件搜索路径&lt;/span&gt;
&lt;span style=&#34;color:#b8860b&#34;&gt;XWMO_LUASRCS&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt;           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 增加Lua源文件&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;xwbs/&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XuanWuOS_CFG_XWMO_MK&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;)&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 引用编译Makefile执行编译
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;辅助功能&#34;&gt;辅助功能&lt;/h2&gt;
&lt;p&gt;为了方便开发，XWOS定义了一些与模块编译相关的辅助命令。&lt;/p&gt;
&lt;h3 id=&#34;初始化环境&#34;&gt;初始化环境&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#a2f&#34;&gt;source&lt;/span&gt; xwbd/WeActMiniStm32H750/env.sh &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 以电路板WeActMiniStm32H750为例&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;命令&#34;&gt;命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmc&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：获取模块编译开关的C语言宏标识符。&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_PATH&lt;/span&gt;&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;}&lt;/span&gt;/xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
xwmc
&amp;gt; XWEMCFG_vm_lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 输出结果&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmn&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：获取模块的**.a**文件名。&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_PATH&lt;/span&gt;&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;}&lt;/span&gt;/xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
xwmn
&amp;gt; xwem_vm_lua.a &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 输出&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：编译整个XWOS工程，类似Android的m命令。&lt;/li&gt;
&lt;li&gt;用法：&lt;code&gt;xwm [选项] [目标]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项 -B：全部重新编译一次&lt;/li&gt;
&lt;li&gt;目标：make的目标&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;xwm &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 编译整个工程&lt;/span&gt;
xwm c &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 清理&lt;/span&gt;
xwm d &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 侧底清理&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：单独编译模块，类似Android的mm命令，使用当前路径作为模块的路径。&lt;/li&gt;
&lt;li&gt;选项 -B：全部重新编译一次&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;XWOS_PATH&lt;/span&gt;&lt;span style=&#34;color:#b68;font-weight:bold&#34;&gt;}&lt;/span&gt;/xwem/vm/lua &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# 进入到vm/lua模块中&lt;/span&gt;
xwmm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwmmm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;功能：单独编译模块，类似Android的mmm命令，需要指定模块的路径。&lt;/li&gt;
&lt;li&gt;选项 -B：全部重新编译一次&lt;/li&gt;
&lt;li&gt;用法举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;xwmmm xwem/vm/lua
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xwcroot&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：切换到XWOS的根目录，类似Android的croot命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xwcbd&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：切换到电路板目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 启动流程</title>
      <link>/docs/user-manual/boot-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/boot-flow/</guid>
      <description>
        
        
        &lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart LR
    poweron(&amp;quot;上电&amp;quot;) --&amp;gt; 低级初始化阶段 --&amp;gt; 系统初始化阶段 --&amp;gt; 用户程序

    subgraph 低级初始化阶段
        direction TB
        arch_lowlevel_init[&amp;quot;arch_lowlevel_init()&amp;quot;] --&amp;gt; cpu_lowlevel_init
        cpu_lowlevel_init[&amp;quot;cpu_lowlevel_init()&amp;quot;] --&amp;gt; soc_lowlevel_init
        soc_lowlevel_init[&amp;quot;soc_lowlevel_init()&amp;quot;] --&amp;gt; board_lowlevel_init
        board_lowlevel_init[&amp;quot;board_lowlevel_init()&amp;quot;]
    end

    subgraph 系统初始化阶段
        direction TB
        xwos_init[&amp;quot;xwos_init()&amp;quot;] --&amp;gt; arch_relocate
        arch_relocate[&amp;quot;arch_relocate()&amp;quot;] --&amp;gt; arch_init
        arch_init[&amp;quot;arch_init()&amp;quot;] --&amp;gt; cpu_init
        cpu_init[&amp;quot;cpu_init()&amp;quot;] --&amp;gt; soc_init
        soc_init[&amp;quot;soc_init()&amp;quot;] --&amp;gt; board_init
    end

    subgraph 用户程序
        direction LR
        subgraph &amp;quot;xwos_main()&amp;quot;
            direction LR
            skd[&amp;quot;启动调度器&amp;quot;]
            thd[&amp;quot;线程初始化&amp;quot;]
            device[&amp;quot;设备驱动初始化&amp;quot;]
            libc[&amp;quot;C/C++标准库初始化&amp;quot;]
            lua[&amp;quot;Lua虚拟机初始化&amp;quot;]
        end
    end
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;低级初始化阶段&#34;&gt;低级初始化阶段&lt;/h2&gt;
&lt;p&gt;低级初始化阶段，程序只能访问寄存器，不可以访问全局变量。&lt;/p&gt;
&lt;h4 id=&#34;arch_lowlevel_init&#34;&gt;&lt;code&gt;arch_lowlevel_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;架构层的低级初始化，例如：ARM的异常、数据cache、指令cache、
浮点运算单元等的初始化。&lt;/p&gt;
&lt;h4 id=&#34;cpu_lowlevel_init&#34;&gt;&lt;code&gt;cpu_lowlevel_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;CPU层的低级初始化。&lt;/p&gt;
&lt;h4 id=&#34;soc_lowlevel_init&#34;&gt;&lt;code&gt;soc_lowlevel_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;SOC层的低级初始化。&lt;/p&gt;
&lt;h4 id=&#34;board_lowlevel_init&#34;&gt;&lt;code&gt;board_lowlevel_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;电路板的低级初始化。通常系统的时钟、电源等在这一层进行进行初始化。&lt;/p&gt;
&lt;h2 id=&#34;系统初始化阶段&#34;&gt;系统初始化阶段&lt;/h2&gt;
&lt;h4 id=&#34;xwos_init&#34;&gt;&lt;code&gt;xwos_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;初始化玄武OS的数据段(.xwos.data)，并初始化最简单的内核内存分配器。&lt;/p&gt;
&lt;h4 id=&#34;arch_relocate&#34;&gt;&lt;code&gt;arch_relocate()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;初始化用户的数据段(.data)，经过此函数之后，用户才可以访问全局变量。&lt;/p&gt;
&lt;h4 id=&#34;arch_init&#34;&gt;&lt;code&gt;arch_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;架构层的初始化。&lt;/p&gt;
&lt;h4 id=&#34;cpu_init&#34;&gt;&lt;code&gt;cpu_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;CPU层的初始化。&lt;/p&gt;
&lt;h4 id=&#34;soc_init&#34;&gt;&lt;code&gt;soc_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;SOC层的初始化。通常中断控制器在这一层进行初始化。&lt;/p&gt;
&lt;h4 id=&#34;board_init&#34;&gt;&lt;code&gt;board_init()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;电路板的初始化。通常外设驱动在此处进行初始化，例如：SDRAM、GPIO、DMA等。&lt;/p&gt;
&lt;h2 id=&#34;用户程序&#34;&gt;用户程序&lt;/h2&gt;
&lt;h4 id=&#34;xwos_main&#34;&gt;&lt;code&gt;xwos_main()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;用户程序主函数，用户可在此处建立一个主线程，然后启动调度器。
主线程中还可以初始化设备驱动、初始化C/C++标准库、初始化Lua虚拟机、启动子线程等。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 中断控制</title>
      <link>/docs/user-manual/irq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/irq/</guid>
      <description>
        
        
        &lt;h2 id=&#34;约束&#34;&gt;约束&lt;/h2&gt;
&lt;h3 id=&#34;异常与中断&#34;&gt;异常与中断&lt;/h3&gt;
&lt;p&gt;XWOS将中断分为EXC和IRQ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EXC是指架构中定义的中断，在某些架构中被称为&lt;strong&gt;异常(Exception)&lt;/strong&gt;，中断号用负数表示；&lt;/li&gt;
&lt;li&gt;IRQ是指外设中断，例如UART的中断等，中断号用0和正数表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断优先级&#34;&gt;中断优先级&lt;/h3&gt;
&lt;p&gt;XWOS对中断优先级的要求：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt; 调度器服务中断
切换上下文的中断 &amp;lt; 其他中断 &amp;lt; 调度器服务中断
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;中断向量&#34;&gt;中断向量&lt;/h2&gt;
&lt;p&gt;中断向量通常位于&lt;code&gt;ivt.c&lt;/code&gt;文件中，此文件可能存放在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwbd/电路板名称/bdl&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwbd/电路板名称/bm&lt;/code&gt;下的某个&lt;a href=&#34;../build-system#%E7%8E%84%E6%AD%A6%E6%A8%A1%E5%9D%97&#34;&gt;玄武模块&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS要求给出下列形式的中断向量的定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;__xwos_ivt __xwos_ivt_qualifier &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; soc_ivt xwospl_ivt;
__xwos_ivt_qualifier &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; soc_idvt xwospl_idvt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__xwos_ivt&lt;/code&gt;：中断向量的段落属性&lt;code&gt;.xwos.ivt&lt;/code&gt;，链接脚本通过此属性，识别
中断向量，并在链接时将它安排在特定的内存区域内；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__xwos_ivt_qualifier&lt;/code&gt;：中断向量的读写修饰符，与&lt;code&gt;xwbd/电路板/cfg/soc.h&lt;/code&gt;中配置有关，
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_RO_IVT&lt;/code&gt;配置为1：&lt;code&gt;__xwos_ivt_qualifier&lt;/code&gt;为&lt;code&gt;const&lt;/code&gt;，表示只读；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOCCFG_RO_IVT&lt;/code&gt;配置为0：&lt;code&gt;__xwos_ivt_qualifier&lt;/code&gt;为空，表示可读写；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct soc_ivt&lt;/code&gt;：操作系统移植实现层(XWOSIMPL)中需要定义的&lt;strong&gt;中断向量表结构体类型&lt;/strong&gt;，
在&lt;code&gt;xwosimpl_soc_irq.h&lt;/code&gt;文件中定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_ivt&lt;/code&gt;：中断向量表结构体；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct soc_idvt&lt;/code&gt;：操作系统移植实现层(XWOSIMPL)中需要定义的&lt;strong&gt;中断数据表结构体类型&lt;/strong&gt;，
在&lt;code&gt;xwosimpl_soc_irq.h&lt;/code&gt;文件中定义，用于给每个中断存放私有数据；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_idvt&lt;/code&gt;：中断数据表结构体。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的SOC，中断向量的实现可能有细微的差异，具体可参考移植笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;TBD&#34;&gt;ARMv6/v7/v8-M&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;TBD&#34;&gt;GD32V&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;TBD&#34;&gt;MPC560x&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cpu总中断&#34;&gt;CPU总中断&lt;/h2&gt;
&lt;p&gt;XWOS可对CPU的总中断开关进行操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos_cpuirq_disable_lc()&lt;/code&gt;：关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_cpuirq_enable_lc()&lt;/code&gt;：开启&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_cpuirq_save_lc()&lt;/code&gt;：保存当前开关状态后关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_cpuirq_restore_lc()&lt;/code&gt;：恢复之前保存的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS要求操作系统移植实现层(XWOSIMPL)中给出上面4个函数的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件：&lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_disable_lc()&lt;/code&gt;：关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_enable_lc()&lt;/code&gt;：开启&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_save_lc()&lt;/code&gt;：保存当前开关状态后关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_cpuirq_restore_lc()&lt;/code&gt;：恢复之前保存的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用局限&#34;&gt;使用局限&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关闭与开启CPU总中断开关需要确保不会发生嵌套，例如下面的嵌套代码就是&lt;strong&gt;错误&lt;/strong&gt;的：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        xwos_cpuirq_disable_lc();
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区 ... */&lt;/span&gt;
        xwos_cpuirq_enable_lc();
&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;}

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func0&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        xwos_cpuirq_disable_lc();
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区 ... */&lt;/span&gt;
        func1(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 错误！！！发生嵌套 */&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区 ... */&lt;/span&gt;
        xwos_cpuirq_enable_lc();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当关闭中断的代码发生嵌套时，需要保存与恢复CPU总中断开关，上面的例子可以更正为：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        xwreg_t cpuirq;

        xwos_cpuirq_save_lc(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq);
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区 ... */&lt;/span&gt;
        xwos_cpuirq_restore_lc(cpuirq);
}

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func0&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        xwreg_t cpuirq;

        xwos_cpuirq_save_lc(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cpuirq);
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区 ... */&lt;/span&gt;
        func1();
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... 临界区 ... */&lt;/span&gt;
        xwos_cpuirq_restore_lc(cpuirq);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;外设中断&#34;&gt;外设中断&lt;/h2&gt;
&lt;p&gt;XWOS可对CPU的外设中断进行控制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_request()&lt;/code&gt;：申请中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_release()&lt;/code&gt;：释放中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_enable()&lt;/code&gt;：开启中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_disable()&lt;/code&gt;：关闭中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_save()&lt;/code&gt;：保存中断的开关，然后将其关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_restore()&lt;/code&gt;：恢复中断的开关&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_pend()&lt;/code&gt;：挂起中断标志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_clear()&lt;/code&gt;：清除中断标志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_tst()&lt;/code&gt;：测试中断是否挂起&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_cfg()&lt;/code&gt;：配置中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_get_cfg()&lt;/code&gt;：获取中断的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_get_data()&lt;/code&gt;：获取中断的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_irq_get_id()&lt;/code&gt;；判断当前的上下文是否为中断上下文，并取得当前中断的中断号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS要求操作系统移植实现层(XWOSIMPL)中给出上面4个函数的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件：&lt;code&gt;xwosimpl_irq.h/xwosimpl_irq.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_request()&lt;/code&gt;：申请中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_release()&lt;/code&gt;：释放中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_enable()&lt;/code&gt;：开启中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_disable()&lt;/code&gt;：关闭中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_save()&lt;/code&gt;：保存中断的开关，然后将其关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_restore()&lt;/code&gt;：恢复中断的开关&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_pend()&lt;/code&gt;：挂起中断标志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_clear()&lt;/code&gt;：清除中断标志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_tst()&lt;/code&gt;：测试中断是否挂起&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_cfg()&lt;/code&gt;：配置中断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_get_cfg()&lt;/code&gt;：获取中断的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_get_data()&lt;/code&gt;：获取中断的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwospl_irq_get_id()&lt;/code&gt;；判断当前的上下文是否为中断上下文，并取得当前中断的中断号&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api与示例&#34;&gt;API与示例&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;文档未及时更新时，以头文件&lt;code&gt;xwos/osal/irq.h&lt;/code&gt;中注释为准；&lt;/li&gt;
&lt;li&gt;API详细说明与示例：&lt;a href=&#34;TBD&#34;&gt;API手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 调度器</title>
      <link>/docs/user-manual/skd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/skd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS调度器最基本的调度单位是&lt;strong&gt;线程&lt;/strong&gt;，暂时不支持&lt;strong&gt;MMU虚拟内存&lt;/strong&gt;与&lt;strong&gt;进程&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;每个&lt;strong&gt;线程&lt;/strong&gt;都有自己独立的&lt;strong&gt;栈&lt;/strong&gt;内存，但所有内存对所有线程都可见，除非使用MPU增加限制；&lt;/li&gt;
&lt;li&gt;每个&lt;strong&gt;线程&lt;/strong&gt;都有调度优先级，优先级的值越&lt;strong&gt;小&lt;/strong&gt;，优先级越&lt;strong&gt;低&lt;/strong&gt;，优先级的值越&lt;strong&gt;大&lt;/strong&gt;，优先级越&lt;strong&gt;高&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;调度器始终选择优先级最高的线程，高优先级的线程可以抢占低优先级的线程；&lt;/li&gt;
&lt;li&gt;相同的优先级的线程，调度器按照先进先出的方法调度，同优先级线程之间不能相互抢占；&lt;/li&gt;
&lt;li&gt;调度器可以冻结线程，支持电源管理；&lt;/li&gt;
&lt;li&gt;每个CPU都有自己独立的调度器，线程只能在自身CPU的调度器中调度，如果需要在CPU间移动，
需要进行&lt;strong&gt;迁移&lt;/strong&gt;操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度算法&#34;&gt;调度算法&lt;/h2&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个优先级都有一个先进先出(FIFO)的&lt;strong&gt;就绪&lt;/strong&gt;队列；&lt;/li&gt;
&lt;li&gt;使用一个位图标记每个优先级队列是否为空；非空的队列对应的位被置1，否则被清0。&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/user-manual/skd/ready-queue_hu9b60b1c85faa2d0c7a8cad73f43546b4_90524_680x680_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;680&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS调度器就绪队列
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;调度流程&#34;&gt;调度流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义操作&lt;strong&gt;fls&lt;/strong&gt;：从最高位起查找第一个被置1的位，并返回其序号，
如果所有位都为0，返回-1。此操作需要CPU的相关指令来实现，例如ARM的clz，
DEC Alpha的ctlz，x86的lzcnt，PowerPC的cntlz等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流程图&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart TB
    start --&amp;gt; fls
    fls --&amp;gt; idx
    idx --否--&amp;gt; idle
    idx --是--&amp;gt; q
    q --&amp;gt; t
    t --&amp;gt; skd
    skd --&amp;gt; e
    idle --&amp;gt; e

    start(&amp;quot;开始&amp;quot;)
    fls[&amp;quot;idx = fls(bitmap)&amp;quot;]
    idx{&amp;quot;idx &amp;gt;= 0 ?&amp;quot;}
    idle[&amp;quot;调度空闲任务&amp;quot;]
    q[&amp;quot;选择优先级为idx的就绪队列&amp;quot;]
    t[&amp;quot;从就绪队列头部选择第一个线程&amp;quot;]
    skd[&amp;quot;调度选择的线程&amp;quot;]
    e(&amp;quot;结束&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;调度器中的特殊任务&#34;&gt;调度器中的特殊任务&lt;/h2&gt;
&lt;h3 id=&#34;空闲任务&#34;&gt;空闲任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当调度器中没有任何线程&lt;strong&gt;就绪&lt;/strong&gt;，调度器会调度空闲任务；&lt;/li&gt;
&lt;li&gt;空闲任务比较特殊，属于&lt;strong&gt;最低优先级&lt;/strong&gt;的线程，但不能使用任何会导致睡眠、阻塞的函数。&lt;/li&gt;
&lt;li&gt;用户可在空闲任务中HOOK用户代码，方法：
&lt;ul&gt;
&lt;li&gt;在配置文件&lt;code&gt;xwbd/电路板/cfg/board.h&lt;/code&gt;中定义配置&lt;code&gt;BRDCFG_XWSKD_IDLE_HOOK&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;定义函数&lt;code&gt;board_xwskd_idle_hook()&lt;/code&gt;并在其中增加用户代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断底半部任务&#34;&gt;中断底半部任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当调度器配置&lt;code&gt;XWMPCFG_SD_BH&lt;/code&gt;（多核）或&lt;code&gt;XWUPCFG_SD_BH&lt;/code&gt;（单核）为&lt;code&gt;1&lt;/code&gt;时，
调度器会为系统预留一个&lt;strong&gt;最高优先级&lt;/strong&gt;线程；&lt;/li&gt;
&lt;li&gt;中断底半部任务比较特殊，属于线程上下文，但不能使用任何会导致睡眠、阻塞的函数；&lt;/li&gt;
&lt;li&gt;中断底半部任务可抢占任何线程；&lt;/li&gt;
&lt;li&gt;当开启中断底半部时，调度器的滴答定时器任务运行在中断底半部中；&lt;/li&gt;
&lt;li&gt;XWOS的中断底半部并未完全开发完成，目前只开放给滴答定时器任务使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滴答定时器任务&#34;&gt;滴答定时器任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作系统内核通常都会包含一个定时器，用于产生固定周期的“&lt;strong&gt;滴答&lt;/strong&gt;”（或称为“&lt;strong&gt;节拍&lt;/strong&gt;”）中断；&lt;/li&gt;
&lt;li&gt;滴答定时器任务也即是在此定时器中断中执行的周期性任务；&lt;/li&gt;
&lt;li&gt;如果&lt;a href=&#34;#%E4%B8%AD%E6%96%AD%E5%BA%95%E5%8D%8A%E9%83%A8%E4%BB%BB%E5%8A%A1&#34;&gt;中断底半部任务&lt;/a&gt;配置为&lt;code&gt;1&lt;/code&gt;，滴答定时器任务运行在中断底半部任务内部；&lt;/li&gt;
&lt;li&gt;如果&lt;a href=&#34;#%E4%B8%AD%E6%96%AD%E5%BA%95%E5%8D%8A%E9%83%A8%E4%BB%BB%E5%8A%A1&#34;&gt;中断底半部任务&lt;/a&gt;配置为&lt;code&gt;0&lt;/code&gt;，滴答定时器任务运行在中断上下文中；&lt;/li&gt;
&lt;li&gt;用户可以在滴答定时器任务中HOOK自己的代码，方法：
&lt;ul&gt;
&lt;li&gt;在配置文件&lt;code&gt;xwbd/电路板/cfg/board.h&lt;/code&gt;中定义配置&lt;code&gt;BRDCFG_XWSKD_SYSHWT_HOOK&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;定义函数&lt;code&gt;board_xwskd_syshwt_hook()&lt;/code&gt;并在其中增加用户代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度器的中断&#34;&gt;调度器的中断&lt;/h2&gt;
&lt;h3 id=&#34;切换上下文的中断&#34;&gt;切换上下文的中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调度器用于切换正在执行的线程的中断&lt;/li&gt;
&lt;li&gt;中断优先级：最低&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滴答定时器的中断&#34;&gt;滴答定时器的中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于产生固定周期的“&lt;strong&gt;滴答&lt;/strong&gt;”（或称为“&lt;strong&gt;节拍&lt;/strong&gt;”）的定时器中断，
&lt;a href=&#34;#%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1&#34;&gt;滴答定时器任务&lt;/a&gt;由此中断触发执行&lt;/li&gt;
&lt;li&gt;中断优先级：&lt;code&gt;切换上下文的中断 &amp;lt;= 滴答定时器的中断 &amp;lt; 调度器服务中断&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度器服务中断&#34;&gt;调度器服务中断&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于执行调度器特殊操作的软中断，包括：
&lt;ul&gt;
&lt;li&gt;调度器暂停 &lt;code&gt;xwosplcb_skd_suspend_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程退出 &lt;code&gt;xwosplcb_thd_exit_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程冻结 &lt;code&gt;xwosplcb_thd_freeze_lic()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程迁移 &lt;code&gt;xwosplcb_thd_immigrate_lic()&lt;/code&gt;和&lt;code&gt;xwosplcb_thd_outmigrate_lic()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断优先级：最高&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;切换上下文的中断 &amp;lt; 其他中断 &amp;lt; 调度器服务中断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;硬件定时器&#34;&gt;硬件定时器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;XWOS内核要求每个CPU都有一个私有的滴答定时器，产生固定频率的中断；&lt;/li&gt;
&lt;li&gt;通常配置为1000HZ，参考配置文件&lt;code&gt;xwbd/电路板/cfg/xwos.h&lt;/code&gt;中的
配置&lt;code&gt;XWMPCFG_SYSHWT_PERIOD&lt;/code&gt;（多核）或&lt;code&gt;XWUPCFG_SYSHWT_PERIOD&lt;/code&gt;（单核）；&lt;/li&gt;
&lt;li&gt;XWOS的滴答定时器会产生三个变量：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt;滴答计数
&lt;ul&gt;
&lt;li&gt;在每次滴答定时器中断时，&lt;code&gt;tickcount&lt;/code&gt;都会自增1；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt;可以表示滴答定时器中断了多少次；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tickcount&lt;/code&gt;是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的&lt;code&gt;tickcount&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;通过API&lt;code&gt;xwos_skd_get_tickcount_lc()&lt;/code&gt;可以获取当前CPU的&lt;code&gt;tickcount&lt;/code&gt;，
API的后缀&amp;quot;&lt;strong&gt;_lc&lt;/strong&gt;&amp;ldquo;表示此函数是一个&lt;strong&gt;Local CPU&lt;/strong&gt;函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt;滴答时间
&lt;ul&gt;
&lt;li&gt;XWOS内核使用**纳秒(ns)**作为时间的基本单位，假设滴答器频率1000HZ，
&lt;code&gt;tickcount&lt;/code&gt;每1ms增加一次，即每1ms增加&lt;code&gt;(xwtm_t)1000000&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt;与&lt;code&gt;tickcount&lt;/code&gt;的关系：&lt;code&gt;timetick = tickcount * (xwtm_t)1000000&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timetick&lt;/code&gt;是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的&lt;code&gt;timetick&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;通过API&lt;code&gt;xwos_skd_get_timetick_lc()&lt;/code&gt;可以获取当前CPU的&lt;code&gt;timetick&lt;/code&gt;，
API的后缀&amp;rdquo;&lt;strong&gt;_lc&lt;/strong&gt;&amp;ldquo;表示此函数是一个&amp;rdquo;&lt;strong&gt;Local CPU&lt;/strong&gt;&amp;ldquo;函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;时间戳
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;是以纳秒为单位的时间戳；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;会使用滴答定时器中计数器的数值，计算精确到纳秒的时间戳，
但精度由SOC的主频与计数器的位宽决定；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的&lt;code&gt;timestamp&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;通过API&lt;code&gt;xwos_skd_get_timestamp_lc()&lt;/code&gt;可以获取当前CPU的&lt;code&gt;timestamp&lt;/code&gt;，
API的后缀&amp;rdquo;&lt;strong&gt;_lc&lt;/strong&gt;&amp;ldquo;表示此函数是一个&amp;rdquo;&lt;strong&gt;Local CPU&lt;/strong&gt;&amp;ldquo;函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;超时管理&#34;&gt;超时管理&lt;/h2&gt;
&lt;h3 id=&#34;原理--时间树&#34;&gt;原理 —— 时间树&lt;/h3&gt;
&lt;p&gt;XWOS内核中，每个需要超时管理的对象（线程、软件定时器）都是以&lt;strong&gt;时间树节点&lt;/strong&gt;组织
到时间树中。&lt;strong&gt;时间树节点&lt;/strong&gt;中包含了超时的&lt;strong&gt;滴答时间&lt;/strong&gt;，调度器每次进入
滴答定时器任务时，都会检测时间树中是否有节点超时。在时间树中，所有节点的滴答
时间都是未来的时间。最先超时的节点的滴答时间一定是最小值。
因此时间树的超时问题是寻找最小值的问题。
XWOS使用红黑树解决此最小值的问题，因此算法原理被称为时间树：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用一个&lt;strong&gt;leftmost&lt;/strong&gt;指针指向最小值，需要时可直接从&lt;strong&gt;leftmost&lt;/strong&gt;快速获取；&lt;/li&gt;
&lt;li&gt;超时后，&lt;strong&gt;leftmost&lt;/strong&gt;从红黑树中被删除，按照二叉树的性质，下一任&lt;strong&gt;leftmost&lt;/strong&gt;是
前任的右孩子（即后继）。如果前任的右孩子为叶子，下一任&lt;strong&gt;leftmost&lt;/strong&gt;一定是
前任的父节点；&lt;/li&gt;
&lt;li&gt;红黑树中不允许存在关键字相同的节点，因此拥有相同超时滴答时间的节点相互
形成链表，超时后它们全部被唤醒。&lt;/li&gt;
&lt;/ul&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 690px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/user-manual/skd/timetree_hu5a14de9a02930993b5ae32946216e0fc_64326_680x490_fill_catmullrom_smart1_3.png&#34; width=&#34;680&#34; height=&#34;490&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS时间树
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;h3 id=&#34;超时函数的统一形式&#34;&gt;超时函数的统一形式&lt;/h3&gt;
&lt;p&gt;当调用带超时管理的API，传入时间参数时，都是通过一个```xwtm_t``类型的指针传入，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 睡眠 */&lt;/span&gt;
xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cthd_sleep&lt;/span&gt;(xwtm_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwtm);

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号量 */&lt;/span&gt;
xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sem_timedwait&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sem &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sem, xwtm_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwtm);

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待条件量 */&lt;/span&gt;
xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_cond_timedwait&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_cond &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; cond,
                           &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;union&lt;/span&gt; xwlk_ulock lock, xwsq_t lktype,
                           &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; lkdata, xwtm_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwtm, xwsq_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; lkst);

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待互斥锁 */&lt;/span&gt;
xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_mtx_timedlock&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_mtx &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; mtx, xwtm_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwtm);


&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待信号旗 */&lt;/span&gt;
xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_flg_timedwait&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_flg &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; flg, xwsq_t trigger, xwsq_t action,
                          xwbmp_t origin[], xwbmp_t msk[],
                          xwtm_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwtm);

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 选择信号选择器 */&lt;/span&gt;
xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_sel_timedselect&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_sel &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; sel,
                            xwbmp_t msk[], xwbmp_t trg[],
                            xwtm_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwtm);

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程同步 */&lt;/span&gt;
xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_br_timedsync&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; xwos_br &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; br, xwsq_t pos,
                         xwbmp_t sync[], xwtm_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; xwtm);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是因为&lt;code&gt;xwtm&lt;/code&gt;指向的缓冲区既作为&lt;strong&gt;输入&lt;/strong&gt;，又作为&lt;strong&gt;输出&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为输入时，表示期望的超时时间；&lt;/li&gt;
&lt;li&gt;作为输出时，返回剩余的时间。超时后，剩余的时间应该小于等于0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设调用&lt;code&gt;xwos_mtx_timedlock()&lt;/code&gt;时，&lt;code&gt;disired&lt;/code&gt;作为输入，期望等待10s。&lt;/li&gt;
&lt;li&gt;4s后就已获得互斥锁，函数返回，&lt;code&gt;disired&lt;/code&gt;作为输出，剩余时间为(10 - 4) = 6s。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 等待互斥锁 */&lt;/span&gt;
{
        xwer_t rc;
        xwtm_t disired;

        disired &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; XWTM_S;
        rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; xwos_mtx_timedlock(mid, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;disired);
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (XWOK &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; rc) {
                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 临界区 */&lt;/span&gt;
                xwos_mtx_unlock(mid);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;多核与单核&#34;&gt;多核与单核&lt;/h2&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;文档未及时更新时，以头文件&lt;code&gt;xwos/osal/skd.h&lt;/code&gt;中注释为准；&lt;/li&gt;
&lt;li&gt;API详细说明与示例：&lt;a href=&#34;TBD&#34;&gt;API手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 线程</title>
      <link>/docs/user-manual/thd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/thd/</guid>
      <description>
        
        
        &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;线程是操作系统最基本的调度单位，在其他RTOS中可能称之为&lt;strong&gt;任务&lt;/strong&gt;。XWOS的线程，
除了最基本的运行、睡眠、退出操作外，还支持冻结与解冻，迁移等操作。&lt;/p&gt;
&lt;h3 id=&#34;线程的状态&#34;&gt;线程的状态&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 760px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/user-manual/thd/thread-state_huaec0f5f93355fc1242cf72cb5941b922_44070_750x500_fill_catmullrom_smart1_3.png&#34; width=&#34;750&#34; height=&#34;500&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
XWOS线程状态图
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;待命（standby）&lt;/strong&gt; ：线程对象已被初始化，但未指定主函数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪（ready）&lt;/strong&gt; ：线程已加入到就绪队列中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行（running）&lt;/strong&gt; ：线程正在运行，每个CPU中只可能存在一个线程正在运行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;睡眠（sleeping）&lt;/strong&gt; ：线程正在睡眠；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞（blocking）&lt;/strong&gt; ：线程正在等待，可与&lt;strong&gt;睡眠&lt;/strong&gt;态组合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冻结（frozen）&lt;/strong&gt; ：线程已被冻结；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;退出（exiting）&lt;/strong&gt; ：线程即将结束；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迁移（migrating）&lt;/strong&gt; ：线程正处于迁移到别的CPU的过程中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程属性&#34;&gt;线程属性&lt;/h3&gt;
&lt;p&gt;线程在创建时，可通过参数&lt;code&gt;attr&lt;/code&gt;设定其属性，取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKDATTR_PRIVILEGED&lt;/code&gt;：表示线程拥有系统特权，
&lt;ul&gt;
&lt;li&gt;CPU的一些寄存器需要开启特权后才可访问，例如全局中断的开关：
&lt;ul&gt;
&lt;li&gt;在ARMv6m/ARMv7m中，是通过&lt;strong&gt;CONTROL&lt;/strong&gt;寄存器的bit0(nPRIV)来实现的；&lt;/li&gt;
&lt;li&gt;在Embedded PowerPC中，是通过&lt;strong&gt;MSR&lt;/strong&gt;寄存器的bit17(PR)来实现的；&lt;/li&gt;
&lt;li&gt;在Embedded PowerPC中，是通过&lt;strong&gt;MCAUSE&lt;/strong&gt;寄存器的bit28和bit29(MPP)来实现的；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKDATTR_DETACHED&lt;/code&gt;：表示线程是分离的
&lt;ul&gt;
&lt;li&gt;类似于POSIX线程的detached属性，DETACHED的线程退出后，系统自动回收其资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKDATTR_JOINABLE&lt;/code&gt;：表示线程是可连接的，此为默认属性
&lt;ul&gt;
&lt;li&gt;类似于POSIX线程的joinable属性，JOINABLE的线程退出后，父线程必须
调用&lt;code&gt;xwos_thd_stop()&lt;/code&gt;或&lt;code&gt;xwos_thd_join()&lt;/code&gt;回收其资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的创建初始化与删除销毁&#34;&gt;线程的创建、初始化与删除、销毁&lt;/h2&gt;
&lt;p&gt;XWOS内核提供静态初始化和动态创建两种方式建立线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化与销毁
&lt;ul&gt;
&lt;li&gt;初始化：&lt;code&gt;xwos_thd_init()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;销毁：&lt;code&gt;xwos_thd_fini()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt;是指用户预先定义对象，这些对象在编译时由编译器分配内存；&lt;/li&gt;
&lt;li&gt;静态初始化线程还需预先定义栈数组，作用域应该为全局。
栈数组的首地址与大小，必须要满足CPU的ABI规则，例如ARM，就要求8字节对齐，
因此在定义栈数组时需要使用&lt;code&gt;__xwcc__aligned(8)&lt;/code&gt;来修饰，且大小是8的倍数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态创建与删除
&lt;ul&gt;
&lt;li&gt;创建：&lt;code&gt;xwos_thd_create()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;删除：&lt;code&gt;xwos_thd_delete()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt;是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存，
并把这块内存初始化为所需要的对象。使用完毕后，需要通过删除来释放内存；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt;方式创建的线程，其栈内存地址对齐问题由操作系统内核处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的睡眠&#34;&gt;线程的睡眠&lt;/h2&gt;
&lt;p&gt;线程睡眠常用来做精度要求不高的延迟，XWOS内核提供两种睡眠方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xwos_cthd_sleep()&lt;/code&gt;：睡眠的时间的起点相对于当前的系统时间，这种方式使用简单，但精度较低；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xwos_cthd_sleep_from()&lt;/code&gt;：睡眠时间的起点由调用者提供，这种方式用来做精确的周期性定时。
第一次调用时，需要提供初始时间起点和增量，此函数超时返回时，会返回当前超时的系统时间，
可作为下一次调用的时间起点，由此循环可形成精准的周期性定时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的退出与返回值&#34;&gt;线程的退出与返回值&lt;/h2&gt;
&lt;h3 id=&#34;线程的退出&#34;&gt;线程的退出&lt;/h3&gt;
&lt;p&gt;线程退出通常有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主函数直接&lt;code&gt;return&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;foo_task_thd&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
{
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 省略 ... */&lt;/span&gt;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;主函数中调用&lt;code&gt;xwos_cthd_exit(rc)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此API的用法类似于POSIX中的函数&lt;code&gt;pthread_exit()&lt;/code&gt;，调用的线程会立即终止并抛出返回值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;foo_task_thd&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;arg)
{
        xwer_t rc;
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 省略 ... */&lt;/span&gt;
        xwos_cthd_exit(rc); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程在此处结束，并抛出返回值rc */&lt;/span&gt;
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 后面的代码不再执行 ... */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;线程的退出的方式&#34;&gt;线程的退出的方式&lt;/h3&gt;
&lt;p&gt;XWOS的线程类似于pthread，分为Detached属性与Joinable属性，可在创建线程时的&lt;code&gt;attr&lt;/code&gt;参
数中指明属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKDATTR_DETACHED&lt;/code&gt;：线程是分离的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XWOS_SKDATTR_JOINABLE&lt;/code&gt;：线程是可连接的（默认属性）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;xwos_skdattr_joinable线程&#34;&gt;&lt;code&gt;XWOS_SKDATTR_JOINABLE&lt;/code&gt;线程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;类似于POSIX线程的Joinable属性，JOINABLE的线程退出后，父线程必须
调用&lt;code&gt;xwos_thd_stop()&lt;/code&gt;或&lt;code&gt;xwos_thd_join()&lt;/code&gt;回收其资源；&lt;/li&gt;
&lt;li&gt;父线程可通过&lt;code&gt;xwos_thd_stop()&lt;/code&gt;或&lt;code&gt;xwos_thd_join()&lt;/code&gt;获取子线程退出时抛出的返回值；&lt;/li&gt;
&lt;li&gt;函数&lt;code&gt;xwos_thd_stop()&lt;/code&gt;或&lt;code&gt;xwos_thd_join()&lt;/code&gt;会阻塞调用的父线程，直到子线程退出；&lt;/li&gt;
&lt;li&gt;函数&lt;code&gt;xwos_thd_cancel()&lt;/code&gt;只通知子线程退出，不会等待；&lt;/li&gt;
&lt;li&gt;函数&lt;code&gt;xwos_thd_join()&lt;/code&gt;只会等待子线程退出，不会通知子线程退出；&lt;/li&gt;
&lt;li&gt;函数&lt;code&gt;xwos_thd_stop()&lt;/code&gt;会先通知子线程退出，再等待子线程退出，相当
于&lt;code&gt;xwos_thd_cancel()&lt;/code&gt;+&lt;code&gt;xwos_thd_join()&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;xwos_skdattr_detached线程&#34;&gt;&lt;code&gt;XWOS_SKDATTR_DETACHED&lt;/code&gt;线程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;类似于POSIX线程的detached属性，DETACHED的线程退出后，系统自动回收其资源。&lt;/li&gt;
&lt;li&gt;不可对DETACHED的线程使用&lt;code&gt;xwos_thd_join()&lt;/code&gt;和&lt;code&gt;xwos_thd_stop()&lt;/code&gt;，
但可使用&lt;code&gt;xwos_thd_cancel()&lt;/code&gt;通知其退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程的退出通知&#34;&gt;线程的退出通知&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;子线程收到退出通知后，只会中断阻塞态和睡眠态，并不会被**“暗杀”**；&lt;/li&gt;
&lt;li&gt;子线程可通过&lt;code&gt;xwos_cthd_shld_stop()&lt;/code&gt;获取是否收到了退出通知；&lt;/li&gt;
&lt;li&gt;子线程收到退出通知后，可以选择忽略，也可选择清理资源后退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;thread_main&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; arg)
{
        xwer_t rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; XWOK;

        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;xwos_cthd_shld_stop()) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 判断是否收到了退出通知 */&lt;/span&gt;
                &lt;span style=&#34;&#34;&gt;线程循环&lt;/span&gt;...;
        }
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;线程的冻结与解冻&#34;&gt;线程的冻结与解冻&lt;/h2&gt;
&lt;h3 id=&#34;冻结&#34;&gt;冻结&lt;/h3&gt;
&lt;p&gt;线程的冻结，是用来支持内核的一些特殊功能的。用户不能随意冻结线程。
在以下情况，XWOS内核要求线程进入冻结状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统准备进入低功耗模式。如果此时线程还在运行，很有可能因其正在访问硬件资源、
占用锁，导致系统关闭硬件、清理资源时发生异常。因此线程需要运行到一个
特殊的点后冻结，这个点就是&lt;strong&gt;冻结点&lt;/strong&gt;。线程进入冻结点前，需要返回到最外层的
主函数中，并释放掉所有的锁和硬件资源。&lt;/li&gt;
&lt;li&gt;线程迁移至另一个CPU。线程迁移时，也需要返回至最外层的冻结点，保证不能占用当前
CPU的任何资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解冻&#34;&gt;解冻&lt;/h3&gt;
&lt;p&gt;线程的解冻一般不由用户来操作，系统完成特殊功能后会自动对线程进行解冻：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统退出低功耗模式时；&lt;/li&gt;
&lt;li&gt;线程迁移操作已经完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;XWOS的线程被要求进入冻结时，会中断阻塞态或睡眠态，这些函数会返回
错误码-EINTR。然后线程可由此释放掉占用的锁和资源，最后执行到主函数的冻结点进行冻结。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;foo_task_thread&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;arg)
{
        xwer_t rc;
        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; was_frz;

        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 初始化... */&lt;/span&gt;

        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 冻结点在函数xwos_cthd_frz_shld_stop()内部：
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 此函数会判断当前线程是否需要冻结，若是，在函数内部冻结线程，冻结点在函数内部；
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 此函数同时还判断线程是否需要退出，若是，返回false；
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 线程解冻时，从此函数内部冻结点继续执行，直至返回；
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 此函数的参数用来告诉用户刚才线程是否被冻结过，若是，was_frz被置为true，否则为false。
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;        */&lt;/span&gt;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;xwos_cthd_frz_shld_stop(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;was_frz)) {
                &lt;span style=&#34;&#34;&gt;线程循环&lt;/span&gt;...;
        }
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的例子比较简单，在不需要释放锁和资源的场合使用。如果线程冻结前需要
做一些清理操作，可以这样来写主函数中的循环：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;foo_task_thread&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;arg)
{
        xwer_t rc;

        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 初始化... */&lt;/span&gt;

        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程循环 */&lt;/span&gt;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;xwos_cthd_shld_stop()) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 只判断线程是否需要退出 */&lt;/span&gt;
                rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; fsm(...); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 在状态机中阻塞在某个同步对象或锁上 */&lt;/span&gt;
                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;EINTR &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; rc) {
                        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程的阻塞态或睡眠态被中断时，会收到错误码-EINTR，
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                           进一步判断是否被系统要求冻结。 */&lt;/span&gt;
                        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (xwos_cthd_shld_frz()) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 判断是否需要冻结 */&lt;/span&gt;
                                free_resource(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 释放锁和资源... */&lt;/span&gt;
                                xwos_cthd_freeze(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 冻结点 */&lt;/span&gt;
                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 线程解冻后，代码回到这里，如果对线程进行了迁移，
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                                   另一个CPU从此处开始运行此线程 */&lt;/span&gt;
                                alloc_resource(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 重新请求资源和锁... */&lt;/span&gt;
                        } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 处理其他原因导致的中断，例如终止请求 */&lt;/span&gt;
                        }
                }
        }

        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; rc;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;线程的迁移&#34;&gt;线程的迁移&lt;/h2&gt;
&lt;p&gt;在多核系统中，XWOS的线程只会在某个CPU上被调度，XWOS内核并不会自动对线程做均衡处理，
但支持将线程迁移到另一个CPU上，相关API：&lt;code&gt;xwos_thd_migrate()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;迁移流程&#34;&gt;迁移流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;假定条件：线程正在CPU-A上，准备迁移到CPU-B上&lt;/li&gt;
&lt;li&gt;流程：
&lt;ul&gt;
&lt;li&gt;用户在任意CPU的任意上下文调用API：&lt;code&gt;xwos_thd_migrate()&lt;/code&gt;；
&lt;ul&gt;
&lt;li&gt;系统向CPU-A发送调度器服务中断，提出“&lt;strong&gt;迁移出&lt;/strong&gt;”的申请；&lt;/li&gt;
&lt;li&gt;CPU-A切换至调度器服务中断，向线程设置冻结标志，并中断线程的阻塞态和睡眠态，
然后退出中断上下文；&lt;/li&gt;
&lt;li&gt;CPU-A中线程被重新调度，并运行到冻结点；&lt;/li&gt;
&lt;li&gt;线程在冻结点向CPU-A发送调度器服务中断，执行&lt;strong&gt;冻结&lt;/strong&gt;操作；&lt;/li&gt;
&lt;li&gt;线程冻结后，CPU-A向CPU-B申请调度器服务中断，提出“&lt;strong&gt;迁移进&lt;/strong&gt;”的申请；&lt;/li&gt;
&lt;li&gt;CPU-B切换至调度器服务中断，把线程加入到自己的调度器中，解除线程的冻结状态，
并加入就绪列表中；&lt;/li&gt;
&lt;li&gt;迁移完成，线程开始在CPU-B中调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;文档未及时更新时，以头文件&lt;code&gt;xwos/osal/skd.h&lt;/code&gt;中注释为准；&lt;/li&gt;
&lt;li&gt;API详细说明与示例：&lt;a href=&#34;TBD&#34;&gt;API手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 软件定时器</title>
      <link>/docs/user-manual/swt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/swt/</guid>
      <description>
        
        
        &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;软件定时器是基于调度器的&lt;a href=&#34;../skd#%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1&#34;&gt;滴答定时器任务&lt;/a&gt;实现的，
因此时间精度最小为滴答定时器的中断频率。&lt;/p&gt;
&lt;h3 id=&#34;软件定时器的回调函数&#34;&gt;软件定时器的回调函数&lt;/h3&gt;
&lt;p&gt;软件定时器的回调函数运行在滴答定时器任务中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当开启中断底半部时，软件定时器的回调函数运行在中断底半部中；&lt;/li&gt;
&lt;li&gt;当关闭中断底半部时，软件定时器的回调函数运行在中断上下文中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是运行在中断底半部还是中断上下文，软件定时器的回调函数都
&lt;strong&gt;不&lt;/strong&gt;可使用任何会导致睡眠、阻塞的API。&lt;/p&gt;
&lt;h2 id=&#34;软件定时器的标志&#34;&gt;软件定时器的标志&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XWOS_SWT_FLAG_RESTART&lt;/code&gt;：定时器超时后自动重新开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;软件定时器的创建初始化与删除销毁&#34;&gt;软件定时器的创建、初始化与删除、销毁&lt;/h2&gt;
&lt;p&gt;软件定时器同线程一样，支持静态初始化与销毁，动态创建与删除两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态初始化与销毁
&lt;ul&gt;
&lt;li&gt;初始化：&lt;code&gt;xwos_swt_init()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;销毁：&lt;code&gt;xwos_swt_fini()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态&lt;/strong&gt;是指用户预先定义对象，这些对象在编译时由编译器分配内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态创建与删除
&lt;ul&gt;
&lt;li&gt;创建：&lt;code&gt;xwos_swt_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除：&lt;code&gt;xwos_swt_delete()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt;是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存，
并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;文档未及时更新时，以头文件&lt;code&gt;xwos/osal/swt.h&lt;/code&gt;中注释为准；&lt;/li&gt;
&lt;li&gt;API详细说明与示例：&lt;a href=&#34;TBD&#34;&gt;API手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 电源管理</title>
      <link>/docs/user-manual/pm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/pm/</guid>
      <description>
        
        
        &lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;XWOS有两套电源管理框架，分别用于MP系统和UP系统。&lt;/p&gt;
&lt;p&gt;XWOS的电源管理框架只提供了基本流程，最终SOC如何休眠由BSP中的回调函数实现：
用户可以自行决定是否保持SDRAM的刷新、是否保持某些GPIO的输出、或则是否进入最低功耗的待机等等。&lt;/p&gt;
&lt;h2 id=&#34;mp系统的电源管理&#34;&gt;MP系统的电源管理&lt;/h2&gt;
&lt;h3 id=&#34;电源管理领域&#34;&gt;电源管理领域&lt;/h3&gt;
&lt;p&gt;MP系统中，CPU不唯一，XWOS中使用&lt;strong&gt;电源管理领域&lt;/strong&gt;(&lt;strong&gt;PMDM&lt;/strong&gt;)来统一管理所有CPU的休眠与唤醒。&lt;/p&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 789px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/user-manual/pm/mp-pm-flow_huad237c88a54a050d1276e5f5ab1230e1_100614_779x658_fill_catmullrom_smart1_3.png&#34; width=&#34;779&#34; height=&#34;658&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
MP系统电源管理流程
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;p&gt;图中，左列为休眠流程，右列为唤醒流程，箭头代表了可以进行&lt;strong&gt;电源管理阶段&lt;/strong&gt;转换的方向。
&lt;strong&gt;电源管理领域&lt;/strong&gt;将电源管理分为四个阶段（图中绿色的框）：&lt;/p&gt;
&lt;h5 id=&#34;正在运行-xwmp_pmdm_stage_running&#34;&gt;正在运行 (&lt;code&gt;XWMP_PMDM_STAGE_RUNNING&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;所有CPU正常运行，可以使用下面API进入休眠的流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwos_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此API是操作系统抽象层&lt;strong&gt;OSAL&lt;/strong&gt;中的API，实际调用的是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwmp_pmdm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;冻结调度器--解冻调度器-xwmp_pmdm_stage_freezing---xwmp_pmdm_stage_thawing&#34;&gt;冻结调度器 —— 解冻调度器 (&lt;code&gt;XWMP_PMDM_STAGE_FREEZING - XWMP_PMDM_STAGE_THAWING&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;一旦开始休眠流程，PMDM会通知所有CPU冻结线程。当调度器中线程
全部冻结后，调度器会向PMDM报告&lt;strong&gt;已经暂停&lt;/strong&gt;的状态。调度器冻结
线程的过程是一个比较复杂的过程，这个阶段又分为几个子阶段（图中蓝色的框）：&lt;/p&gt;
&lt;h6 id=&#34;冻结线程--解冻线程-xwmp_skd_wklkcnt_freezing---xwmp_skd_wklkcnt_thawing&#34;&gt;冻结线程 —— 解冻线程 (&lt;code&gt;XWMP_SKD_WKLKCNT_FREEZING - XWMP_SKD_WKLKCNT_THAWING&lt;/code&gt;)&lt;/h6&gt;
&lt;p&gt;调度器会中断所有线程的&lt;strong&gt;等待&lt;/strong&gt;和&lt;strong&gt;睡眠&lt;/strong&gt;态，并为所有线程设置&lt;strong&gt;可冻结&lt;/strong&gt;标志，
然后依次调度每个线程，直到它们运行到&lt;strong&gt;冻结点&lt;/strong&gt;进行冻结，这个过程耗时比较长，
在执行过程中如果遇到唤醒事件，调度器会在唤醒事件中断中切换为解冻流程：
解冻已经冻结的线程，并取消未冻结的线程的&lt;strong&gt;可冻结&lt;/strong&gt;标志。&lt;/p&gt;
&lt;h6 id=&#34;全部线程已经冻结-xwmp_skd_wklkcnt_allfrz&#34;&gt;全部线程已经冻结 (&lt;code&gt;XWMP_SKD_WKLKCNT_ALLFRZ&lt;/code&gt;)&lt;/h6&gt;
&lt;p&gt;最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。
如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断。
休眠流程切换为唤醒流程，并重新打开滴答定时器。
按照&lt;a href=&#34;../skd#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD&#34;&gt;调度器的中断&lt;/a&gt;中的约束，唤醒事件中断的优先级低于
调度器服务中断，因此唤醒事件中断一定会在调度器服务中断退出后才开始执行，
滴答定时器一定会先关闭，然后再打开，顺序不会错乱。&lt;/p&gt;
&lt;h6 id=&#34;调度器已经暂停-xwmp_skd_wklkcnt_suspended&#34;&gt;调度器已经暂停 (&lt;code&gt;XWMP_SKD_WKLKCNT_SUSPENDED&lt;/code&gt;)&lt;/h6&gt;
&lt;p&gt;CPU从上一步骤的调度器服务中断中退出后，会切换回线程上下文，此时因所有
线程已经冻结，CPU只可能运行在&lt;a href=&#34;../skd#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1&#34;&gt;空闲任务&lt;/a&gt;中。
CPU会在空闲任务中向PMDM报告调度器&lt;strong&gt;已经暂停&lt;/strong&gt;的状态。此过程不能在调度器服务中断
中进行，因为调度器服务中断是最高优先级中断，不能被唤醒事件中断打断，
有可能会导致无法唤醒的问题。&lt;/p&gt;
&lt;h5 id=&#34;正在暂停--正在恢复-xwmp_pmdm_stage_suspending---xwmp_pmdm_stage_resuming&#34;&gt;正在暂停 —— 正在恢复 (&lt;code&gt;XWMP_PMDM_STAGE_SUSPENDING - XWMP_PMDM_STAGE_RESUMING&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;当最后一个CPU报告了&lt;strong&gt;已经暂停&lt;/strong&gt;的状态后，会在最后一个CPU的&lt;strong&gt;空闲任务&lt;/strong&gt;中执行用户
的&lt;code&gt;suspend()&lt;/code&gt;回调函数。此时，如果出现唤醒事件，电源管理的阶段会从&lt;strong&gt;正在暂停&lt;/strong&gt;切换
为&lt;strong&gt;正在恢复&lt;/strong&gt;，并执行用户的&lt;code&gt;resume()&lt;/code&gt;回调函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;suspend()&lt;/code&gt;回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resume()&lt;/code&gt;回调函数用于在唤醒之前执行与&lt;code&gt;suspend()&lt;/code&gt;回调函数相反的操作；&lt;/li&gt;
&lt;li&gt;执行这两个函数时，PMDM会自动锁定&lt;strong&gt;resume-suspend锁&lt;/strong&gt;，并关闭当前
CPU的总中断开关。&lt;strong&gt;resume-suspend锁&lt;/strong&gt;是自旋锁，如果CPU-1正在
执行&lt;code&gt;suspend()&lt;/code&gt;回调函数，此时出现了唤醒事件，会分下面两种情况进行处理：
&lt;ul&gt;
&lt;li&gt;唤醒事件中断也绑定在CPU-1上，唤醒事件中断会挂起，直到&lt;code&gt;suspend()&lt;/code&gt;回调函数
返回，PMDM解锁&lt;strong&gt;resume-suspend锁&lt;/strong&gt;并打开CPU总中断开关，才被处理，
然后执行&lt;code&gt;resume()&lt;/code&gt;回调函数；&lt;/li&gt;
&lt;li&gt;唤醒事件中断绑定在CPU-2上，CPU-2会立即进入唤醒事件中断，但一直会
&lt;strong&gt;自旋&lt;/strong&gt;等待CPU-1释放&lt;strong&gt;resume-suspend锁&lt;/strong&gt;，直到获得&lt;strong&gt;resume-suspend锁&lt;/strong&gt;后，
才会执行&lt;code&gt;resume()&lt;/code&gt;回调函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示例WeActMiniStm32H750的&lt;code&gt;resume()&lt;/code&gt;与&lt;code&gt;suspend()&lt;/code&gt;回调函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* xwbd/WeActMiniStm32H750/bm/stm32cube/xwds/pm.c */&lt;/span&gt;
&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_resume&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        ...
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 恢复stm32cube中的所有设备 */&lt;/span&gt;
        xwds_pm_resume(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;stm32cube_ds);
}

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        ...
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 暂停stm32cube：
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 暂停所有设备
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           + 配置GPIO */&lt;/span&gt;
        xwds_pm_suspend(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;stm32cube_ds);

        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 设置休眠方式为STOP模式：
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           STOP模式下寄存器与内部RAM数据不丢失，
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;           因此休眠方式为SuspendToRAM，唤醒后运行状态可恢复。*/&lt;/span&gt;
        LL_PWR_SetRegulModeDS(LL_PWR_REGU_DSMODE_LOW_POWER);
        LL_PWR_EnableFlashPowerDown();
        LL_PWR_CPU_SetD1PowerMode(LL_PWR_CPU_MODE_D1STOP);
        LL_PWR_CPU_SetD2PowerMode(LL_PWR_CPU_MODE_D2STOP);
        LL_PWR_CPU_SetD3PowerMode(LL_PWR_CPU_MODE_D3STOP);
        LL_LPM_EnableDeepSleep();

        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 设置ARMv7-m的DEEPSLEEP位 */&lt;/span&gt;
        LL_LPM_EnableDeepSleep();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;已经暂停-xwmp_pmdm_stage_suspended&#34;&gt;已经暂停 (&lt;code&gt;XWMP_PMDM_STAGE_SUSPENDED&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。
此阶段提供给用户的回调函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt;：休眠SOC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wakeup()&lt;/code&gt;：唤醒SOC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当最后一个CPU的&lt;strong&gt;空闲任务&lt;/strong&gt;执行完上一阶段的&lt;code&gt;suspend()&lt;/code&gt;回调函数后，
PMDM将电源管理步骤切换到此阶段，并执行&lt;code&gt;sleep()&lt;/code&gt;回调函数。
SOC系统在&lt;code&gt;sleep()&lt;/code&gt;回调函数内部进入低功耗状态，
此时时钟停止，代码停止运行，&lt;code&gt;sleep()&lt;/code&gt;回调函数不会返回。&lt;/p&gt;
&lt;p&gt;XWOS将&lt;code&gt;sleep()&lt;/code&gt;回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能
导致系统无法唤醒。例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了
休眠指令（&lt;code&gt;wfi&lt;/code&gt;），低优先级的唤醒中断无法把系统唤醒。&lt;/p&gt;
&lt;p&gt;当唤醒事件出现，**wakeup()**回调函数在唤醒事件中断中执行。&lt;/p&gt;
&lt;p&gt;回调函数&lt;code&gt;sleep()&lt;/code&gt;与&lt;code&gt;wakeup()&lt;/code&gt;之间没有锁的保护，
因此&lt;code&gt;sleep()&lt;/code&gt;回调函数需要设计成能被&lt;code&gt;wakeup()&lt;/code&gt;回调函数打断。&lt;/p&gt;
&lt;p&gt;示例，WeActMiniStm32H750的&lt;code&gt;wakeup()&lt;/code&gt;与&lt;code&gt;sleep()&lt;/code&gt;回调函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* xwbd/WeActMiniStm32H750/bm/stm32cube/xwds/pm.c */&lt;/span&gt;
&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_wakeup&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        LL_LPM_EnableSleep(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 清除DEEPSLEEP位 */&lt;/span&gt;
        SystemClock_Config(); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 从STOP模式恢复后，需要重新配置时钟 */&lt;/span&gt;
}

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;stm32cube_pm_sleep&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 位置1 */&lt;/span&gt;
        cm_wfi();
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 位置2 */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分为两种情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt;中的&lt;code&gt;WFI&lt;/code&gt;指令执行后出现唤醒事件：
唤醒流程执行完毕后，代码会回到&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt;中&lt;strong&gt;位置2&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt;中的&lt;code&gt;WFI&lt;/code&gt;指令执行之前出现唤醒事件：
唤醒事件中断会打断&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt;函数，然后
执行&lt;code&gt;stm32cube_pm_wakeup()&lt;/code&gt;函数，&lt;code&gt;LL_LPM_EnableSleep()&lt;/code&gt;
会清除ARMv7-m的DEEPSLEEP位，接下来的唤醒流程也会将滴答定时器重新打开，当
再次回到&lt;code&gt;stm32cube_pm_sleep()&lt;/code&gt;的&lt;strong&gt;位置1&lt;/strong&gt;时，&lt;code&gt;WFI&lt;/code&gt;指令只会使CPU进入
ARMv7-m的SLEEP模式，只是短暂地暂停了一下CPU时钟，即将到来的滴答定时器中断
可使系统恢复正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;up内核的电源管理&#34;&gt;UP内核的电源管理&lt;/h2&gt;
&lt;h3 id=&#34;流程-1&#34;&gt;流程&lt;/h3&gt;







&lt;div class=&#34;card rounded p-2 td-post-card mb-4 mt-4&#34; style=&#34;max-width: 683px&#34;&gt;
	&lt;img class=&#34;card-img-top&#34; src=&#34;/docs/user-manual/pm/up-pm-flow_hud28fc7ba75fb6cae820cff89a3e4c72a_66458_673x499_fill_catmullrom_smart1_3.png&#34; width=&#34;673&#34; height=&#34;499&#34;&gt;
	
	&lt;div class=&#34;card-body px-0 pt-2 pb-0 text-center&#34;&gt;
		&lt;p class=&#34;card-text&#34;&gt;
UP系统电源管理流程
&lt;small class=&#34;text-muted&#34;&gt;&lt;br/&gt;Photo: xwos.tech / CC-BY&lt;/small&gt;&lt;/p&gt;
	&lt;/div&gt;
	
&lt;/div&gt;

&lt;p&gt;图中，左列为休眠流程，右列为唤醒流程，箭头代表了&lt;strong&gt;电源管理阶段&lt;/strong&gt;切换的方向。
UP系统电源管理分为五个阶段：&lt;/p&gt;
&lt;h5 id=&#34;正在运行-xwup_pm_stage_running&#34;&gt;正在运行 (&lt;code&gt;XWUP_PM_STAGE_RUNNING&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;调度器正常运行，可以使用下面API进入休眠的流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;xwer_t &lt;span style=&#34;color:#00a000&#34;&gt;xwup_skd_suspend&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;正在冻结线程--正在解冻线程-xwup_pm_stage_freezing---xwup_pm_stage_thawing&#34;&gt;正在冻结线程 —— 正在解冻线程 (&lt;code&gt;XWUP_PM_STAGE_FREEZING - XWUP_PM_STAGE_THAWING&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;一旦开始休眠流程，调度器会中断所有线程的&lt;strong&gt;等待&lt;/strong&gt;和&lt;strong&gt;睡眠&lt;/strong&gt;态，并通知所有线程冻结。
这个过程耗时比较长，在执行过程中如果遇到唤醒事件，调度器可在唤醒事件中断中
切换为解冻流程：解冻已冻结的线程，并将调度器状态逐步恢复至&lt;strong&gt;正在运行&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;调度器中全部线程已经冻结-xwup_pm_stage_allfrz&#34;&gt;调度器中全部线程已经冻结 (&lt;code&gt;XWUP_PM_STAGE_ALLFRZ&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。
如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断，
休眠流程切换为唤醒流程，并重新打开滴答定时器。
按照&lt;a href=&#34;../skd#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD&#34;&gt;调度器的中断&lt;/a&gt;中的约束，唤醒事件中断的优先级
低于调度器服务中断，因此唤醒事件中断一定会在调度器服务中断退出后才开始执行，
滴答定时器一定会先关闭，然后再打开，顺序不会错乱。&lt;/p&gt;
&lt;h5 id=&#34;正在暂停--正在恢复-xwup_pm_stage_suspending---xwup_pm_stage_resuming&#34;&gt;正在暂停 —— 正在恢复 (&lt;code&gt;XWUP_PM_STAGE_SUSPENDING - XWUP_PM_STAGE_RESUMING&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;当全部线程冻结后，调度器只能调度&lt;strong&gt;空闲任务&lt;/strong&gt;，调度器会在&lt;strong&gt;空闲任务&lt;/strong&gt;中执行用户
的&lt;code&gt;suspend()&lt;/code&gt;回调函数。此时，如果出现唤醒事件，系统会在唤醒事件中断中将状态从
&lt;strong&gt;正在暂停&lt;/strong&gt;切换为&lt;strong&gt;正在恢复&lt;/strong&gt;，并执行用户的&lt;code&gt;resume()&lt;/code&gt;回调函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;suspend()&lt;/code&gt;回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resume()&lt;/code&gt;回调函数用于在唤醒之前执行与&lt;code&gt;suspend()&lt;/code&gt;回调函数相反的操作；&lt;/li&gt;
&lt;li&gt;执行这两个函数时系统会关闭CPU总中断开关。如果正在执行&lt;code&gt;suspend()&lt;/code&gt;回调函数时
出现了唤醒事件，唤醒事件中断会挂起，直到&lt;code&gt;suspend()&lt;/code&gt;回调函数，系统
打开CPU总中断开关时才被处理，然后执行&lt;code&gt;resume()&lt;/code&gt;回调函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;已经暂停-xwup_pm_stage_suspended&#34;&gt;已经暂停 (&lt;code&gt;XWUP_PM_STAGE_SUSPENDED&lt;/code&gt;)&lt;/h5&gt;
&lt;p&gt;此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。
此阶段提供给用户的回调函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt;：休眠SOC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wakeup()&lt;/code&gt;：唤醒SOC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当&lt;strong&gt;空闲任务&lt;/strong&gt;执行完上一阶段的&lt;code&gt;suspend()&lt;/code&gt;回调函数后，
电源管理步骤切换到此阶段，并执行&lt;code&gt;sleep()&lt;/code&gt;回调函数。SOC系统在&lt;code&gt;sleep()&lt;/code&gt;回调函数
内部进入休眠状态，此时时钟停止，代码停止运行，&lt;code&gt;sleep()&lt;/code&gt;回调函数不会返回。&lt;/p&gt;
&lt;p&gt;XWOS将&lt;code&gt;sleep()&lt;/code&gt;回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能
导致系统无法唤醒。例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了
休眠指令（&lt;code&gt;WFI&lt;/code&gt;），低优先级的唤醒中断无法把系统唤醒。&lt;/p&gt;
&lt;p&gt;当唤醒事件出现，&lt;code&gt;wakeup()&lt;/code&gt;回调函数在唤醒事件中断中执行。&lt;/p&gt;
&lt;p&gt;回调函数&lt;code&gt;sleep()&lt;/code&gt;与&lt;code&gt;wakeup()&lt;/code&gt;之间没有锁的保护，
因此&lt;code&gt;sleep()&lt;/code&gt;回调函数需要设计成能被&lt;code&gt;wakeup()&lt;/code&gt;回调函数打断。&lt;/p&gt;
&lt;h2 id=&#34;api参考&#34;&gt;API参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;文档未及时更新时，以头文件&lt;code&gt;xwos/osal/pm.h&lt;/code&gt;中注释为准；&lt;/li&gt;
&lt;li&gt;API详细说明与示例：&lt;a href=&#34;TBD&#34;&gt;API手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 锁</title>
      <link>/docs/user-manual/lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/lock/</guid>
      <description>
        
        
        &lt;h2 id=&#34;临界区管理&#34;&gt;临界区管理&lt;/h2&gt;
&lt;p&gt;临界区是指访问共用资源的程序片段，传统RTOS中，通常使用以下几种方式保护临界区资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用协作式内核：线程（任务）不主动放弃CPU不会发生调度，因此共享的资源在
线程（任务）中访问都是安全的。&lt;/li&gt;
&lt;li&gt;关闭抢占：可用于保护被多个线程（任务）共享的资源。&lt;/li&gt;
&lt;li&gt;关闭中断：可用于保护线程与线程、线程与中断共享的资源。&lt;/li&gt;
&lt;li&gt;互斥锁：可用于保护被多个线程（任务）共享的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XWOS内核是假定系统为MP来设计的（UP可以视为MP的特例），
因此在进入临界区的方式与传统RTOS有些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭抢占：使用自旋锁或其派生锁的&lt;code&gt;lock&lt;/code&gt;与&lt;code&gt;unlock&lt;/code&gt;形式的API；&lt;/li&gt;
&lt;li&gt;关闭CPU总中断：使用自旋锁或其派生锁的&lt;code&gt;lock_cpuirq&lt;/code&gt;与&lt;code&gt;unlock_cpuirq&lt;/code&gt;形式的API。
若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用&lt;code&gt;lock_cpuirqsv&lt;/code&gt;与&lt;code&gt;unlock_cpuirqrs&lt;/code&gt;
形式的API来保存与恢复CPU总中断开关标志，防止内层锁解锁时意外地把CPU总中断打开；&lt;/li&gt;
&lt;li&gt;关闭部分中断：使用自旋锁或其派生锁的&lt;code&gt;lock_irqs&lt;/code&gt;与&lt;code&gt;unlock_irqs&lt;/code&gt;形式的API，
若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用&lt;code&gt;lock_irqssv&lt;/code&gt;与&lt;code&gt;unlock_irqsrs&lt;/code&gt;
形式的API来保存与恢复部分中断开关标志，防止内层锁解锁时意外地把这些中断打开；&lt;/li&gt;
&lt;li&gt;关闭中断底半部：使用自旋锁或其派生锁的&lt;code&gt;lock_bh&lt;/code&gt;与&lt;code&gt;unlock_bh&lt;/code&gt;形式的API；&lt;/li&gt;
&lt;li&gt;互斥锁：只能用于保护被多个线程共享的资源；&lt;/li&gt;
&lt;li&gt;原子操作：XWOS中提供原子操作的函数库&lt;code&gt;xwos/lib/xwaop.h&lt;/code&gt;，并抽象了std:atomic类似的内存模型。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 同步</title>
      <link>/docs/user-manual/sync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/sync/</guid>
      <description>
        
        
        &lt;p&gt;玄武OS提供多种同步机制，它们统一称为&lt;strong&gt;同步对象&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;条件量&lt;/li&gt;
&lt;li&gt;事件标志&lt;/li&gt;
&lt;li&gt;线程栅栏&lt;/li&gt;
&lt;li&gt;信号选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;与&lt;strong&gt;条件量&lt;/strong&gt;是操作系统最基本的两种同步机制，
其他复杂的同步机制都可基于这两种同步机制实现。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 内存管理</title>
      <link>/docs/user-manual/mm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/mm/</guid>
      <description>
        
        
        &lt;p&gt;XWOS提供四种内存管理的算法。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: XWOS基本C函数库</title>
      <link>/docs/user-manual/xwlib/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/xwlib/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: C/C&#43;&#43;</title>
      <link>/docs/user-manual/c-c&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/c-c&#43;&#43;/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: 通讯</title>
      <link>/docs/user-manual/isc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/user-manual/isc/</guid>
      <description>
        
        
        &lt;p&gt;XWOS内核只提供基本的同步机制（信号量、条件量、事件标志、线程栅栏、信号选择器），
线程间通讯的机制是基于最基本的同步机制实现的，因此属于中间件XWMD。
XWMD除了提供消息队列、循环队列等线程间通讯机制外，还提供电路板上SOC芯片间的通讯机制，
因此被称为系统间通讯机制(ISC, Inter-System Communication)。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
