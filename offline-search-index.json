


























































































[{"body":"概述 XWOS的源码中，已包含了大部分ARM-Cortex-M架构的代码：\n 架构描述层(ADL)  ARMv7m:xwcd/soc/arm/v7m/gcc ARMv6m:xwcd/soc/arm/v6m/gcc   CPU描述层(CDL)  m0:xwcd/soc/arm/v6m/gcc/m0 m0p:xwcd/soc/arm/v6m/gcc/m0p m3:xwcd/soc/arm/v7m/gcc/m3 m4:xwcd/soc/arm/v7m/gcc/m4 m7:xwcd/soc/arm/v7m/gcc/m7   SOC描述层(SDL)  STM32:  L0/F0:xwcd/soc/arm/v7m/gcc/m0/stm32 L1/F1:xwcd/soc/arm/v7m/gcc/m3/stm32 L4/F4:xwcd/soc/arm/v7m/gcc/m4/stm32 F7/H7:xwcd/soc/arm/v7m/gcc/m7/stm32   S32K:xwcd/soc/arm/v7m/gcc/m4/s32k14x i.MX RT1052:xwcd/soc/arm/v7m/gcc/m7/mimxrt1052    新的SOC芯片，只需在CDL文件夹中增加SOC文件夹，其中包括：\n soc_lowlevel_init()：低级初始化，此时内存还未初始化，不可访问全局变量；  SOC的其他低级初始化   soc_init()  初始化中断控制器与调度器  多核系统：  xwmp_irqc_construct()：初始化每个CPU的中断控制器； xwmp_irqc_register()：将每个CPU的中断控制器注册到中断控制子系统； xwmp_skd_init_lc()：分别在每个CPU上都运行一次这个函数初始化自己的调度器；   单核系统：  xwup_irqc_init()：初始化中断控制器； xwup_skd_init_lc()：初始化调度器；     SOC的其他初始化   XWOS内核移植层(XWOSPL)的实现：xwosimpl_xxx.[ch] *.lds：链接脚本  可以复制一个SDL文件夹（例如STM32）作为模板， 所有Cortex-M的单片机XWOSIMPL都是一样的。\n栈  XWOS在ARMv6/7-m平台的实现上，使用8字节对齐的栈， 因此必须在芯片初始化的最早阶段将CCR寄存器中的STKALIGN设置为1：  cm_scs.scb.ccr.bit.stkalign = 1;  使用满递减栈，即配置文件cfg/xwos.h中XWMMCFG_FD_STACK配置为1： 当CPU中包含浮点单元时，开启浮点上下文自动保存与恢复，即  cm_scs.scb.fpu.fpccr.bit.aspen = 1; 栈结构 C语言一般将寄存器分为两部分：易失性的(volatile)和非易失性的(non-volatile)。 当使用到易失性(volatile)寄存器时不需要保存值和恢复； 当使用到非易失性(non-volatile)寄存器时需要保存值和恢复。\n易失性(volatile)栈结构 ARMv6/v7-m的CPU，从线程模式进入中断模式时，会自动将易失性(volatile)寄存器保存到栈中。\n------------------------ | Prev Frame | +------------+---------+ sp+0x3C | | | sp+0x38 | FPSCR | | sp+0x3C | s15 | | sp+0x38 | s14 | | sp+0x34 | s13 | | sp+0x30 | s12 | | sp+0x2C | s11 | | sp+0x28 | s10 | | sp+0x24 | s9 | FP | sp+0x20 | s8 | Frame | sp+0x3C | s7 | | sp+0x38 | s6 | | sp+0x34 | s5 | | sp+0x30 | s4 | | sp+0x2C | s3 | | sp+0x28 | s2 | | sp+0x24 | s1 | | sp+0x20 | s0 | | ------------------------ sp+0x1C | xpsr | | sp+0x18 | pc | | sp+0x14 | lr | | sp+0x10 | r12 (ip) | Basic | sp+0x0C | r3 | Frame | sp+0x08 | r2 | | sp+0x04 | r1 | | sp+0x00 | r0 | | ------------------------ 易失性(volatile)寄存器栈结构 非易失性(non-volatile)栈结构 编译器能自动处理非易失性(non-volatile)寄存器，因此在同一个上下文中恢复环境，不需要 保存非易失性(non-volatile)寄存器。但当操作系统切换任务时，不同的任务的 非易失性(non-volatile)寄存器环境是不一样的，需要进行保存与恢复。\nXWOS在ARMv6/7-m平台上的非易失性(non-volatile)寄存器栈结构如下：\n----------------------------- | Volatile stack Frame | +-----------------+---------+ sp+0x64 | s31 | | sp+0x60 | s30 | | sp+0x5C | s29 | | sp+0x58 | s28 | | sp+0x54 | s27 | | sp+0x50 | s26 | | sp+0x4C | s25 | FP | sp+0x48 | s24 | Frame | sp+0x44 | s23 | | sp+0x40 | s22 | | sp+0x3C | s21 | | sp+0x38 | s20 | | sp+0x34 | s19 | | sp+0x30 | s18 | | sp+0x2C | s17 | | sp+0x28 | s16 | | ----------------------------- sp+0x24 | lr (EXC_RETURN) | | sp+0x20 | r11 (fp) | | sp+0x1C | r10 (sl) | | sp+0x18 | r9 | | sp+0x14 | r8 | Basic | sp+0x10 | r7 | Frame | sp+0x0C | r6 | | sp+0x08 | r5 | | sp+0x04 | r4 | | sp+0x00 | CONTROL | | ----------------------------- 非易失性(non-volatile)寄存器栈结构 setjmp()/longjmp()的栈结构 C标准库中定义的setjmp()/longjmp()是可在不同函数之间跳转的goto， 有些libc的实现没有考虑浮点寄存器栈，因此XWOS重新实现了这两个函数。\n 源码路径：  xwcd/soc/arm/v7m/gcc/xwosimpl_soc_setjmp.h xwcd/soc/arm/v7m/gcc/xwosimpl_soc_setjmp.c  完整的栈结构如下：  ----------------------------- sp+0x64 | s31 | | sp+0x60 | s30 | | sp+0x5C | s29 | | sp+0x58 | s28 | | sp+0x54 | s27 | | sp+0x50 | s26 | | sp+0x4C | s25 | FP | sp+0x48 | s24 | Frame | sp+0x44 | s23 | | sp+0x40 | s22 | | sp+0x3C | s21 | | sp+0x38 | s20 | | sp+0x34 | s19 | | sp+0x30 | s18 | | sp+0x2C | s17 | | sp+0x28 | s16 | | ----------------------------- sp+0x24 | r14 (lr) | | sp+0x20 | r13 (sp) | | sp+0x1C | r11 (fp) | | sp+0x18 | r10 (sl) | | sp+0x14 | r9 | Basic | sp+0x10 | r8 | Frame | sp+0x0C | r7 | | sp+0x08 | r6 | | sp+0x04 | r5 | | sp+0x00 | r4 | | ----------------------------- setjmp/longjmp寄存器栈结构 ","categories":"","description":"","excerpt":"概述 XWOS的源码中，已包含了大部分ARM-Cortex-M架构的代码：\n 架构描述层(ADL) …","ref":"/docs/note/soc/arm-m/","tags":"","title":"ARM-Cortex-M移植说明"},{"body":"概述 GD32V相关的代码：\n 架构描述层(ADL)：xwcd/soc/riscv/nuclei/gcc CPU描述层(CDL)：xwcd/soc/riscv/nuclei/gcc/bumblebee SOC描述层(SDL)  GD32V：xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v    启动流程  程序入口：xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_boot  中断  采用非向量模式，统一的入口：xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_isr_entry 使用RISC-V标准寄存器mscratch来实现ARM-Cortex-M类似的双栈结构的工作方式 异常统一的入口xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S: soc_esr_entry 源码：  xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_soc_irq.h xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_irq.h xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_irq.c xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/soc.S    调度  源码：  xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_skd.h xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_skd.c xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosasmimpl_skd.S    栈结构  RISC-V要求栈必须按16字节对齐； RISC-V只使用满递减栈； RISC-V的ABI文档中将寄存器分为两类：caller-saved和callee-saved。  caller-saved栈结构 从线程进入中断时，中断入口程序会自动将caller-saved寄存器保存到栈中：\n* __caller-saved (volatile) context__ * 19 * 4 t6 (x31) ---------- * 18 * 4 t5 (x30) | * 17 * 4 t4 (x29) | * 16 * 4 t3 (x28) | * 15 * 4 a7 (x17) | * 14 * 4 a6 (x16) | * 13 * 4 msubm --------+ | * 12 * 4 mepc | | * 11 * 4 mcause | | * 10 * 4 mscratch | | * 9 * 4 a5 (x15) | RV32I * 8 * 4 a4 (x14) | | * 7 * 4 a3 (x13) | | * 6 * 4 a2 (x12) RV32E | * 5 * 4 a1 (x11) | | * 4 * 4 a0 (x10) | | * 3 * 4 t2 (x7) | | * 2 * 4 t1 (x6) | | * 1 * 4 t0 (x5) | | * 0 * 4 ra (x1) | | * __caller-saved (volatile) context__ callee-saved栈结构 切换上下文时，需要保存与恢复callee-saved寄存器栈结构如下：\n* __callee-saved (non-volatile) context__ * 12 * 4 s11 (x27) | * 11 * 4 s10 (x26) | * 10 * 4 s9 (x25) | * 9 * 4 s8 (x24) | * 8 * 4 s7 (x23) | * 7 * 4 s6 (x22) | * 6 * 4 s5 (x21) RV32I * 5 * 4 s4 (x20) | * 4 * 4 s3 (x19) | * 3 * 4 s2 (x18) | * 2 * 4 mstatus ------+ | * 1 * 4 s1 (x9) | | * 0 * 4 s0 (x8) RV32E | * __callee-saved (non-volatile) context__ 滴答定时器  使用RISC-V标准中定义的定时器来产生滴答中断。 源码：  xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_syshwt.h xwcd/soc/riscv/nuclei/gcc/bumblebee/gd32v/xwosimpl_syshwt.c    ","categories":"","description":"","excerpt":"概述 GD32V相关的代码：\n 架构描述层(ADL)：xwcd/soc/riscv/nuclei/gcc CPU描述 …","ref":"/docs/note/soc/risc-v/gd32v/","tags":"","title":"GD32V移植说明"},{"body":"格式 # [标题] \u003ctype\u003e(\u003cscope\u003e): :emoji: \u003csubject\u003e # - type: feat, fix, perf, refactor, style, revert, docs, test, # chore, milestone, release, revision # - scope: 可为空 # - subject: 以动词开始的短语，结尾无句号 # - 页眉只占一行 # - 每行总长度不超过72个字符（中文字符算2个字符） # # [正文] 描述 # - 为什么需要修改？ # - 如何定位问题？ # - 修改有什么副作用？ # - 每行总长度不超过72个字符（中文字符算2个字符） # # [脚注] \u003ctoken:\u003e \u003ctext\u003e # - 问题的ID或链接 # - BREAKING CHANGE（破坏API原型的修改） # - 每行总长度不超过72个字符（中文字符算2个字符） 参考：https://www.conventionalcommits.org/\n规范  标题信息必须以一个可选的类别作为前缀，类别后面可以跟一个可选的 范围描述词，范围描述词需要放在英文的小括号内，之后可再跟一个可选的 英文的**!**表示有BREAKING CHANGE发生 (需要在最后面增加BREAKING CHANGE脚注)； 类别type说明  feat: 新功能  emoji:  新增 :sparkles: 移除 :fire: 升级依赖 :arrow_up: 新增待改进的代码 :poop: 新增.o或.a文件 :package:     fix: 修复BUG  emoji:  修复重大BUG :ambulance: 修复BUG :bug: 修复警告 :rotating_light:     perf: 性能优化  emoji:  性能优化 :zap: 移除死代码 :coffin:     refactor: 重构代码  emoji:  重大重构 :hammer: 新增 :sparkles: 重构 :recycle: 移除 :fire: 破坏性修改 :boom: 增加log :loud_sound: 移除log :mute: 调整路径 :truck: 依赖的第三方软件更新导致的API更新 :alien:     style: 格式调整（删除行尾空格等）  emoji:  :art:     revert: 回退提交  emoji:  回退代码 :rewind: 降级依赖 :arrow_down:     docs: 文档  emoji:  修改.md文档 :book: 修改源码中的注释 :bulb:     test: 测试  emoji:  :white_check_mark:     chore: 其他未归类的零碎事务  emoji:  配置相关 :wrench: 分支合并 :twisted_rightwards_arrows:     milestone: 更新大版本号  emoji:  :bookmark:     release: 更新小版本号  emoji:  :bookmark:     revision: 更新修订号  emoji:  :bookmark:       标题中的描述与类别之间需要增加一个英文的冒号“:”与一个空格“ ”，然后增加 emoji符号，间隔一个空格“ ”，再增加描述，最后不能有标点符号； 标题只能占一行； 正文与标题间需要空一行； 脚注与正文间需要空一行； 每一项脚注需要有一个单词作为标识，标识中的空格用“-”代替， 后面跟一个“:”和一个空格“ ”作为间隔，也可以跟一个空格“ ”和“#”作为间隔， 之后再跟脚注内容； 脚注可以有多行内容，直到遇到新的脚注标识为止。  字符集 全部使用utf-8字符集。\n 增加环境变量  export LESSHARESET=utf-8 设置字符集  git config i18n.commitencoding utf-8 # 设置提交日志使用utf-8 git config i18n.logoutputencoding utf-8 # 设置输出日志时使用utf-8 git config core.quotepath false # 中文路径使用utf-8 git config gui.encoding utf-8 # 图形界面使用utf-8 NTFS文件系统的文件权限问题 NTFS文件系统下，会导致文件的mode变为100644，且chmod无法修改， 可修改git配置忽略文件模式的变更。\ngit config core.filemode false 行尾空格 通常情况下，使用'\\n'（LF）作为换行符，自动生成的代码可不遵守这个规则。\n","categories":"","description":"XWOS的git-commit-msg规范\n","excerpt":"XWOS的git-commit-msg规范\n","ref":"/docs/criterion/git-msg/","tags":"","title":"git-msg规范"},{"body":"XWOS内核对libc的依赖 XWOS使用newlib作为默认的libc，具体依赖的情况如下：\n string.h的memset()、memcpy()函数， xwmd/libc/newlibac/string.c中已提供覆盖newlib的实现； stdlib.h  当配置了XWMPCFG_SKD_THD_STDC_MM、XWMPCFG_SKD_SWT_STDC_MM、 XWMPCFG_SYNC_SEM_STDC_MM、XWMPCFG_SYNC_COND_STDC_MM、 XWMPCFG_SYNC_EVT_STDC_MM或XWMPCFG_LOCK_MTX_STDC_MM时， 需要使用stdlib.h的malloc()和free()函数动态创建和删除对象： 低成本的应用中，可能会使用小内存的MCU，不能使用动态内存管理，配置中 也不能将XWMPCFG_SKD_THD_STDC_MM、XWMPCFG_SKD_SWT_STDC_MM、 XWMPCFG_SYNC_SEM_STDC_MM、XWMPCFG_SYNC_COND_STDC_MM、 XWMPCFG_SYNC_EVT_STDC_MM和XWMPCFG_LOCK_MTX_STDC_MM配置为1， 此时，XWOS内核不再需要stdlib.h；   inttypes.h、stdint.h、stddef.h  XWOS的基本类型基于标准C的基本类型进行定义： uint8_t、int8_t、uint16_t、int16_t、 uint32_t、int32_t、uint64_t、int64_t、 size_t、ssize_t、等   stdbool.h：bool类型； stdatomic.h：C11标准中原子操作内存屏障的定义，XWOS有自己的原子操作库，不依赖 C11标准中的原子操作函数，但用户也可以在自己的代码中使用； stdarg.h：变参函数； stdio.h：vsnprintf()，用于xwos/lib/xwlog.c中格式化日志，若配置 XWLIBCFG_LOG为0，则不需要这个函数；  文件操作  头文件stdio.h  fopen() fclose() fread() fwrite() fseek() remove() rename()    这些函数由xwmd/libc/newlibac/fops.c提供底层支持，xwmd/libc/newlibac/fops.c 又依赖第三方软件xwem/fs/fatfs。\nFatFs需要BSP中提供对块设备操作的支持，因此不同的电路板对文件操作的支持情况不一致， 可以参考快速开发指南获得说明：\n WeActMiniStm32H750 FK429M1 EmbedFireStm32H743 ATKStm32H743 ATKStm32F103Core ATKStm32F407Core MPC5607BCore S9KEAZ128Core Stm32F072HiXWOS Stm32F103HiXWOS GD32F303CCTmpl GD32VF103Tmpl S32K144Evb LQRT1052Tmpl  动态内存管理  stdlib.h  malloc() free() realloc() calloc() memalign() aligned_alloc() valloc() pvalloc()    这些函数由xwmd/libc/newlibac/mem.c提供底层支持：\n xwmd/libc/newlibac/mem.c覆盖了newlib中原有的实现。 xwmd/libc/newlibac/mem.c中的实现是对mempool的封装， mempool需要在board_init()中选择内存设备进行初始化后才可使用； 用户也可使用newlib提供的内存管理算法，只需将配置XWMDCFG_libc_newlibac_mem改为0即可； 用户也可自己提供动态内存算法，只需改写xwmd/libc/newlibac/mem.c中的 函数_malloc_r()、_realloc_r()、_calloc_r()、_memalign_r()、 _valloc_r()、_pvalloc_r()、_free_r()即可。 由于各电路板硬件配置不一样，动态内存管理的函数支持情况也不一样，可以参考快速开发指南获得说明： WeActMiniStm32H750 FK429M1 EmbedFireStm32H743 ATKStm32H743 ATKStm32F103Core ATKStm32F407Core MPC5607BCore S9KEAZ128Core Stm32F072HiXWOS Stm32F103HiXWOS GD32F303CCTmpl GD32VF103Tmpl S32K144Evb LQRT1052Tmpl  setjmp/longjmp setjmp()和longjmp()函数对可实现在不同函数间的goto。 用户应该使用头文件xwos/lib/setjmp.h中代替标准C的头文件setjmp.h， 并且也应该使用xwlib_setjmp()与xwlib_longjmp()函数对代替setjmp()/longjmp()函数 setjmp()和longjmp()函数对。\nerrno XWOS重构了errno的实现，将errno改为每个线程的私有变量， 线程访问errno时，只会访问自己的errno。 用户应该使用xwos/lib/errno.h替代libc中的errno.h。 errno的实现位于xwmd/libc/newlibac/errno.c。\n其他libc的功能 其他libc由newlib提供，用户可参考newlib的源码或资料获取帮助，不完全清单如下：\n libm: 数学库 ctype: 字符类型 wchar: 多字节字符 iconv: 字符集转换 locale: 区域 search: 查找 argz: 字符串数组 time: 时间，暂时不支持，需要底层提供RTC的驱动  ","categories":"","description":"libc(newlib)\n","excerpt":"libc(newlib)\n","ref":"/docs/user-manual/c-c++/libc/","tags":"","title":"libc"},{"body":"SOC对象 XWLUA不提供动态创建硬件的方法，硬件的创建与初始化都是在C语言中完成。因此， XWLUA虚拟机只提供C语言的API，用于将硬件的对象注册到虚拟机中。\nC API参考 xwlua_soc_register void xwlua_soc_register(lua_State * L, const char * name, struct xwds_soc * soc)  简介：注册SOC对象 参数L：(输入) 虚拟机 参数name：(输入) SOC在虚拟机中的变量名 参数soc：(输入) SOC对象 示例：  void xwlua_open_brdlibs(lua_State * L) { xwlua_soc_register(L, \"stm32\", \u0026stm32cube_soc_cb); } xwlua_soc_unregister void xwlua_soc_unregister(lua_State * L, const char * name)  简介：删除SOC对象 参数L：(输入) 虚拟机 参数name：(输入) SOC在虚拟机中的变量名  ","categories":"","description":"XWLUA的SOC库\n","excerpt":"XWLUA的SOC库\n","ref":"/docs/lua-manual/xwds/soc/","tags":"","title":"SOC"},{"body":"概述 XWOS的移植，包括以下几个环节：\n 编译环境 初始化流程 XWOS移植层（XWOSPL） XWOS移植实现层（XWOSIMPL）  XWOS采用适配器模式的方法来构建移植相关的代码：XWOS移植层（XWOSPL）定义接口， XWOS移植实现层（XWOSIMPL）提供实现。\n为了提高代码的复用性，XWOS移植实现层（XWOSIMPL）相关的代码又细分为：\n 架构描述层(ADL) CPU描述层(CDL) SOC描述层(SDL) 电路板描述层(BDL)  例如，ARMv7m架构下，ADL目录为xwcd/soc/arm/v7m/gcc/，其中代码对 STM32、S32K、i.MX RT1052、GD32等都是复用的，m3、m4、m7的差异又由CDL目录来描述， 相同的CPU内核不同SOC又由SDL来描述，不同的电路板由BDL来描述，最后由他们共同完成 对编译环境、初始化流程以及XWOS移植实现层（XWOSIMPL）的“实现”。\nXWOS移植层（XWOSPL）头文件规则  xwos/ospl/*.h：XWOS提供给BSP的头文件，不可被XWOS自身的头文件包含。  前缀xwospl：BSP中需要提供实现的函数 前缀xwosplcb：BSP中可以调用的函数   xwos/ospl/soc/*.h：BSP提供给XWOS的头文件，可被XWOS的头文件包含。  前缀soc：BSP中额外提供结构体、函数等    移植 XWOS的移植，包括：基本类型、编译器、断点、setjmp、系统调用与系统特权、 位操作、原子操作、无锁队列、自旋锁、中断、硬件定时器、调度器。\n基本类型 XWOS定义了自己的一套基本类型，所有源码都是围绕基本类型展开的。\n XWOS头文件：xwos/lib/type.h， 详见基本类型。 Adapter：xwos/ospl/soc/type.h Adaptee：xwosimpl_soc_type.h文件对某些类型按照架构的ELFABI规则重新进行了 定义，并且需要将ARCH_HAVE_xxxx宏定义为1，表明覆盖xxxx的默认定义， 此文件一般位于ADL目录，例如xwcd/soc/arm/v7m/gcc/xwosimpl_soc_type.h。 基本类型：  ARCH_HAVE_XWU8_T：宏，定义为1表示arch_type.h中提供类型xwu8_t xwu8_t：类型，8位无符号整数 ARCH_HAVE_XWU8_A：宏，定义为1表示arch_type.h中提供类型xwu8_a xwu8_a：类型，原子的8位无符号整数 ARCH_HAVE_XWS8_T：宏，定义为1表示arch_type.h中提供类型xws8_t xws8_t：类型，8位有符号整数 ARCH_HAVE_XWS8_A：宏，定义为1表示arch_type.h中提供类型xws8_a xws8_a：类型，原子的8位有符号整数 ARCH_HAVE_XWU16_T：宏，定义为1表示arch_type.h中提供类型xwu16_t xwu16_t：类型，16位无符号整数 ARCH_HAVE_XWU16_A：宏，定义为1表示arch_type.h中提供类型xwu16_a xwu16_a：类型，原子的16位无符号整数 ARCH_HAVE_XWS16_T：宏，定义为1表示arch_type.h中提供类型xws16_t xws16_t：类型，16位有符号整数 ARCH_HAVE_XWS16_A：宏，定义为1表示arch_type.h中提供类型xws16_a xws16_a：类型，原子的16位有符号整数 ARCH_HAVE_XWU32_T：宏，定义为1表示arch_type.h中提供类型xwu32_t xwu32_t：类型，32位无符号整数 ARCH_HAVE_XWU32_A：宏，定义为1表示arch_type.h中提供类型xwu32_a xwu32_a：类型，原子的32位无符号整数 ARCH_HAVE_XWS32_T：宏，定义为1表示arch_type.h中提供类型xws32_t xws32_t：类型，32位有符号整数 ARCH_HAVE_XWS32_A：宏，定义为1表示arch_type.h中提供类型xws32_a xws32_a：类型，原子的32位有符号整数 ARCH_HAVE_XWU64_T：宏，定义为1表示arch_type.h中提供类型xwu64_t xwu64_t：类型，64位无符号整数 ARCH_HAVE_XWU64_A：宏，定义为1表示arch_type.h中提供类型xwu64_a xwu64_a：类型，原子的64位无符号整数 ARCH_HAVE_XWS64_T：宏，定义为1表示arch_type.h中提供类型xws64_t xws64_t：类型，64位有符号整数 ARCH_HAVE_XWS64_A：宏，定义为1表示arch_type.h中提供类型xws64_a xws64_a：类型，原子的64位有符号整数 ARCH_HAVE_XWSZ_T：宏，定义为1表示arch_type.h中提供类型xwsz_t xwsz_t：类型，无符号大小值类型 ARCH_HAVE_XWSZ_A：宏，定义为1表示arch_type.h中提供类型xwsz_a xwsz_a：类型，原子的无符号大小值类型 ARCH_HAVE_XWSSZ_T：宏，定义为1表示arch_type.h中提供类型xwssz_t xwssz_t：类型，有符号大小值类型 ARCH_HAVE_XWSSZ_A：宏，定义为1表示arch_type.h中提供类型xwssz_a xwssz_a：类型，原子的有符号大小值类型 ARCH_HAVE_XWSTK_T：宏，定义为1表示arch_type.h中提供类型xwstk_t xwstk_t：类型，无符号栈类型 ARCH_HAVE_XWSTK_A：宏，定义为1表示arch_type.h中提供类型xwstk_a xwstk_a：类型，原子的无符号栈类型 ARCH_HAVE_XWPTR_T：宏，定义为1表示arch_type.h中提供类型xwptr_t xwptr_t：类型，无符号指针值类型 ARCH_HAVE_XWPTR_A：宏，定义为1表示arch_type.h中提供类型xwptr_a xwptr_a：类型，原子的无符号指针值类型 ARCH_HAVE_XWREG_T：宏，定义为1表示arch_type.h中提供类型xwreg_t xwreg_t：类型，无符号寄存器类型 ARCH_HAVE_XWREG_A：宏，定义为1表示arch_type.h中提供类型xwreg_a xwreg_a：类型，原子的无符号寄存器类型 ARCH_HAVE_XWSREG_T：宏，定义为1表示arch_type.h中提供类型xwsreg_t xwsreg_t：类型，有符号寄存器类型 ARCH_HAVE_XWSREG_A：宏，定义为1表示arch_type.h中提供类型xwsreg_a xwsreg_a：类型，原子的有符号寄存器类型 ARCH_HAVE_XWSQ_T：宏，定义为1表示arch_type.h中提供类型xwsq_t xwsq_t：类型，无符号顺序值类型 ARCH_HAVE_XWSQ_A：宏，定义为1表示arch_type.h中提供类型xwsq_a xwsq_a：类型，原子的无符号顺序值类型 ARCH_HAVE_XWSSQ_T：宏，定义为1表示arch_type.h中提供类型xwssq_t xwssq_t：类型，有符号顺序值类型 ARCH_HAVE_XWSSQ_A：宏，定义为1表示arch_type.h中提供类型xwssq_a xwssq_a：类型，原子的有符号顺序值类型 ARCH_HAVE_XWID_T：宏，定义为1表示arch_type.h中提供类型xwid_t xwid_t：类型，无符号ID值类型 ARCH_HAVE_XWID_A：宏，定义为1表示arch_type.h中提供类型xwid_a xwid_a：类型，原子的无符号ID值类型 ARCH_HAVE_XWSID_T：宏，定义为1表示arch_type.h中提供类型xwsid_t xwsid_t：类型，有符号ID值类型 ARCH_HAVE_XWSID_A：宏，定义为1表示arch_type.h中提供类型xwsid_a xwsid_a：类型，原子的有符号ID值类型 ARCH_HAVE_XWER_T：宏，定义为1表示arch_type.h中提供类型xwer_t xwer_t：类型，有符号错误码类型 ARCH_HAVE_XWER_A：宏，定义为1表示arch_type.h中提供类型xwer_a xwer_a：类型，原子的有符号错误码类型 ARCH_HAVE_XWPR_T：宏，定义为1表示arch_type.h中提供类型xwpr_t xwpr_t：类型，有符号优先级类型 ARCH_HAVE_XWPR_A：宏，定义为1表示arch_type.h中提供类型xwpr_a xwpr_a：类型，原子的有符号优先级类型 ARCH_HAVE_XWBMP_T：宏，定义为1表示arch_type.h中提供类型xwbmp_t xwbmp_t：类型，无符号位图类型 ARCH_HAVE_XWBMP_A：宏，定义为1表示arch_type.h中提供类型xwbmp_a xwbmpy_a：类型，原子的无符号位图类型 ARCH_HAVE_XWTM_T：宏，定义为1表示arch_type.h中提供类型xwtm_t xwtm_t：类型，有符号优先级类型 ARCH_HAVE_XWTM_A：宏，定义为1表示arch_type.h中提供类型xwtm_a xwtm_a：类型，原子的有符号优先级类型 ARCH_HAVE_XWLFQ_T：宏，定义为1表示arch_type.h中提供类型xwlfq_t xwlfq_t：类型，无锁队列类型 ARCH_HAVE_XWLFQ_A：宏，定义为1表示arch_type.h中提供类型xwlfq_a xwlfq_a：类型，原子的无锁队列类型 ARCH_HAVE_XWISR_F：宏，定义为1表示arch_type.h中提供类型xwisr_f xwer_a：类型，原子的有符号错误码类型 ARCH_HAVE_XWIRQ_T：宏，定义为1表示arch_type.h中提供类型xwirq_t xwirq_t：类型，有符号中断号类型    编译器  XWOS头文件：xwos/lib/compiler.h，被xwos/standard.h包含。 Adapter：xwos/ospl/soc/compiler.h Adaptee：xwosimpl_soc_compiler.h 内存屏障：XWOS支持多核系统，多核系统中存在内存数据一致性的问题， CPU架构通常会提供内存屏障指令来解决这个问题。移植XWOS时，需要对这些指令进行封装。  xwccmb()：编译器的内存屏障，防止编译器优化重排代码 xwmb_mp_mb()：多核系统的内存屏障 xwmb_mp_rmb()：多核系统的读内存屏障 xwmb_mp_wmb()：多核系统的写内存屏障 xwmb_mp_ddb()：多核系统的数据依赖屏障 xwmb_mp_load_acquire()：多核系统的load-acquire语义的内存屏障 xwmb_mp_store_release()：多核系统的store-release语义的内存屏障     题外话：数据依赖屏障\n用在存在address dependency的两个读操作之间，和Write barrier/memory barrier 配合使用，确保内存的写操作能够按照程序顺序(Program Order)对这两个读操作可见。例如,\n初始条件：A=0; B=1; P=\u0026B; CPU1: A=8; xwmb_mp_wmb(); P=\u0026A; CPU2: Q=P; C=*Q;\n在CPU2上第二个读*Q，依赖于第一个读P，这被称为address dependency，大部分CPU，例如 X86、ARM都能检测到address dependency，并保证CPU2上Program Order不会发生改变，当 读到C==8时，Q的值一定为\u0026A。但在DEC Alpha上，(Q==\u0026A \u0026\u0026 C==1)是有可能出现的，此时需要 使用数据依赖屏障才能得到正确的结果：\nCPU2: Q=P; xwmb_mp_ddb(); C=*Q;\n数据依赖屏障比较少见，在标准库(std:atomic/stdatomic.h)中，有一种内存序 release-consume，其中release就是CPU1写内存时的写屏障，consume就是CPU2上的数据依赖屏障。\n除了指针访问数据会产生address dependency，数组下标也会产生address dependency。\n  编译器相关的宏定义：  __xwcc_section(s)：表明符号属于段s。 __xwcc_aligned(x)：表明数据的起始地址对齐到x字节处。 __xwcc_inline：表明函数是内联函数，需要和static一起使用。 __xwcc_packed：表明数据结构体是紧凑分布的，编译器不要做优化对齐处理。 __xwcc_must_check：表明函数返回值必须被读取，否则编译器会报错，若编译器不支持可定义为空宏。 __xwcc_unused：表明变量或函数未被使用，用于去除编译警告，若编译器不支持可定义为空。 __xwcc_noreturn：表明函数不会返回，若编译器不支持可定义为空。 __xwcc_hot：表明函数在代码中经常被调用，若编译器不支持可定义为空。 __xwcc_atomic：表明变量是原子的，C11标准中被定义为_Atomic，C99标准中被定义为volatile __xwcc_likely(x)：表明条件x大概率为true，用于编译if..else..的优化，若编译器不支持， 应该定义为(x)。 __xwcc_unlikely(x)：表明条件x大概率为false，用于编译if..else..的优化，若编译器不支持， 应该定义为(x)。 __xwcc_alignl1cache：表明数据的起始地址对齐到1级缓存(way-set缓存)的缓存线 __xwcc_alignptr：表明数据的起始地址对齐到指针的尺寸 xwcc_offsetof(type, member)：计算member在结构体type中的偏移，等价于标准C库中的offsetof()    断点 许多CPU架构都提供断点指令，以方便调试，XWOS内核对其进行了统一封装。\n XWOS头文件：被包含在xwos/standard.h内。 Adapter：xwos/ospl/soc/bkpt.h Adaptee：xwosimpl_soc_bkpt.h  setjmp/longjmp XWOS的C库中提供了类似于C标准库中的````setjmp()/longjmp()```函数组合， 其实现与切换上下文时如何保存寄存器有密切关系。\n XWOS头文件：xwos/lib/setjmp.h Adapter：xwos/ospl/soc/setjmp.h Adaptee：xwosimpl_soc_setjmp.h  系统调用与系统特权 XWOS的C库中提供了可切换CPU访问权限的函数。通常CPU都有两种权限模式：用户和系统， 用户模式下某些CPU内的寄存器无法被访问（例如开关中断）， 只能通过特殊指令让CPU进入系统模式才可访问。\n XWOS头文件：xwos/lib/sc.h Adapter：xwos/ospl/soc/xwsc.h Adaptee：xwosimpl_soc_xwsc.h  位操作 XWOS的C库中提供了位操作的函数集合，为提高效率，部分位操作可使用特殊指令实现。\n XWOS头文件：xwos/lib/xwbop.h Adapter：xwos/ospl/soc/xwbop.h Adaptee：xwosimpl_soc_xwbop.h 基本类型的位操作函数集合：  位序镜面翻转：Intel位序（主流的小端CPU都是Inter位序）是越往高位位序号越大， 摩托罗拉位序（PowerPC架构的CPU）是越往高位位序号越小， 因此在两个系统混用时需要将数据的位序进行镜面翻转  xwbop_rbit8()：镜面翻转8位数据的位序 xwbop_rbit16()：镜面翻转16位数据的位序 xwbop_rbit32()：镜面翻转32位数据的位序 xwbop_rbit64()：镜面翻转64位数据的位序   大小端反转  xwbop_re16()：反转16位数据的字节序 xwbop_re16s32()：反转16位数据的字节序，并将符号位扩展到32位，返回有符号32位数据 xwbop_re32()：反转32位数据的字节序 xwbop_re32s64()：反转32位数据的字节序，并将符号位扩展到64位，返回有符号64位数据 xwbop_re64()：：反转64位数据的字节序   查找被置1的位  xwbop_ffs8()：8位数据，从最低有效位开始查找 xwbop_fls8()：8位数据，从最高有效位开始查找 xwbop_ffs16()：16位数据，从最低有效位开始查找 xwbop_fls16()：16位数据，从最高有效位开始查找 xwbop_ffs32()：32位数据，从最低有效位开始查找 xwbop_fls32()：32位数据，从最高有效位开始查找 xwbop_ffs64()：64位数据，从最低有效位开始查找 xwbop_fls64()：64位数据，从最高有效位开始查找      原子操作 XWOS的C库中提供了原子操作的函数集合，原子操作的实现依赖于CPU的原子操作指令。\n XWOS头文件：  xwos/lib/xwaop.h：基本类型原子操作 xwos/lib/xwbmpaop.h：位图数组原子操作   Adapter：  xwos/ospl/soc/xwaop8.h：8位原子操作 xwos/ospl/soc/xwaop16.h：16位原子操作 xwos/ospl/soc/xwaop32.h：32位原子操作 xwos/ospl/soc/xwaop64.h：64位原子操作 xwos/ospl/soc/xwbmpaop.h：位图数组原子操作   Adaptee：  xwosimpl_soc_xwaop8.h：8位原子操作 xwosimpl_soc_xwaop16.h：16位原子操作 xwosimpl_soc_xwaop32.h：32位原子操作 xwosimpl_soc_xwaop64.h：64位原子操作 xwosimpl_soc_xwbmpaop.h：位图数组原子操作   说明  其他类型的原子操作，XWOS内核会基于4个基本类型进行封装。 64位原子操作如果不支持可不提供； 如果CPU架构比较简单，无原子操作指令，可通过关中断实现这些原子操作函数； 某些CPU架构只提供与CPU位宽一致的原子操作指令，考虑代码的通用性，最好只使用 与CPU位宽一致的原子数据类型；   基本类型的原子操作函数集合：  load()：加载（可指定内存序） store()：存储（可指定内存序） read()：读（内存序：load-require） write()：写（内存序：store-release） add()：加法运算 sub()：减法运算 rsb()：反向减法运算 and()：与运算 or()：或运算 xor()：异或运算 teq_then_write()：测试是否与测试值相等，然后写 teq_then_add()：测试是否与测试值相等，然后做加法运算 teq_then_sub()：测试是否与测试值相等，然后做减法运算 teq_then_rsb()：测试是否与测试值相等，然后做反向减法运算 tne_then_write()：测试是否与测试值不相等，然后写 tne_then_add()：测试是否与测试值不相等，然后做加法运算 tne_then_sub()：测试是否与测试值不相等，然后做减法运算 tne_then_rsb()：测试是否与测试值不相等，然后做反向减法运算 tge_then_write()：测试是否大于等于测试值，然后写 tge_then_add()：测试是否大于等于测试值，然后做加法运算 tge_then_sub()：测试是否大于等于测试值，然后做减法运算 tge_then_rsb()：测试是否大于等于测试值，然后做反向减法运算 tgt_then_write()：测试是否大于测试值，然后写 tgt_then_add()：测试是否大于测试值，然后做加法运算 tgt_then_sub()：测试是否大于测试值，然后做减法运算 tgt_then_rsb()：测试是否大于测试值，然后做反向减法运算 tle_then_write()：测试是否小于等于测试值，然后写 tle_then_add()：测试是否小于等于测试值，然后做加法运算 tle_then_sub()：测试是否小于等于测试值，然后做减法运算 tle_then_rsb()：测试是否小于等于测试值，然后做反向减法运算 tlt_then_write()：测试是否小于测试值，然后写 tlt_then_add()：测试是否小于测试值，然后做加法运算 tlt_then_sub()：测试是否小于测试值，然后做减法运算 tlt_then_rsb()：测试是否小于测试值，然后做反向减法运算 tgele_then_write()：测试是否旧值是否在闭区间[l,r]，然后写 tgele_then_add()：测试是否旧值是否在闭区间[l,r]，然后做加法运算 tgele_then_sub()：测试是否旧值是否在闭区间[l,r]，然后做减法运算 tgele_then_rsb()：测试是否旧值是否在闭区间[l,r]，然后做反向减法运算 tgelt_then_write()：测试是否旧值是否在左闭右开区间[l,r)，然后写 tgelt_then_add()：测试是否旧值是否在左闭右开区间[l,r)，然后做加法运算 tgelt_then_sub()：测试是否旧值是否在左闭右开区间[l,r)，然后做减法运算 tgelt_then_rsb()：测试是否旧值是否在左闭右开区间[l,r)，然后做反向减法运算 tgtle_then_write()：测试是否旧值是否在左开右闭区间(l,r]，然后写 tgtle_then_add()：测试是否旧值是否在左开右闭区间(l,r]，然后做加法运算 tgtle_then_sub()：测试是否旧值是否在左开右闭区间(l,r]，然后做减法运算 tgtle_then_rsb()：测试是否旧值是否在左开右闭区间(l,r]，然后做反向减法运算 tgtlt_then_write()：测试是否旧值是否在开区间(l,r)，然后写 tgtlt_then_add()：测试是否旧值是否在开区间(l,r)，然后做加法运算 tgtlt_then_sub()：测试是否旧值是否在开区间(l,r)，然后做减法运算 tgtlt_then_rsb()：测试是否旧值是否在开区间(l,r)，然后做反向减法运算 tst_then_op()：使用tst函数测试，然后使用op函数操作   位图数组的原子操作  c0i()：将第i位清0 s1i()：将第i位置1 x1i()：翻转第i位 t1i()：测试第i位是否为1 t0i_then_s1i()：测试第i位是否为0，然后把它置1 t1i_then_c0i()：测试第i位是否为1，然后把它清0 ffs_then_c0i()：从最低有效位开始查找第一个为1的位并把它清0 ffz_then_s1i()：从最低有效位开始查找第一个为0的位并把它置1 fls_then_c0i()：从最高有效位开始查找第一个为1的位并把它清0 flz_then_s1i()：从最高有效位开始查找第一个为0的位并把它置1    无锁队列 XWOS的C库中提供了无锁队列的函数，无锁队列的实现依赖于CPU的原子操作指令。\n XWOS头文件：xwos/lib/lfq.h Adapter：xwos/ospl/soc/lfq.h Adaptee：xwosimpl_soc_lfq.h  自旋锁 在多核系统中，被多个CPU共同访问的内存区域需要被自旋锁保护，自旋锁的实现依赖于 原子操作指令与内存屏障指令。\n XWOS头文件：  xwos/osal/lock/spinlock.h：自旋锁 xwos/osal/lock/seqlock.h：自旋锁的派生锁，顺序锁   Adapter：xwos/ospl/soc/spinlock.h Adaptee：xwosimpl_soc_spinlock.h  中断  XWOS头文件：xwos/osal/irq.h Adapter：  xwos/ospl/irq.h：定义了BSP中需要适配的函数； xwos/ospl/soc/irq.h：包含了与SOC相关的一些中断结构体类型的定义。   Adaptee：  xwosimpl_irq.h：实现了XWOS移植层中定义的函数； xwosimpl_soc_irq.h：提供了与SOC相关的一些中断结构体类型的定义。   结构体类型：  struct soc_irq_cfg：每个中断配置，例如优先级等； struct soc_irq_data：每个中断的数据（中断处理函数的参数）。   结构体：  xwospl_ivt：中断向量表，由于每个电路板的中断情况不一样，因此此结构体 通常定义在电路板描述层(BDL)； xwospl_idvt：中断参数表，由于每个电路板的中断情况不一样，因此 此结构体通常定义在电路板描述层(BDL)。   中断号：  XWOS定义了中断号类型xwirq_t，是一个有符号数：  整数和0：表示SOC的外设中断，外设中断通常可以配置与CPU的“亲合力”； 负数：表示异常，异常通常是每个都有的CPU私有中断。     中断优先级  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  操作系统移植层中需要提供的函数：  xwospl_cpuirq_enable_lc()：打开当前CPU的中断开关 xwospl_cpuirq_disable_lc()：关闭当前CPU的中断开关 xwospl_cpuirq_restore_lc()：恢复当前CPU的中断开关 xwospl_cpuirq_save_lc()：存储当前CPU的中断开关标志，然后关闭 xwospl_irq_get_id()：获取当前中断的中断号 xwospl_irq_request()：申请中断 xwospl_irq_release()：释放中断 xwospl_irq_enable()：开启中断 xwospl_irq_disable()：关闭中断 xwospl_irq_save()：保存中断开关标志并关闭中断 xwospl_irq_restore()：恢复中断开关标志 xwospl_irq_pend()：挂起中断标志 xwospl_irq_clear()：清除中断标志 xwospl_irq_cfg()：配置中断 xwospl_irq_get_cfg();：获取中断配置 xwospl_irq_get_data()：获取中断数据    硬件定时器 每个CPU都需要一个私有的硬件定时器提供滴答中断，XWOS的调度、超时、软件定时器都 基于滴答中断来实现。\n Adapter：xwos/ospl/syshwt.h Adaptee：xwosimpl_syshwt.h 适配函数：  xwospl_syshwt_init()：初始化硬件定时器 xwospl_syshwt_start()：启动硬件定时器 xwospl_syshwt_stop()：关闭硬件定时器 xwospl_syshwt_get_timeconfetti()：返回还有多少纳秒进入下一次定时器中断    调度器  Adapter：xwos/ospl/skd.h Adaptee：xwosimpl_skd.h 适配函数：  xwospl_skd_init()：初始化调度调度器，一般用于初始化调度相关的中断 xwospl_skd_init_stack()：初始化调度对象的栈 xwospl_skd_get_id()：获取当前CPU的ID xwospl_skd_start_lc()：启动调度器 xwospl_skd_suspend()：暂停调度器，用于电源管理 xwospl_skd_resume()：继续调度器，用于电源管理 xwospl_thrd_exit_lc()：本地CPU上的线程退出 xwospl_thrd_freeze_lc()：冻结本地CPU中正在运行的线程 xwospl_thrd_outmigrate()：将线程迁出其他CPU，并准备迁入其他CPU（仅限多核） xwospl_thrd_immigrate()：迁移线程至目标CPU（仅限多核）    链接脚本 SOC描述层中包含了SOC的基本链接脚本，使用时需要在电路板目录的cfg文件夹中定义 一个XuanWuOS.lds，其中包含了SOC的地址空间的定义，然后再includeSOC描述层 中的连接脚本即可。例如：xwbd/WeActH750/cfg/XuanWuOS.lds中只定义了MEMORY， 然后include xwcd/soc/arm/v7m/gcc/m7/stm32/h7.lds。\n XWOS定义了一些段(section)，链接时，可将内核代码、内核数据放在镜像文件的 特定区域。这需要在链接脚本中指明这些段如何存放。  __xwos_init_code：初始化代码，存放在**.xwos.init.text**段 __xwos_init_rodata：初始化阶段的const数据，存放在**.xwos.init.rodata**段 __xwos_exit_code：退出代码，存放在**.xwos.exit.text**段 __xwos_exit_rodata：退出阶段的const数据，存放在**.xwos.exit.rodata**段 __xwos_ivt：中断向量表，存放在**.xwos.ivt**段 __xwos_isr：中断代码，存放在**.xwos.isr.text**段 __xwos_bh：中断底半部代码，存放在**.xwos.isr.text**段 __xwos_code：XWOS内核代码，存放在**.xwos.text**段 __xwos_api：XWOS内核API，存放在**.xwos.text**段 __xwos_rodata：const数据，存放在**.xwos.rodata**段 __xwos_data：全局变量与静态变量，存放在**.xwos.data**段   如果不需要这些自定义的段，可将上面的宏定义为空，相应的，代码会默认 放在.text段，数据会默认放在.data段，const数据会默认放在.rodata段。 这三个段都是由编译器默认产生的。 当__xwos_data定义为空时，配置文件cfg/xwos.h中的 配置XWKNCFG_RELOCATE_DATA也应该不定义或定义为0。  初始化流程 XWOS提供了一个通用的启动流程：\nflowchart LR poweron(\"上电\") --\u003e 低级初始化阶段 --\u003e 系统初始化阶段 --\u003e 用户程序 subgraph 低级初始化阶段 direction TB arch_lowlevel_init[\"arch_lowlevel_init()\"] --\u003e cpu_lowlevel_init cpu_lowlevel_init[\"cpu_lowlevel_init()\"] --\u003e soc_lowlevel_init soc_lowlevel_init[\"soc_lowlevel_init()\"] --\u003e board_lowlevel_init board_lowlevel_init[\"board_lowlevel_init()\"] end subgraph 系统初始化阶段 direction TB xwos_init[\"xwos_init()\"] --\u003e arch_relocate arch_relocate[\"arch_relocate()\"] --\u003e arch_init arch_init[\"arch_init()\"] --\u003e cpu_init cpu_init[\"cpu_init()\"] --\u003e soc_init soc_init[\"soc_init()\"] --\u003e board_init end subgraph 用户程序 direction LR subgraph \"xwos_main()\" direction LR skd[\"启动调度器\"] thd[\"线程初始化\"] device[\"设备驱动初始化\"] libc[\"C/C++标准库初始化\"] lua[\"Lua虚拟机初始化\"] end end  用户可在流程中找地方插入SOC的初始化的代码，但要注意：  lowlevel_init的流程中不可访问全局变量，因为还未将全局变量的初值从 flash中拷贝到RAM中； cxx_init之后才可开始调用C++的代码；   XWOS的初始化流程中，在soc_init()中完成对中断控制器、调度器的初始化， 如果用户不使用XWOS的初始化流程，需要依次调用：  xwos_init()：初始化XWOS内核； 多核系统：  xwmp_irqc_construct()：初始化每个CPU的中断控制器； xwmp_irqc_register()：将每个CPU的中断控制器注册到中断控制子系统； xwmp_skd_init_lc()：分别在每个CPU上都运行一次这个函数初始化自己的调度器；   单核系统：  xwup_irqc_init()：初始化中断控制器； xwup_skd_init_lc()：初始化调度器；      编译集成环境 XWOS提供了一个构建系统，可在Windows、Linux上运行。 用户可以选择使用XWOS的编译集成环境，也可以使用其他IDE进行编译。\n使用玄武构建系统  XWOS的构建系统在构建内核、xwmd模块、xwcd模块、xwem模块、 xwam模块、oem模块时都是独立编译成静态库**.a**，然后再链接。 各个模块的编译配置（头文件、编译器选项）都是完全独立的，可以理解为不同的子工程。 构建是从xwbd/电路板名称/录下执行命令make开始的。  使用其他IDE构建系统  需要增加的头文件搜索路径：  XuanWuOS根目录XuanWuOS 架构描述层(ADL)目录：以ARMv7m为例，xwcd/soc/arm/v7m/gcc CPU描述层(CDL)目录：以ARMv7m7为例，xwcd/soc/arm/v7m/gcc/m7 SOC描述层(SDL)目录：以STM32H7为例，xwcd/soc/arm/v7m/gcc/m7/stm32h7x 电路板目录：以开发板WeActH750为例，xwbd/WeActH750   需要包含的源码文件：  内核目录xwos 架构描述层(ADL)目录：以ARMv7m为例，xwcd/soc/arm/v7m/gcc CPU描述层(CDL)目录：以ARMv7m7为例，xwcd/soc/arm/v7m/gcc/m7 SOC描述层(SDL)目录：以STM32H7为例，xwcd/soc/arm/v7m/gcc/m7/stm32h7x 电路板目录：以开发板WeActH750为例，xwbd/WeActH750 中间件xwmd、驱动框架xwcd/ds、第三方模块xwem、应用模块xwam 不是必须的，若只使用XWOS内核，这些可以删除。   若其他IDE的工具链不是gcc，则需要重新实现ADL、CDL、SDL中的代码， 此种情况xwcd/soc中的代码也不需要。 需要修改配置，以开发板WeActH750为例，xwbd/WeActH750/cfg。 需要在xwbd/WeActH750目录，执行一次make cfg，生成 然后将xwbd/WeActH750/wkspc/autogen.h拷贝到xwbd/WeActH750/cfg中。 需要配置IDE的连接脚本。  ","categories":"","description":"","excerpt":"概述 XWOS的移植，包括以下几个环节：\n 编译环境 初始化流程 XWOS移植层（XWOSPL） XWOS移植实现层（XWOSIMPL） …","ref":"/docs/note/soc/","tags":"","title":"SOC移植笔记"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/quick-guide/stm32/","tags":"","title":"STM32"},{"body":"介绍 由于ST官方的STM32CubeMX能自动生成初始化芯片的代码，因此 XWOS中STM32的架构描述层(ADL)、CPU描述层(CDL)、SOC描述层(SDL)的代码几乎 是一致的，唯一区别是链接脚本。\n链接脚本 STM32的链接脚本也是按照可复用的方式设计的，分为两部分：\n SDL中的链接脚本：描述各个段如何分布在镜像文件中  STM32F0：xwcd/soc/arm/v7m/gcc/m0/stm32/f0.lds STM32G0：xwcd/soc/arm/v7m/gcc/m0p/stm32/g0.lds STM32F1：xwcd/soc/arm/v7m/gcc/m3/stm32/f1.lds STM32L1：xwcd/soc/arm/v7m/gcc/m3/stm32/l1.lds STM32F4：xwcd/soc/arm/v7m/gcc/m4/stm32/f4.lds STM32L4：xwcd/soc/arm/v7m/gcc/m4/stm32/l4.lds STM32F7：xwcd/soc/arm/v7m/gcc/m7/stm32/f7.lds STM32H7：xwcd/soc/arm/v7m/gcc/m7/stm32/h7.lds 其他SOC还在持续增加中…   BDL中的链接脚本：只描述内存区域  Stm32F072HiXWOS工程：xwbd/Stm32F072HiXWOS/cfg/XuanWuOS.lds Stm32F103HiXWOS工程：xwbd/Stm32F103HiXWOS/cfg/XuanWuOS.lds ATKStm32H743工程：xwbd/ATKStm32H743/cfg/XuanWuOS.lds EmbedFireStm32H743工程：xwbd/EmbedFireStm32H743/cfg/XuanWuOS.lds ATKStm32F103Core工程：xwbd/ATKStm32F103Core/cfg/XuanWuOS.lds ATKStm32F407Core工程：xwbd/ATKStm32F407Core/cfg/XuanWuOS.lds FK429M1工程：xwbd/FK429M1/cfg/XuanWuOS.lds WeActMiniStm32H750工程：xwbd/WeActMiniStm32H750/cfg/XuanWuOS.lds WeActMiniStm32H750Bootloader工程：xwbd/WeActMiniStm32H750Bootloader/cfg/XuanWuOS.lds 其他电路板还在持续增加中…    不同的电路板工程，只有Board中链接脚本中的Memory区域不同。\nlds的基本语法 定义存储器区域 名字 (属性): org = xxx, len = xxx  o, org, ORIGIN: 表示定义存储器的起始地址 l, len, LENGTH: 表示定义存储器长度 ORIGIN(x): 表示取存储器x的起始地址 LENGTH(x): 表示取存储器x的长度 属性: r表示读，w表示写，a表示可申请，x表示可执行  ivt_lmr \u0026 ivt_vmr XWOS的中断向量表区域，其中LMR表示中断向量的加载地址区域， 也即是中断向量在Flash中的存储位置，VMR表示中断向量的运行地址区域， 也即是上电运行时的中断向量的地址。\n 如果LMR与VMR都指向Flash，且起始地址(org)与大小(len)完全一致，表示加载地址 就是运行地址，XWOS在初始化阶段不会对中断向量执行拷贝操作； 如果VMR指向RAM的某个地址，XWOS会在初始化阶段把Flash中的中断向量表拷贝到 VMR指定的RAM内，并设置ARM的VTOR寄存器； 需要注意ARM的VTOR寄存器低7位(0~6)必须保持为0，因此VMR的起始地址也必须满足 此规则。  image_description_mr 此段中包含镜像文件的一些基本信息，例如起始位置，结尾标志位置等，可用在升级固件功能中。\ncode_mr 存放代码和常量的地方。\nxwos_data_mr 存放xwos全局数据的地方，这些变量在定义时带有修饰符：__xwos_data，此段可以 不存在，若不存在，需要在SDL中的链接脚本中将此段的数据放到data_mr中。\ndata_mr 存放全局变量的地方。当连接器ld安排完全局变量后，剩余的部分会交给XWOS 的默认的内核内存分配器进行管理，用于为动态创建内核对象的API提供动态内存申请的接口。\nxwos_stk_mr XWOS内核的栈内存，XWOS内核处理中断时会使用此内存作为函数的栈。\nSOC的初始化 STM32CubeMX生成的初始化代码，分别由stm32cube_lowlevel_init()与stm32cube_init()执行， 这两个函数在启动流程中分别 被board_lowlevel_init与board_init()调用。\nSTM32CubeMX STM32CubeMX工程是以玄武模块中的电路板模块的方式进行集成的， 详细可参考构建系统。\n各个工程的STM32CubeMX工程如下（可在STM32CubeMX中打开）：\n Stm32F072HiXWOS工程：xwbd/Stm32F072HiXWOS/bm/stm32cube/cubemx/Stm32F072HiXWOS.ioc Stm32F103HiXWOS工程：xwbd/Stm32F103HiXWOS/bm/stm32cube/cubemx/Stm32F103HiXWOS.ioc ATKStm32H743工程：xwbd/ATKStm32H743/bm/stm32cube/cubemx/ATKStm32H743.ioc EmbedFireStm32H743工程：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/EmbedFireStm32H743.ioc ATKStm32F103Core工程：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx/ATKStm32F103Core.ioc ATKStm32F407Core工程：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx/ATKStm32F407Core.ioc FK429M1工程：xwbd/FK429M1/bm/stm32cube/cubemx/FK429M1.ioc WeActMiniStm32H750工程：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx/WeActMiniStm32H750.ioc WeActMiniStm32H750Bootloader工程：xwbd/WeActMiniStm32H750Bootloader/bm/stm32cube/cubemx/WeActMiniStm32H750Bootloader.ioc  中断优先级  XWOS对中断优先级的要求：  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  NVIC设置  设置3个抢占优先级位和1个子优先级位 SVC中断设置成最高优先级，即Preemption Priority为0； PendSV中断设置成最低优先级，即Preemption Priority为7； Systick中断设置成最低优先级，即Preemption Priority为7； 系统Fault的优先级设置为0； 其他中断的优先级只可在1~6之间。。    中断向量表 STM32CubeMX生成的代码中断向量表是放在startup.s中，XWOS并不使用这个文件，因此需要 另外增加中断向量表。STM32型号太多，一个一个编辑工作量巨大，但观察STM32寄存器定义的 头文件（例如：stm32h750xx.h），可以发现IRQn_Type这个枚举类型，其中列举了 所有的中断号，因此可使用脚本自动生成中断向量表的代码。\n本项目中提供了一个Emacs-Lisp脚本xwbs/util/el/stm32ivt/stm32ivt.el来完成这项工作， 用法：\nxwbs/util/el/stm32ivt/stm32ivt.el xwbd/电路板名称/bm/stm32cube  需要注意脚本指定的路径为cubemx的父目录stm32cube； 脚本执行完成后，会生成名为IVT的文件夹； 此脚本能自动获取芯片型号等信息； 生成的两个.c文件需要写入xwmo.mk。  CUBEMX_CSRCS += IVT/isr.c CUBEMX_CSRCS += IVT/ivt.c xwac 文件夹xwac中存放的都是适配性质的代码，是连接STM32CubeMX HAL库与XWOS的纽带。 文件夹名中的ac是Adaptation Code的缩写。\n fatfs：fatfs底层设备驱动 newlib：为标准C库提供底层的支持  mem.c：malloc()系列函数的内存池 stdio.c：定义stdin的输入设备，stdout、stderr的输出设备   xwds：STM32的设备栈 xwlib：为XWOS通用库提供底层硬件支持，例如使用硬件CRC模块加速CRC运算、定义Log的输出设备等 xwos：XWOS内核的Hook函数  ","categories":"","description":"","excerpt":"介绍 由于ST官方的STM32CubeMX能自动生成初始化芯片的代码，因此 XWOS中STM32的架构描述层(ADL)、CPU描述 …","ref":"/docs/note/soc/arm-m/stm32/","tags":"","title":"STM32移植说明"},{"body":"","categories":"","description":"XWOS的快速上手指南\n","excerpt":"XWOS的快速上手指南\n","ref":"/docs/quick-guide/","tags":"","title":"上手指南"},{"body":"XWLUA API参考 包：xwlib.bmp xwlib.bmp.new(bits)  简介：新建一个位图数据结构 参数bits：(number, 输入)位图中包含位的数量 返回值：(userdata)新的位图 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 运算符  说明：位图支持部分Lua运算符  位与 \u0026  简介：两个位图按位进行与运算 说明：要求两个位图的位数相同。 示例：  mybmp1 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图1 mybmp1:fill() -- 全部填充1 mybmp2 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图2 mybmp2:zero() -- 全部填清0 mybmp2:s1i(1, 2, 3, 4, 5, 6, 7, 8) mybmp3 = mybmp1 \u0026 mybmp2 -- mybmp1与mybmp2按位进行与运算 print(mybmp3)  示例输出：  00000000000000FF 位或 |  简介：两个位图按位进行或运算 说明：要求两个位图的位数相同。 示例：  mybmp1 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图1 mybmp1:zero() -- 全部填清0 mybmp2 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图2 mybmp2:zero() -- 全部填清0 mybmp2:s1i(1, 2, 3, 4, 5, 6, 7, 8) mybmp3 = mybmp1 | mybmp2 -- mybmp1与mybmp2按位进行与运算 print(mybmp3)  示例输出：  00000000000000FF 位异或 ~  简介：两个位图按位进行异或运算 说明：要求两个位图的位数相同。 示例：  mybmp1 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图1 mybmp1:fill() -- 全部填充1 mybmp2 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图2 mybmp2:zero() -- 全部填清0 mybmp2:s1i(1, 2, 3, 4, 5, 6, 7, 8) mybmp3 = mybmp1 ~ mybmp2 -- mybmp1与mybmp2按位进行与运算 print(mybmp3)  示例输出：  FFFFFFFFFFFFFF00 位取反 ~  简介：位图按位取反 示例：  mybmp1 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图1 mybmp1:fill() -- 全部填充1 mybmp2 = ~mybmp1 print(mybmp1) print(mybmp2)  示例输出：  FFFFFFFFFFFFFFFF 0000000000000000 **计算长度  简介：计算位图的长度 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图1 print(#mybmp)  示例输出：  64 比较相等 ==  说明：要求两个位图的位数相同。 示例：  mybmp1 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图1 mybmp1:fill() -- 全部填充1 mybmp2 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图2 mybmp2:fill() -- 全部填充1 if (mybmp1 == mybmp2) then print(\"equal\") end  示例输出：  equal 类：bmp  说明：位图类  bmp:fill()  简介：将位图全部填1 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:fill() -- 全部填充1 print(mybmp)  示例输出：  FFFFFFFFFFFFFFFF bmp:zero()  简介：将位图全部清0 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 全部填充0 print(mybmp)  示例输出：  0000000000000000 bmp:assign(opd)  简介：赋值位图 参数bmp：(userdata, 输入)类成员函数的this参数，目的位图对象 参数opd：(userdata, 输入)源位图对象 说明：  此函数将位图opd中的内容拷贝到位图bmp中，属于深拷贝 此函数与bmp = opd不同，bmp = opd只是将引用bmp指向opd，bmp 原来的对象如果没有被别的引用持有，将会被虚拟机回收掉，属于浅拷贝。   示例：  mybmp1 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图1 mybmp1:fill() -- 全部填充1 mybmp2 = xwlib.bmp.new(64) -- 创建一个包含64个位的位图2 mybmp2:assign(mybmp1) print(mybmp1) print(mybmp2)  示例输出：  FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF bmp:weight()  简介：计算位图中1的个数 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 返回值：(number)位图中1的个数 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 清0 mybmp:s1i(1, 10) -- 第10位填充1 print(mybmp:weight())  示例输出：  2 bmp:ffs()  简介：从位图的最低位开始，查找第一个被置1的位的序号 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 返回值：(number)序号 说明：为了和Lua语言保持一致，序号从1开始的，返回0表示没有找到1。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 清0 mybmp:s1i(10) -- 第10位填充1 mybmp:s1i(11) -- 第11位填充1 print(mybmp:ffs())  示例输出：  10 bmp:ffz()  简介：从位图的最低位开始，查找第一个被清0的位的序号 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 返回值：(number)序号 说明：为了和Lua语言保持一致，序号从1开始的，返回0表示没有找到0。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 清0 mybmp:s1i(10) -- 第10位填充1 mybmp:s1i(11) -- 第11位填充1 print(mybmp:ffz())  示例输出：  1 bmp:fls()  简介：从位图的最高位开始，查找第一个被置1的位的序号 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 返回值：(number)序号 说明：为了和Lua语言保持一致，序号从1开始的，返回0表示没有找到1。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 清0 mybmp:s1i(10) -- 第10位填充1 mybmp:s1i(11) -- 第11位填充1 print(mybmp:fls())  示例输出：  11 bmp:flz()  简介：从位图的最高位开始，查找第一个被清0的位的序号 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 返回值：(number)序号 说明：为了和Lua语言保持一致，序号从1开始的，返回0表示没有找到0。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 清0 mybmp:s1i(10) -- 第10位填充1 mybmp:s1i(11) -- 第11位填充1 print(mybmp:flz())  示例输出：  64 bmp:s1i(pos1[, pos2, …])  简介：依次将位图中给定位置的位设置为1 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数pos1：(number, 输入)位的序号 可选参数pos2, …：(number, 输入)剩余位的序号列表 说明：为了和Lua语言保持一致，序号从1开始的。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 清0 mybmp:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填充1 print(mybmp)  示例输出：  000000000000020B bmp:s1m(msk)  简介：将位图中的掩码部分全部设置为1 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数msk：(userdata, 输入)掩码位图 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mymsk = xwlib.bmp.new(64) -- 创建一个包含64个位的位图掩码 mymsk:zero() -- 清0 mymsk:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填1 mybmp:zero() -- 清0 mybmp:s1m(mymsk) print(mybmp)  示例输出：  000000000000020B bmp:c0i(pos1[, pos2, …])  简介：依次将位图中给定位置的位设置为1 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数pos：(number, 输入)位的序号 说明：为了和Lua语言保持一致，序号从1开始的。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:fill() -- 填1 mybmp:c0i(1, 2, 4, 10) -- 第1, 2, 4, 10位清0 print(mybmp)  示例输出：  FFFFFFFFFFFFFDF4 bmp:c0m(msk)  简介：将位图中的掩码部分全部设置为0 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数msk：(userdata, 输入)掩码位图 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mymsk = xwlib.bmp.new(64) -- 创建一个包含64个位的位图掩码 mymsk:zero() -- 清0 mymsk:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填1 mybmp:fill() -- 填1 mybmp:c0m(mymsk) print(mybmp)  示例输出：  FFFFFFFFFFFFFDF4 bmp:x1i(pos1[, pos2, …])  简介：依次将位图中给定位置的位翻转 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数pos：(number, 输入)位的序号 说明：为了和Lua语言保持一致，序号从1开始的。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:zero() -- 清0 mybmp:x1i(1, 2, 4, 10) -- 第1, 2, 4, 10位翻转 print(mybmp)  示例输出：  000000000000020B bmp:x1m(msk)  简介：将位图中的掩码部分全部翻转 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数msk：(userdata, 输入)掩码位图 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mymsk = xwlib.bmp.new(64) -- 创建一个包含64个位的位图掩码 mymsk:zero() -- 清0 mymsk:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填1 mybmp:zero() -- 清0 mybmp:x1m(mymsk) print(mybmp)  示例输出：  000000000000020B bmp:t1i(pos)  简介：测试位图中的某个位是否为1 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数pos：(number, 输入)位的序号 返回值：(boolean)  true：1 false：0   说明：为了和Lua语言保持一致，序号从1开始的。 示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mybmp:fill() -- 填1 mybmp:c0i(1, 2, 4, 10) -- 第1, 2, 4, 10位清0 print(mybmp:t1i(1)) print(mybmp:t1i(11))  示例输出：  false true bmp:t1ma(msk)  简介：测试位图中的掩码部分是否全部为1 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数msk：(userdata, 输入)掩码位图 返回值：(boolean)  true：全部为1 false：不是全部为1   示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mymsk = xwlib.bmp.new(64) -- 创建一个包含64个位的位图掩码 mymsk:zero() -- 清0 mymsk:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填1 mybmp:zero() -- 清0 mybmp:s1i(1, 2) -- 第1, 2位填1 print(mybmp:t1ma(mymsk)) mybmp:s1i(4, 10) -- 第4, 10位填1 print(mybmp:t1ma(mymsk))  示例输出：  false true bmp:t1mo(msk)  简介：测试位图中的掩码部分是否至少有1位为1 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数msk：(userdata, 输入)掩码位图 返回值：(boolean)  true：至少有1位为1 false：全部为0   示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mymsk = xwlib.bmp.new(64) -- 创建一个包含64个位的位图掩码 mymsk:zero() -- 清0 mymsk:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填1 mybmp:zero() -- 清0 mybmp:s1i(1, 2) -- 第1, 2位填1 print(mybmp:t1mo(mymsk)) mybmp:s1i(4, 10) -- 第4, 10位填1 print(mybmp:t1mo(mymsk))  示例输出：  true true bmp:t0ma(msk)  简介：测试位图中的掩码部分是否全部为0 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数msk：(userdata, 输入)掩码位图 返回值：(boolean)  true：全部为0 false：不是全部为0   示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mymsk = xwlib.bmp.new(64) -- 创建一个包含64个位的位图掩码 mymsk:zero() -- 清0 mymsk:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填1 mybmp:fill() -- 填1 mybmp:c0i(1, 2) -- 第1, 2位清0 print(mybmp:t0ma(mymsk)) mybmp:c0i(4, 10) -- 第4, 10位清0 print(mybmp:t0ma(mymsk))  示例输出：  false true bmp:t0mo(msk)  简介：测试位图中的掩码部分是否至少有1位为0 参数bmp：(userdata, 输入)类成员函数的this参数，位图对象 参数msk：(userdata, 输入)掩码位图 返回值：(boolean)  true：至少有1位为0 false：全部为1   示例：  mybmp = xwlib.bmp.new(64) -- 创建一个包含64个位的位图 mymsk = xwlib.bmp.new(64) -- 创建一个包含64个位的位图掩码 mymsk:zero() -- 清0 mymsk:s1i(1, 2, 4, 10) -- 第1, 2, 4, 10位填1 mybmp:fill() -- 填1 mybmp:c0i(1, 2) -- 第1, 2位清0 print(mybmp:t0mo(mymsk)) mybmp:c0i(4, 10) -- 第4, 10位清0 print(mybmp:t0mo(mymsk))  示例输出：  true true ","categories":"","description":"XWLUA的位图\n","excerpt":"XWLUA的位图\n","ref":"/docs/lua-manual/xwlib/bitmap/","tags":"","title":"位图"},{"body":"位操作 XWOS提供了位操作模板库，基本类型中定义的 各种非函数指针类型都可使用位操作。位操作函数模板包括：\n xwbop_s1m()：将数据掩码部分的位全部置1 xwbop_c0m()：将数据掩码部分的位全部清0 xwbop_x1m()：将数据掩码部分的位全部翻转 xwbop_rbit()：将数据的位镜面翻转 xwbop_re()：将数据的大小端翻转 xwbop_ffs()：在数据中从最低位起查找第一个被置1的位 xwbop_fls()：在数据中从最高位起查找第一个被置1的位1的位 xwbop_ffz()：在数据中从最低位起查找第一个被清0的位 xwbop_flz()：在数据中从最高位起查找第一个被清0的位 xwbop_weight()：统计数据中1的个数  所有位操作函数的第一个参数均为基本类型，第二个参数 是数据或数据的指针，例如：\nxwssq_t idx; /* 从最低位开始查找\"xwu32_t\"类型的数据\"0\"中第一个被置1的位，结果为-1 */ idx = xwbop_ffs(xwu32_t, 0); /* 从最低位开始查找\"xwu32_t\"类型的数据\"0xF0\"中第一个被置1的位，结果为4 */ idx = xwbop_ffs(xwu32_t, 0xF0); /* 将\"xwu32_t\"类型的数据\"0xAA\"进行镜像翻转，结果为0x55 */ xwu32_t rdata = xwbop_rbit(xwu32_t, 0xAA); 位图操作 XWOS提供了基本类型xwbmp_t，用于定义位图，位图是xwbmp_t的数组。 用户可以声明任意位数的位图，XWOS提供了函数集方便用户操作位图：\n xwbmpop_declare()：声明位图 xwbmpop_assign()：赋值 xwbmpop_cmp()：比较两个位图 xwbmpop_s1all()：所有位置1 xwbmpop_c0all()：所有位清0 xwbmpop_s1i()：将位图中某位置1 xwbmpop_s1m()：将位图中掩码部分置1 xwbmpop_c0i()：将位图中某位清0 xwbmpop_c0m()：将位图中掩码部分清0 xwbmpop_x1i()：将位图中某位翻转 xwbmpop_x1m()：将位图中掩码部分翻转 xwbmpop_t1i()：测试位图中的某位是否为1 xwbmpop_t1ma()：测试位图中掩码部分是否全部为1 xwbmpop_t1ma_then_c0m()：测试位图中掩码部分是否全部为1，如果是，就将掩码部分全部清0 xwbmpop_t1mo()：测试位图中掩码部分是否至少有一位为1 xwbmpop_t1mo_then_c0m()：测试位图中掩码部分是否至少有一位为1，如果是，就将掩码部分全部清0 xwbmpop_t0ma()：测试位图中掩码部分是否全部为0 xwbmpop_t0ma_then_s1m()：测试位图中掩码部分是否全部为0，如果是，就将掩码部分全部置1 xwbmpop_t0mo()：测试位图中掩码部分是否至少有一位为0 xwbmpop_t0mo_then_s1m()：测试位图中掩码部分是否至少有一位为0，如果是，就将掩码部分全部置1 xwbmpop_not()：非运算 xwbmpop_and()：与运算 xwbmpop_or()：或运算 xwbmpop_xor()：异或运算 xwbmpop_ffs()：从最低位起查找第一个被置1的位 xwbmpop_fls()：从最高位起查找第一个被置1的位 xwbmpop_ffz()：从最低位起查找第一个被清0的位 xwbmpop_flz()：从最高位起查找第一个被清0的位 xwbmpop_weight()：统计1的个数  API参考  文档未及时更新时，以头文件xwos/lib/xwbop.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的位操作库\n","excerpt":"XWOS的位操作库\n","ref":"/docs/user-manual/xwlib/xwbop/","tags":"","title":"位操作库"},{"body":"XWLUA API参考 包：xwos.sem xwos.sem.new(val, max)  简介：新建一个信号量 参数val：(number, 输入)信号量的初始值 参数max：(number, 输入)信号量的最大值 返回值：(userdata)新的信号量对象的强引用指针 示例：  mysem = xwos.sem.new(0, 10) -- 创建初始值为0，最大值为10的信号量 类：semsp  说明：信号量对象强指针类  semsp:bind(sel)  简介：绑定信号量对象到信号选择器 参数semsp：(userdata, 输入)类成员函数的this参数，信号量对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ECHRNG: 位置超出范围 -EALREADY: 同步对象已经绑定到事件对象 -EBUSY: 通道已经被其他同步对象独占    semsp:unbind(sel)  简介：从信号选择器上解绑信号量对象 参数semsp：(userdata, 输入)类成员函数的this参数，信号量对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    semsp:freeze()  简介：解冻信号量 参数semsp：(userdata, 输入)类成员函数的this参数，信号量对象的强引用指针 返回值：(number)错误码  0：成功 -EALREADY：信号量已被冻结    semsp:thaw()  简介：解冻信号量 参数semsp：(userdata, 输入)类成员函数的this参数，信号量对象的强引用指针 返回值：(number)错误码  0：成功 -EALREADY：信号量未被冻结    semsp:post()  简介：发布信号量 参数semsp：(userdata, 输入)类成员函数的this参数，信号量对象的强引用指针 返回值：(number)错误码  0：成功 -ENEGATIVE：信号量已被冻结 -ERANGE：信号量的值已经最大    semsp:wait([op])  简介：等待并获取信号量 参数semsp：(userdata, 输入)类成员函数的this参数，信号量对象的强引用指针 可选参数op：  “t”：(string, 输入)尝试等待并获取信号量，若信号量的值小于等于0，立即返回， 不会等待； time：(number, 输入)期望的等待时间，超时后返回错误码-ETIMEDOUT。   返回值：(number)错误码  0：无错误 -EINVAL：参数错误 -ENODATA：尝试失败，仅当存在可选参数\"t\"时才会出现此错误值 -ETIMEDOUT：超时 -EINTR：等待被中断 -ENOTINTHD：不在线程上下文中    ","categories":"","description":"XWLUA的信号量\n","excerpt":"XWLUA的信号量\n","ref":"/docs/lua-manual/xwos/sync/sem/","tags":"","title":"信号量"},{"body":"介绍 信号量通常用于不同代码上下文间的同步，使用PV原语进行操作， 属于操作系统比较底层的同步机制。XWOS内核的信号量有两种：\n  管道信号量(PLSEM)：对所有阻塞在其等待队列中的线程按照先进先出(FIFO)的策略调度， 即当信号量可用时，最先进入等待队列中的线程将优先获得信号量。\n  实时信号量(RTSEM)：对所有阻塞在其等待队列中的线程按照优先级进行调度，即高优先级 的线程总是最先获得信号量，同优先级的线程按先进先出(FIFO)的策略调度。\n  操作系统抽象层(OSAL)的API只封装了一种信号量，当系统配置文件中同时 配置了管道信号量与实时信号量时，优先使用实时信号量。\n信号量的创建、初始化与删除、销毁 信号量支持静态初始化与销毁，动态创建与删除两种方式：\n 静态初始化与销毁  静态是指用户预先定义对象，这些对象在编译时由编译器分配内存。 初始化：xwos_sem_init() 销毁：xwos_sem_fini()   动态创建与删除  动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。 创建：xwos_sem_create() 删除：xwos_sem_delete()    信号量的P操作 P操作是指发布信号量，使得信号量的计数器加1，同时会唤醒信号量等待队列中的一个线程。 被唤醒的线程会进行V操作，取走信号量中的一个信号，使得信号量的计数器减1。\n xwos_sem_post()  可在中断上下文、中断底半部、线程上下文中使用    信号量的V操作 V操作是指取走信号量中的一个信号，使得信号量的计数器减1，XWOS提供四种方式：\n xwos_sem_trywait()  只是测试一下信号量，如果失败，就返回-ENODATA，不会阻塞调用的线程； 可在中断上下文、中断底半部、线程上下文中使用。   xwos_sem_wait()  只可在线程上下文中使用； 调用的线程若无法获取信号量，就会被阻塞； 线程的阻塞状态可被中断，中断将返回-EINTR。   xwos_sem_timedwait()  只可在线程上下文中使用； 调用的线程若无法获取信号量，就会被阻塞，并有时间限制； 超时的参数用法可以参考超时API的统一形式； 超时后阻塞状态解除，并以-ETIMEDOUT返回； 线程的阻塞状态可被中断，中断将返回-EINTR。   xwos_sem_wait_unintr()  只可在线程上下文中使用； 调用的线程若无法获取信号量，就会被阻塞； 线程的阻塞状态不可被中断。    信号量的中断操作 中断操作是指XWOS在处理内核事件时中断线程的**“阻塞”**或**“睡眠”**， 强制使其进入**就绪**状态。xwos_sem_wait()和xwos_sem_timedwait() 会返回-EINTR，但xwos_sem_wait_unintr()不能被中断。 相关的内核事件：\n 系统休眠； 线程准备从一个CPU迁移到另一个CPU。  信号量的冻结与解冻操作 冻结信号量是指不允许信号量被发布（P操作），但可以被测试（V操作）。 使用APIxwos_sem_wait()、xwos_sem_timedwait()与xwos_sem_wait_unintr() 测试已冻结信号量的线程都将被阻塞。 解冻后，信号量的计数器重新从0开始计数，并可以重新开始进行发布（P）操作。\n 冻结：xwos_sem_freeze() 解冻：xwos_sem_thaw()  绑定与解绑选择器 可以将信号量绑定到一个特定的信号选择器上。当对信号量进行V操作时， 可向信号选择器发送一个选择信号。\n 绑定API：xwos_sem_bind() 解绑API：xwos_sem_unbind()  可以参考信号选择器的章节获取更多的信息。\nAPI参考  文档未及时更新时，以头文件xwos/osal/sync/sem.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的信号量\n","excerpt":"XWOS的信号量\n","ref":"/docs/user-manual/sync/sem/","tags":"","title":"信号量"},{"body":"介绍 原生的Lua语言不支持多线程，脚本中的全局变量只能由执行脚本的线程自身访问。 XWLUA在C语言中开发了多线程的功能，每个线程都拥有一个独立的Lua虚拟机。 为了实现多线程共享数据，XWLUA中实现了一个全局导出表(xwxt)，全局导出表中 的数据被所有线程可见。\nxwxt.a = 3 -- 在xwxt中创建Number变量a，并赋值3，xwxt.a可被所有线程看见 xwxt[\"a\"] = 3 -- 与上一句等价 xwxt.f = function () print(\"HI, XWOS\") end -- 在xwxt中创建函数f，xwxt.f可被所有线程访问 xwxt[\"f\"] = function () print(\"HI, XWOS\") end -- 与上一句等价 myfunc = xwxt.f -- 任意线程都可从全局导出表中获取函数f xwxt.f = nil -- 删除xwxt中的函数f 全局导出表的索引(key)只能是字符串。\nLua中的原生数据类型，导出到全局导出表时，会做一次深拷贝，这些数据类型是：\n 数值类型：直接拷贝； 字符串：直接拷贝； 函数：dump()成字符串后拷贝； 布尔类型：直接拷贝； 表：  如果metatable[\"__copy\"]是一个函数，则执行metatable.__copy()函数； 如果metatable[\"__copy\"]为空或不是函数，则依次拷贝表中以及metatable中的 每一个键值对，但若被拷贝的键值对的key不为字符串，就跳过。   userdata：  如果metatable[\"__copy\"]是一个函数，则执行metatable.__copy()函数； 如果metatable[\"__copy\"]为空或不是函数，什么也不做；   lightuserdata：同userdata。  XWLUA API参考 导出  说明：导出操作等价于对表xwxt中的元素的赋值，但索引(key)必须为字符串。  Lua中若索引为字符串，可以使用table.key或table[\"key\"]来表达。\n  用法  xwxt.NAME = object xwxt[\"NAME\"] = object 导入  说明：导入操作等价于访问表xwxt中的元素，但索引(key)必须为字符串。  Lua中若索引为字符串，可以使用table.key或table[\"key\"]来表达。\n  用法  xwxt.NAME = object xwxt[\"NAME\"] = object xwxt.gc()  说明：强制xwxt做一次垃圾回收 用法  xwxt.gc() ","categories":"","description":"XWLUA的全局导出表\n","excerpt":"XWLUA的全局导出表\n","ref":"/docs/lua-manual/xwxt/","tags":"","title":"全局导出表"},{"body":"编译配置 编译newlib时，需要增加配置--enable-newlib-multithread开启多线程的支持，默认是开启的。\n_reent结构体 Newlib中的头文件reent.h中，定义了结构体struct _reent，用于支持多线程：\n 默认情况下，Newlib定义了一个全局的结构体变量impure_data， 此结构体定义在newlib/libc/reent/impure.c，并使用宏_REENT表示它； struct _reent定义了一些C标准的变量，例如errno、stdin、stdout、stderr等； 为了支持多线程访问各自的errno、stdin、stdout和stderr等，需要在 线程对象结构体中增加结构体struct _reent的成员； 由于struct _reent体积过大，玄武OS自己将实现struct _reent； Newlib中除了提供C标准中的函数，还定义带后缀_r版本的函数，例如_read_r()， 其中多一个参数struct _reent *用于区分不同的线程。  ","categories":"","description":"","excerpt":"编译配置 编译newlib时，需要增加配置--enable-newlib-multithread开启多线程的支持，默认是开启的。 …","ref":"/docs/note/newlib/multi-thread/","tags":"","title":"多线程"},{"body":"ubuntu-20.04 基本工具 参考用户手册-构建系统-编译环境设置。\npyocd  用途：为gdb提供调试服务 安装方法  sudo apt install python3 pip3 install pyocd IDE 安装IDE  Eclipse Embedded  安装插件  打开菜单\"Help –\u003e Install New Software…\"； 选择\"Embedded C/C++ v6.x Updates\"，安装工具集：  创建工程 工程模板  GD32F103  仓库：https://gitee.com/xwos/GD32F103RBTmpl.git 命令：    git clone --recursive https://gitee.com/xwos/GD32F103RBTmpl.git  gd32f303  仓库：https://gitee.com/xwos/GD32F303CCTmpl.git 命令：    git clone --recursive https://gitee.com/xwos/GD32F303CCTmpl.git  在已有的仓库中同步代码  git pull git submodule update 工程改名 若需要对工程改名，以GD32F103RBTmpl为例，应该在导入工程前修改以下内容：\n 文件夹名由GD32F103RBTmpl改成新的工程名； 文件brd/cfg/XuanWuOS.h中，将XuanWuOS_CFG_BOARD的定义改成新的工程名； 隐藏文件.cproject中，将所有的GD32F103RBTmpl都替换成新的工程名； 隐藏文件.project中，将所有的GD32F103RBTmpl都替换成新的工程名； 隐藏文件.settings中，将所有文件中的所有的GD32F103RBTmpl都替换成新的工程名；  导入工程 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive\n工程设置 编译设置  菜单：Project –\u003e Properties Debug和Release两个配置都需要增加：  环境变量设置  菜单Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment。 点击Restore Defaults先恢复一次默认设置。 设置：  WKSPC: ../${ConfigName}； ~V: 1； ~D: Debug配置为1，Release配置为0。   Debug和Release两个配置都需要增加。  修改芯片配置 模板中的默认芯片可能与用户的不一样，需要按实际情况进行修改。\n brd/bdl/bdl.mk：根据芯片密度，修改定义。按照官方手册：  GD32F101xx和GD32F103xx的闪存存储器容量16K到128K字节之间的产品称作中密度产品， 需要修改成-DGD32F10X_MD； GD32F101xx和GD32F103xx的闪存存储器容量256K到512K字节之间的产品称作高密度产品， 需要修改成-DGD32F10X_HD； GD32F101xx和GD32F103xx的闪存存储器容量大于512K节的产品称作超高密度产品， 需要修改成-DGD32F10X_XD； GD32F105xx和GD32F107xx微控制器称作互联型产品， 需要修改成-DGD32F10X_CL。   brd/cfg/XuanWuOS.lds：根据芯片的Flash与RAM情况，调整memory的参数：  中断向量表、Image信息块以及代码区加起来不能超过Flash区域； 数据区、中断栈加起来不能超过RAM区域。    MEMORY { flash_mr (rx): org = 0x08000000, len = 128k /* Flash的首地址与大小 */ ocram_mr (rwx): org = 0x20000000, len = 20k /* RAM的首地址与大小 */ /* 中断向量表 */ /* 将加载地址和运行地址配置为相同表示中断向量表不需要从Flash中拷贝到 内存 */ vctbl_lmr (rx): org = 0x08000000, len = 1024 /* 加载地址 */ vctbl_vmr (rw): org = 0x08000000, len = 1024 /* 运行地址 */ /* Image信息块 */ /* XWOS会在bin文件中增加一个数据块，记录Image的基本信息， 这一块信息放在中断向量表 */ image_description_mr (rx): org = 0x08000400, len = 1k /* image description */ /* 代码区 */ /* 所有的可执行代码 */ code_mr (rx): org = 0x08000800, len = 126k /* .xwos.vctbl \u0026 .xwos.init.text \u0026 .xwos.init.rodata \u0026 .xwos.exit.text \u0026 .xwos.exit.rodata \u0026 .xwos.isr.text \u0026 .xwos.text \u0026 .xwos.rodata \u0026 .text \u0026 .rodata */ /* 数据区 */ /* 全局变量、栈、堆 */ data_mr (arw): org = 0x20000000, len = 18k /* .data, .bss \u0026 .heap */ /* 中断栈 */ /* 剩下的内存留给处理器执行中断函数时使用 */ xwos_stk_mr (rw): org = 0x20004800, len = 2k /* xwos stack */ } 编译工程 调试 设置DAPLink仿真器的访问权限 sudo gedit /etc/udev/rules.d/81-daplink.rules 输入下面内容后，保存退出。\nATTRS{idProduct}==\"f001\", ATTRS{idVendor}==\"0d28\", MODE=\"666\" ATTRS{idProduct}==\"f002\", ATTRS{idVendor}==\"0d28\", MODE=\"666\" ATTRS{idProduct}==\"2722\", ATTRS{idVendor}==\"0d28\", MODE=\"666\" ATTRS{idProduct}==\"0204\", ATTRS{idVendor}==\"0d28\", MODE=\"666\" 重启系统或使用下面命令使得配置生效：\nsudo udevadm control --reload 设置pyocd，使用DAPLink调试  Main选择卡：选择工程，设置ELF文件。   Debugger选择卡  需要设置pyocd与arm-none-eabi-gdb两个程序的路径，如果用户 是按照之前的指南安装环境，这两个程序可在系统路径中搜索到； 需要设定复位的方式，若仿真器与目标板之间由Reset连线，可选择Hardware，否则 选择Software(SYSRESETREQ)； 需要通过–pack选项为pyocd指定DFP的路径，DFP可在GD的官网中下载keil5 ADD-ON包找到， 下载后将其放在工程目录内，例如brd/cfg/dbg/GigaDevice.GD32F10x_DFP.2.0.1.pack； 通过–target选项为pyocd指定器件名称，例如：gd32f303cc、gd32f103rb、gd32F103ve等。     Startup选择卡：可设置一个启动断点，通常设置为arch_isr_reset或xwos_main。  重启调试 调试过程若需要复位系统，可以在右键菜单中选择Restart，操作方式如下：\n 按住复位按键； 在右键菜单中选择Restart； 释放复位按键。  增加官方Firmware Library 工程模板中已将官方的Firmware Library以OEM模块的形式集成：\n 模块路径：gd32fmwlib 编译规则：gd32fmwlib/xwmo.mk 编译开关：OEMCFG_gd32fmwlib，定义在brd/cfg/oem.h文件中 OEM模块也是玄武模块的一种  增加用户软件 工程模板中已经有一个名为app的OEM模块，用户可在其中增加自己的C代码，也可仿照 此模块建立其他的OEM模块：\n 模块路径：app 编译规则：app/xwmo.mk 编译开关：OEMCFG_app，定义在brd/cfg/oem.h文件中 OEM模块也是玄武模块的一种  ","categories":"","description":"GD32开发环境搭建指南\n","excerpt":"GD32开发环境搭建指南\n","ref":"/docs/quick-guide/gd32/env/","tags":"","title":"开发环境"},{"body":"ubuntu-20.04 基本工具 参考用户手册-构建系统-编译环境设置。\nIDE  NucleiStudio  创建工程 工程模板  仓库：https://gitee.com/xwos/GD32VF103Tmpl.git 下载：  git clone --recursive https://gitee.com/xwos/GD32VF103Tmpl.git  在已有的仓库中同步代码  git pull git submodule update 工程改名 若需要对工程改名，应该在导入工程前修改以下内容：\n 文件夹名改成新的工程名； 在brd/cfg/XuanWuOS.h文件中，将XuanWuOS_CFG_BOARD的定义改成新的工程名； 在.cproject文件中，搜索GD32VF103Tmpl并全部替换成新的工程名； 在.project文件中，搜索GD32VF103Tmpl并全部替换成新的工程名； 在DebugConfigurations文件夹中，在所有文件中搜索GD32VF103Tmpl并全部替换成新的工程名； 在.settings文件夹中，在所有文件中搜索GD32VF103Tmpl并全部替换成新的工程名。  导入工程  工程需要放在Eclipse的工作目录内（即Eclipse启动时指定的目录） 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive  工程设置 编译设置  菜单Project –\u003e Properties Debug和Release两个配置都需要增加：  环境变量设置  菜单Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment。 点击Restore Defaults先恢复一次默认设置。 设置：  WKSPC: ../${ConfigName}； ~V: 1； ~D: Debug配置为1，Release配置为0。   Debug和Release两个配置都需要增加。  修改芯片配置 模板中的默认芯片可能与用户的不一样，需要按实际情况进行修改。\n brd/bdl/bdl.mk：根据芯片晶振频率，修改宏定义-DHXTAL_VALUE=8000000的值。 brd/cfg/XuanWuOS.lds：根据芯片的Flash与RAM情况，调整memory的参数：  中断向量表、Image信息块以及代码区加起来不能超过Flash区域； 数据区、中断栈加起来不能超过RAM区域。    MEMORY { flash_mr (rx): org = 0x08000000, len = 128k /* internal FLASH */ ocram_mr (rwx): org = 0x20000000, len = 32k /* internal SRAM */ soc_mr (rx): org = 0x08000000, len = 768 /* SOC启动代码 */ evt_lmr (rx): org = 0x08000300, len = 256 /* 异常向量表的加载地址(LMA) */ evt_vmr (rx): org = 0x08000300, len = 256 /* 异常向量表的运行地址(VMA) */ eclic_ivt_lmr (rx): org = 0x08000400, len = 1024 /* 中断向量表的加载地址(LMA) */ eclic_ivt_vmr (rw): org = 0x08000400, len = 1024 /* 中断向量表的运行地址(VMA) */ code_mr (rx): org = 0x08000800, len = 126k /* text \u0026 rodata */ data_mr (arw): org = 0x20000000, len = 30k /* .data, .bss \u0026 .heap */ xwos_stk_mr (rw): org = 0x20007800, len = 2k /* xwos stack */ } 编译工程 调试 使用RV-Debugger调试  Main选择卡：选择工程，设置ELF文件。   Debugger选择卡   Startup选择卡：可设置一个启动断点，通常设置为xwos_main。  重启调试 调试过程若需要复位系统，可以在右键菜单中选择Restart，操作方式如下：\n 1.按住复位按键； 2.在右键菜单中选择Restart； 3.释放复位按键。  增加官方Firmware Library 工程模板中已将官方的Firmware Library以OEM模块的形式集成：\n 模块路径：gd32vfmwlib Makefile：gd32vfmwlib/xwmo.mk 编译开关：OEMCFG_gd32vfmwlib，定义在brd/cfg/oem.h文件中 OEM模块也是玄武模块的一种  增加用户软件 工程模板中已经有一个名为app的OEM模块，用户可在其中增加自己的C代码：\n 模块路径：app Makefile：app/xwmo.mk 编译开关：OEMCFG_app，定义在brd/cfg/oem.h文件中 OEM模块也是玄武模块的一种  ","categories":"","description":"GD32V开发环境搭建指南\n","excerpt":"GD32V开发环境搭建指南\n","ref":"/docs/quick-guide/gd32v/env/","tags":"","title":"开发环境"},{"body":"Windows-10-64bit 基本工具 参考用户手册-构建系统-编译环境设置。\nIDE  S32DS for Arm  创建工程 工程模板  仓库：https://gitee.com/xwos/S32K144Evb.git 下载：  git clone --recursive https://gitee.com/xwos/S32K144Evb.git  在已有的仓库中同步代码  git pull git submodule update 工程改名 若需要对工程改名，应该在导入工程前修改以下内容：\n 文件夹名改成新的工程名； 在brd/cfg/XuanWuOS.h文件中，将XuanWuOS_CFG_BOARD的定义改成新的工程名； 在.cproject文件中，搜索S32K144Evb并全部替换成新的工程名； 在.project文件中，搜索S32K144Evb并全部替换成新的工程名； 在ProcessorExpert.pe文件中搜索S32K144Evb并全部替换成新的工程名； 在Project_Settings/Debugger文件夹中，在所有文件中搜索S32K144Evb并全部替换成新的工程名； 在.settings文件夹中，在所有文件中搜索S32K144Evb并全部替换成新的工程名。  导入工程 打开菜单File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive导入。 导入后，S32DS会重新生成一次源代码，这会使得部分对SDK的修改被覆盖：\n幸好我们使用git管理源码，可使用git命令将这这些文件找回：\ncd s32k144evb git checkout SDK/platform/devices/status.h git checkout SDK/rtos/osif/osif.h 修改的这两个文件可使得玄武OS与S32K的SDK能更好地一起工作，但每次使用S32DS重新生成 代码时，这两个文件都会被覆盖。一劳永逸的方法是将这两个文件覆盖到S32DS的安装目录：\nS32DS的安装目录\\S32DS\\software\\S32SDK_S32K1xx_RTM_3.0.0\\platform\\devices\\status.h S32DS的安装目录\\S32DS\\software\\S32SDK_S32K1xx_RTM_3.0.0\\rtos\\osif\\osif.h 工程设置 编译设置  菜单Project –\u003e Properties Debug和Release两个配置都需要增加：  环境变量设置  菜单Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment。 点击Restore Defaults先恢复一次默认设置。 设置：  WKSPC: ../${ConfigName}； ~V: 1； ~D: Debug配置为1，Release配置为0。   Debug和Release两个配置都需要增加。  环境变量设置  修改Debug和Release两个配置的PATH环境变量。  编译工程 调试 设置JLink调试 重启调试 调试过程可能需要复位系统，可以在右键菜单中选择Restart。\n增加官方SDK 工程模板中已将官方SDK以OEM模块的形式集成：\n 模块路径：brd/bm/s32kbsp Makefile：brd/bm/s32kbsp/xwmo.mk 编译开关：BMCFG_s32kbsp，定义在brd/cfg/oem.h文件中 OEM模块也是玄武模块的一种  增加用户软件 工程模板中已经有一个名为app的OEM模块，用户可在其中增加自己的C代码：\n 模块路径：app Makefile：app/xwmo.mk 编译开关：OEMCFG_app，定义在brd/cfg/oem.h文件中 OEM模块也是玄武模块的一种  ","categories":"","description":"S32K开发环境搭建指南\n","excerpt":"S32K开发环境搭建指南\n","ref":"/docs/quick-guide/s32k/env/","tags":"","title":"开发环境"},{"body":"ubuntu-20.04 基本工具 参考用户手册-构建系统-编译环境设置。\nSTM32CubeIDE  下载STM32CubeIDE-DEB进行安装； 安装过程中，需要接受许可证，许可证比较长，可以按q键跳过。  JRE STM323CubeIDE需要java运行环境，在Ubuntu系统中可以直接安装：\nsudo apt install openjdk-8-jdk 安装OpenOCD插件  打开菜单\"Help –\u003e Install New Software…\"； 点击\"Add…\"，增加下面的仓库；  Name: Eclipse Embedded CDT Plug-ins URL: https://download.eclipse.org/embed-cdt/updates/neon/  等待刷新，选择安装  C/C++ OpenOCD Debugging插件； C/C++ J-Link Debugging插件；    STM32CubeMX  到STM32CubeMX的网站，选择下载STM32CubeMX-Lin 解压后增加执行权限，运行，安装。  Windows-10-64bit 基本工具 参考用户手册-构建系统-编译环境设置。\nSTM32CubeIDE 安装IDE  下载STM32CubeIDE-Win 进行安装；  安装OpenOCD插件  打开菜单\"Help –\u003e Install New Software…\"； 点击\"Add…\"，增加下面的仓库；  Name: Eclipse Embedded CDT Plug-ins URL: https://download.eclipse.org/embed-cdt/updates/neon/  等待刷新，选择安装  C/C++ OpenOCD Debugging插件； C/C++ J-Link Debugging插件；    STM32CubeMX  到STM32CubeMX的网站，选择下载STM32CubeMX-Win 解压后，运行，安装。  ","categories":"","description":"STM32开发环境搭建指南\n","excerpt":"STM32开发环境搭建指南\n","ref":"/docs/quick-guide/stm32/env/","tags":"","title":"开发环境"},{"body":" 玄武操作系统（XWOS）开发于2015年，是一款运行在嵌入式微控制器上的通用实时操作系统， 主要面向可靠、实时、安全的应用领域，包括汽车、物联网、工控等。 目前在车载领域已经量产5年。\n ","categories":"","description":"","excerpt":" 玄武操作系统（XWOS）开发于2015年，是一款运行在嵌入式微控制器上的通用实时操作系统， 主要面向可靠、实时、安全的应用领域，包括汽车、 …","ref":"/docs/","tags":"","title":"文档"},{"body":"介绍 简单内存分配器只分配大小最适应内存块，不对内存进行回收。\n 优点：  简单，代码量非常小； 运行时间稳定。   缺点：内存一旦分配出去不再回收，free()只是一个dummy函数； 适用性：简单的RTOS应用场合或不需要回收内存的场合 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。 说明：此内存管理算法只是为了满足玄武OS的API而提供的默认算法，玄武OS在编译时会自动 计算数据区剩余的内存，将它们全部纳入简单内存分配器的管理范围。  API参考  文档未及时更新时，以头文件xwos/mm/sma.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的简单内存分配器\n","excerpt":"XWOS的简单内存分配器\n","ref":"/docs/user-manual/mm/sma/","tags":"","title":"简单内存分配器"},{"body":"XWLUA API参考 包：xwos.skd xwos.skd.tt()  简介：获取当前CPU调度器的系统滴答时间 返回值：(number)系统时间 示例：  xwos.skd.tt() xwos.skd.tc()  简介：获取当前CPU调度器的系统滴答计数 返回值：(number)滴答计数 示例：  xwos.skd.tc() xwos.skd.ts()  简介：获取当前CPU调度器的系统时间戳 返回值：(number)系统时间 示例：  xwos.skd.ts() 包：xwos.thd xwos.thd.dofile(file)  简介：建立一个新的线程，并在新线程中执行脚本文件 参数file：(string)文件路径 返回值：(userdata)新的线程对象的强引用指针 示例：  childthdsp = xwos.thd.dofile(\"sd:/hw.lua\") childthdsp:stop()  示例输出：  \u003e childthdsp = xwos.thd.dofile(\"sd:/hw.lua\") XWLUA Test Script Thread strong pointer:\t{0x20000880, 63} pi =\t3.1415926535898 2^11 =\t-2.5060358315688e-94 exp(10) =\t22026.465794807 t1 = 5 t1[5] = 5 1\t1 2\t2 3\tfalse 4\t4 5\t5 6\t6 7\t7 c\tc b\tb a\ta \u003e childthdsp:stop() 0\t0 xwos.thd.dostring(str)  简介：建立一个新的线程，并在新线程中执行字符串表示的脚本 参数str：(string)脚本 返回值：(userdata)新的线程对象的强引用指针 示例：  script = [[ mythdsp = xwos.cthd.sp() print(\"Thread strong pointer:\", mythdsp) ]] strthdsp = xwos.thd.dostring(script) strthdsp strthdsp:stop()  示例输出：  script = [[ \u003e\u003e mythdsp = xwos.cthd.sp() \u003e\u003e print(\"Thread strong pointer:\", mythdsp) \u003e\u003e ]] \u003e strthdsp = xwos.thd.dostring(script) \u003e Thread strong pointer:\t{0x20000660, 67} \u003e strthdsp {0x20000660, 67} \u003e strthdsp:stop() 0\t0 xwos.thd.call(func)  简介：建立一个新的线程，并在新线程中执行函数 参数func：(function)Lua函数 返回值：(userdata)新的线程对象的强引用指针 示例：  function childthd_main () mythdsp = xwos.cthd.sp() print(\"Thread strong pointer:\", mythdsp) end cthdsp = xwos.thd.call(childthd_main) cthdsp cthdsp:stop()  示例输出：  \u003e function childthd_main () \u003e\u003e mythdsp = xwos.cthd.sp() \u003e\u003e print(\"Thread strong pointer:\", mythdsp) \u003e\u003e end \u003e cthdsp = xwos.thd.call(childthd_main) \u003e Thread strong pointer:\t{0x20000550, 69} \u003e cthdsp {0x20000550, 69} \u003e cthdsp:stop() 0\t0 包：xwos.cthd xwos.cthd.sp()  简介：返回当前线程的线程对象强指针类对象 返回值：(userdata)当前线程对象的强引用指针 示例：  mythdsp = xwos.cthd.sp() xwos.cthd.sleep(time)  简介：调用此函数的线程睡眠一段时间 参数time：(number, 输入)需要睡眠的时间，单位：纳秒 返回值：(number)错误码  错误码  0：睡眠成功 \u003c0：睡眠失败或中断，返回值为Unix错误码     示例：  rc = xwos.cthd.sleep(1000000000) -- 睡眠1s xwos.cthd.sleepFrom(origin, inc)  简介：调用此函数的线程从一个时间起点睡眠到另一个时间点 参数origin：(number, 输入)时间起点，单位：纳秒 参数inc：(number, 输入)期望被唤醒的时间相对于起点的增量，单位：纳秒 返回值：{(number)错误码, (number)时间起点}  错误码  0：睡眠成功 \u003c0：睡眠失败或中断，返回值为Unix错误码   时间起点：新的时间起点   示例：  origin = xwos.skd.tt() cnt = 3 repeat rc, origin = xwos.cthd.sleepFrom(origin, 1000000000) -- 睡眠1s cnt = cnt - 1 until (cnt == 0) -- 重复3次 xwos.cthd.yield()  简介：通知调度器重新选择线程 示例：  xwos.cthd.yield() xwos.cthd.exit(rc)  简介：调用此函数的线程退出 参数rc：(number, 输入)线程退出时的返回值 示例：  xwos.cthd.exit(0) -- 线程退出时抛出返回值0 xwos.cthd.shldFrz()  简介：判断当前线程是否可被冻结 返回值：(boolean)是否可冻结  true：可被冻结 false：不可被冻结    xwos.cthd.shldStop()  简介：判断当前线程是否可以退出 返回值：(boolean)是否可退出  true：可退出 false：不可退出   示例：  -- Lua 线程循环的写法 repeat shldStop = xwos.cthd.shldStop() threadLoop() until (shldStop) xwos.cthd.frzShldStop()  简介：判断当前线程是否可被冻结，如果是，就冻结线程，之后再判断线程是否可以退出 返回值：{(boolean)是否可退出, (boolean)是否被冻结过}  是否可退出 + true：可退出 + false：不可退出 是否被冻结过 + true：线程被冻结过 + false：线程没有冻结过   示例：  -- Lua 线程循环的写法 repeat shldStop, froze = xwos.cthd.frzShldStop() threadLoop() until (shldStop) xwos.cthd.frz()  简介：冻结当前线程  类：thdsp  说明：线程对象强指针类  thdsp:stop()  简介：终止子线程并等待它的返回值，最后回收子线程资源 参数thdsp：(userdata, 输入)类成员函数的this参数，子线程对象的强引用指针 返回值：{(number)函数的错误码, (number)子线程的返回值}，当函数的错误码为0时， 子线程的返回值才有效 说明：thdsp:stop()等价于thdsp:cancel() + thdsp:join() 示例：  rc, childrc = thdsp:stop() thdsp:cancel()  简介：取消子线程并通知它退出 返回值：(number)函数的错误码 说明：thdsp:cancel()可中断子线程的阻塞态与睡眠态（互斥锁、 信号量等的等待状态），并使得子线程调用xwos.cthd.shldStop()时获得 返回值true 示例：  rc = thdsp:cancel() thdsp:join()  简介：等待线程结束并获取它的返回值，最后回收线程资源 参数thdsp：(userdata, 输入)类成员函数的this参数，子线程对象的强引用指针 返回值：{(number)函数的错误码, (number)子线程的返回值}，当函数的错误码为0时， 子线程的返回值才有效 示例：  rc, childrc = thdsp:join() thdsp:detach()  简介：分离线程 参数thdsp：(userdata, 输入)类成员函数的this参数，子线程对象的强引用指针 说明：  此函数可将线程设置为DETACH态，处于分离态的线程退出后，系统自动回收资源， 不需要父线程join()或stop()。 与DETACH相反的状态是JOINABLE，通过 API xwos.thd.dofile(file)、xwos.thd.dostring(str) 以及xwos.thd.call(func)创建的子线程都是JOINABLE态的。    thdsp:migrate(cpu)  简介：将线程迁移到目标CPU 参数thdsp：(userdata, 输入)类成员函数的this参数，子线程对象的强引用指针 参数cpu：(number, 输入)目标CPU的ID 返回值：(number)函数的错误码  ","categories":"","description":"XWLUA的线程\n","excerpt":"XWLUA的线程\n","ref":"/docs/lua-manual/xwos/thd/","tags":"","title":"线程"},{"body":"XWLUA自旋锁对象 XWLUA自旋锁对象是由XWOS内核的自旋锁（XWOS的自旋锁只是一种数据类型，并不 是对象）与XWOS内核对象组成，Lua虚拟机通过引用计数管理XWLUA自旋锁对象。\n在Lua语言中，通过对象强指针来表示Lua自旋锁对象。\nto-be-closed特性 XWLUA自旋锁对象支持Lua语言的to-be-closed特性，Lua自旋锁能在代码块结束时自动解锁。\nmysplk = xwos.splk.new() function test() local lock\u003cclose\u003e = mysplk lock:lock() -- 临界区 end -- 自动解锁自旋锁 XWLUA API参考 包：xwos.splk xwos.splk.new()  简介：新建一个Lua自旋锁 返回值：(userdata)新的Lua自旋锁对象的强引用指针 示例：  mysplk = xwos.splk.new() 类：splksp  说明：自旋锁对象强指针类  splksp:unlock()  简介：解锁自旋锁 参数splksp：(userdata, 输入)类成员函数的this参数，Lua自旋锁对象的强引用指针  splksp:lock([\"t\"])  简介：锁定自旋锁 参数splksp：(userdata, 输入)类成员函数的this参数，Lua自旋锁对象的强引用指针 可选参数\"t\"：(string, 输入)尝试上锁自旋锁，若自旋锁已开启临界区，立即返回， 不会自旋等待。 返回值：(number)错误码  0：无错误 -EINVAL：参数错误 -EAGAIN：尝试上锁失败，仅当存在可选参数\"t\"时才会出现此错误值    ","categories":"","description":"XWLUA的自旋锁\n","excerpt":"XWLUA的自旋锁\n","ref":"/docs/lua-manual/xwos/lock/spinlock/","tags":"","title":"自旋锁"},{"body":"介绍 自旋锁是多核系统中为防止多个处理器同时访问临界区而引入的一种锁。 当一个CPU获得自旋锁并访问临界区时，其他CPU只能“自旋”等待锁。 所谓“自旋”，是指不断循环测试锁的是否可用。\n自旋锁内的操作是不可被打断的。因此，自旋锁还伴随其他操作， 例如关闭调度器的抢占，关闭中断底半部，关闭中断等。 在单核(UP)系统中，只有一个CPU，不需要自旋过程，单核系统为了软件接口与多核系统兼容， 也会实现自旋锁，这种自旋锁只需关闭抢占、中断底半部或中断。\n自旋锁的初始化 自旋锁是基于原子操作指令实现的，自旋锁结构体的核心数据是一个CPU指令能操作的 基本数据类型（8位、16位、32位、64位），因此不需要提供动态创建和删除方法。\nvoid xwos_splk_init(struct xwos_splk * spl); 临界区 自旋锁不同后缀的API安全性不一样：\n 临界区只对线程上下文是安全的：  { xwos_splk_lock(\u0026lock); /* 临界区 */ xwos_splk_unlock(\u0026lock); }  临界区对线程、中断、中断底半部上下文都是安全的：  { xwos_splk_lock_cpuirq(\u0026lock); /* 临界区 */ xwos_splk_unlock_cpuirq(\u0026lock); }  临界区里面还有子临界区，对线程、中断、中断底半部上下文都是安全的：  { xwos_splk_lock_cpuirqsv(\u0026lock1, \u0026cpuirq1); /* 临界区1 */ xwos_splk_lock_cpuirqsv(\u0026lock2, \u0026cpuirq2); /* 临界区2 */ xwos_splk_unlock_cpuirqrs(\u0026loc2, cpuirq2); /* 临界区1 */ xwos_splk_unlock_cpuirqrs(\u0026loc1, cpuirq1); }  临界区对线程上下文、特定的外设中断是安全的：  { xwos_splk_lock_irqs(\u0026lock, irq_array, num); /* 临界区 */ xwos_splk_unlock_irqs(\u0026lock, irq_array, num); }  临界区内有子临界区，对线程上下文、特定的外设中断是安全的：  { xwos_splk_lock_irqssv(\u0026lock1, irq_array, flag1_array, num); /* 临界区1 */ xwos_splk_lock_irqssv(\u0026lock2, irq_array, flag2_array, num); /* 临界区2 */ xwos_splk_unlock_irqsrs(\u0026lock2, irq_array, flag2_array, num); /* 临界区1 */ xwos_splk_unlock_irqsrs(\u0026lock1, irq_array, flag1_array, num); }  临界区对线程上下文、中断底半部是安全的：  /* 自旋等待 */ { xwos_splk_lock_bh(\u0026lock); /* 临界区 */ xwos_splk_unlock_bh(\u0026lock); } API参考  文档未及时更新时，以头文件xwos/osal/lock/spinlock.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的自旋锁\n","excerpt":"XWOS的自旋锁\n","ref":"/docs/user-manual/lock/spinlock/","tags":"","title":"自旋锁"},{"body":"XWOS在设计时就充分考虑了代码的复用性、移植性以及与第三方软件的兼容性， 代码被架构成多层结构：构建系统、BSP、操作系统内核、中间件和应用。\nXWOS架构图 Photo: xwos.tech / CC-BY\n  构建系统  xwbs: 构建系统  BSP  xwcd: 编译器、CPU、SOC、外设驱动相关的代码  xwcd/ds: 玄武设备栈，XWOS的驱动框架 xwcd/perpheral: 基于玄武设备栈，实现的各种外设驱动，代码可被不同SOC共享 xwcd/soc: 不同SOC的XWOS移植实现层的代码   xwbd: 不同电路板的工程配置、调试脚本、链接脚本、驱动与应用  操作系统内核  xwos: 内核  xwos/osal: 操作系统抽象层，统一的内核API，不区分操作系统的具体实现 xwos/ospl: 操作系统移植层，其中定义了内核提供给BSP的回调函数以及BSP提供给内核的接口 xwos/lib: 基本C函数库，包括原子操作库、位操作库、数据结构等 xwos/mm: 内存管理 xwos/mp: 多核(mp)内核 xwos/up: 单核(up)内核    中间件  xwmd: 中间件  xwmd/isc: 系统间的通讯机制  xwmd/isc/xwcq: 线程间的循环队列 xwmd/isc/xwmq: 线程间的消息队列 xwmd/isc/pcp: SOC与SOC间的点对点通讯协议 xwmd/isc/scp: SOC与SOC间的点对点通讯协议简化版   xwmd/libc: 标准C库的适配代码   xwem: 第三方开源软件  xwem/fs: 各种开源的文件系统 xwem/serializing: 序列化与反序列化  xwem/serializing/nanopb: protocol-buffer   xwem/vm: 虚拟机  xwem/vm/lua: Lua语言虚拟机      应用  xwam: 参考代码以及应用代码  ","categories":"","description":"XWOS的目录结构\n","excerpt":"XWOS的目录结构\n","ref":"/docs/user-manual/architecture/","tags":"","title":"软件架构"},{"body":"XWOS内核是使用纯C语言开发的，不依赖C++的标准库。 用户可在线程中使用C++语言以及C++标准库，C++标准库由编译器提供，不完全功能清单如下：\n g++, libstdc++, libsupc++  new, delete, new[], delete[], placement new, aligned new (C++17) 容器  array vector deque map, multimap, unordered_map, unordered_multimap set, multiset, unordered_set, unordered_multiset list, forward_list stack, queue, priority_queue   I/O stream string atomic RTTI exception unwind chrono thread mutex condition_variable   llvm(clang++), libc++, libc++abi  new, delete, new[], delete[], placement new, aligned new (C++17) 容器  array vector deque map, multimap, unordered_map, unordered_multimap set, multiset, unordered_set, unordered_multiset list, forward_list stack, queue, priority_queue   I/O stream string atomic RTTI exception unwind chrono thread mutex condition_variable    ","categories":"","description":"C++ STL\n","excerpt":"C++ STL\n","ref":"/docs/user-manual/c-c++/c++/","tags":"","title":"C++"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/quick-guide/gd32/","tags":"","title":"GD32"},{"body":"XWLUA API参考 包：xwds.gpio xwds.gpio.req(soc, port, pinmsk)  简介：申请GPIO 参数soc：(userdata, 输入)BSP中注册的SOC 参数port：(number, 输入)GPIO端口 参数pinmsk：(number, 输入)GPIO引脚的掩码 返回值：(number)错误码  0：无错误 -ERANGE: GPIO PORT错误 -EBUSY: GPIO PIN已被使用   示例：  -- GPIOA, PIN0 | PIN1 rc = xwds.gpio.req(stm32, 0, 1 | 2) xwds.gpio.rls(soc, port, pinmsk)  简介：释放GPIO 参数soc：(userdata, 输入)BSP中注册的SOC 参数port：(number, 输入)GPIO端口 参数pinmsk：(number, 输入)GPIO引脚的掩码 返回值：(number)错误码  0：无错误 -ERANGE: GPIO PORT错误 -EBUSY: GPIO PIN已被使用   示例：  -- GPIOA, PIN1 | PIN2 rc = xwds.gpio.rls(stm32, 0, 2 | 4) xwds.gpio.set(soc, port, pinmsk)  简介：将GPIO的PIN置为高电平 参数soc：(userdata, 输入)BSP中注册的SOC 参数port：(number, 输入)GPIO端口 参数pinmsk：(number, 输入)GPIO引脚的掩码 返回值：(number)错误码  0：无错误 -ERANGE: GPIO PORT错误 -EBUSY: GPIO PIN已被使用   示例：  -- GPIOB, PIN2 | PIN4 rc = xwds.gpio.set(stm32, 1, 4 | 0x10) xwds.gpio.reset(soc, port, pinmsk)  简介：将GPIO的PIN置为低电平 参数soc：(userdata, 输入)BSP中注册的SOC 参数port：(number, 输入)GPIO端口 参数pinmsk：(number, 输入)GPIO引脚的掩码 返回值：(number)错误码  0：无错误 -ERANGE: GPIO PORT错误 -EBUSY: GPIO PIN已被使用   示例：  -- GPIOC, PIN2 | PIN3 rc = xwds.gpio.reset(stm32, 2, 0x4 | 0x8) xwds.gpio.toggle(soc, port, pinmsk)  简介：翻转GPIO电平 参数soc：(userdata, 输入)BSP中注册的SOC 参数port：(number, 输入)GPIO端口 参数pinmsk：(number, 输入)GPIO引脚的掩码 返回值：(number)错误码  0：无错误 -ERANGE: GPIO PORT错误 -EBUSY: GPIO PIN已被使用   示例：  -- GPIOD, PIN0 | PIN1 rc = xwds.gpio.toggle(stm32, 3, 3) xwds.gpio.output(soc, port, pinmsk, out)  简介：同时输出多个GPIO引脚 参数soc：(userdata, 输入)BSP中注册的SOC 参数port：(number, 输入)GPIO端口 参数pinmsk：(number, 输入)GPIO引脚的掩码 参数out：(number, 输入)输出值 返回值：(number)错误码  0：无错误 -ERANGE: GPIO PORT错误 -EBUSY: GPIO PIN已被使用   示例：  -- 输出GPIOE，掩码0xFFFFFFFF，输出值0x3 rc = xwds.gpio.output(stm32, 4, 0xFFFFFFFF, 0x3) xwds.gpio.input(soc, port, pinmsk)  简介：同时从GPIO端口读取多个引脚的输入值 参数soc：(userdata, 输入)BSP中注册的SOC 参数port：(number, 输入)GPIO端口 参数pinmsk：(number, 输入)GPIO引脚的掩码 返回值：{(number)错误码, (number)输入值}  错误码  0：无错误 -ERANGE: GPIO PORT错误 -EBUSY: GPIO PIN已被使用     示例：  -- 读取GPIOF，掩码0xFFFFFFFF rc, in = xwds.gpio.output(stm32, 5, 0xFFFFFFFF) ","categories":"","description":"XWLUA的GPIO库\n","excerpt":"XWLUA的GPIO库\n","ref":"/docs/lua-manual/xwds/gpio/","tags":"","title":"GPIO"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/note/newlib/","tags":"","title":"newlib笔记"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/note/soc/risc-v/","tags":"","title":"RISC-V移植说明"},{"body":"对象强指针 XWLUA使用对象强指针管理XWOS内核库中的对象（线程、信号量、条件量、事件标志、 信号选择器、线程栅栏、互斥锁、自旋锁、顺序锁），在Lua语言中对象强指针是一种userdata。 对象强指针就是对XWOS中的对象描述符的封装。\nLua虚拟机（一个独立的线程）每强引用一个对象强指针，都会增加相关联线程的引用计数， Lua虚拟机（一个独立的线程）每解引用一个对象强指针，都会减少相关联线程的引用计数。 当所有Lua虚拟机都不再持有对象的强指针，对象就会被回收并释放内存。\n强指针的概念源于Lua语言的强引用，Lua语言中，被符号命名的userdata，就表示持有userdata的强引用。\n","categories":"","description":"XWOS内核的binding库\n","excerpt":"XWOS内核的binding库\n","ref":"/docs/lua-manual/xwos/","tags":"","title":"XWOS内核库"},{"body":"介绍 内存切片分配器将内存切割成等量的块，就像“卡片”一样，然后将它们连接在一起形成队列， 每次分配时取一块内存，回收时再把内存切片放回到队列中。\n 优点：  简单，代码量较小； 支持释放操作； 申请与释放操作的运行时间是稳定的； 反复申请与释放不会造成内存碎片。   缺点：  内存块大小固定，如果要求的内存过小，会造成内存浪费； 如果要求的内存超过内存块的大小，无法满足需求； 连续申请的两块内存不能保证是连续的。   适用性：对时间稳定性要求高的RTOS应用场合。 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。  API参考  文档未及时更新时，以头文件xwos/mm/memslice.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的内存切片分配器\n","excerpt":"XWOS的内存切片分配器\n","ref":"/docs/user-manual/mm/memslice/","tags":"","title":"内存切片分配器"},{"body":"分支  main*: 主分支，所有新增的提交都优先合并到主分支； 版本号分支: 稳定版本与里程碑版本的分支，用于发布版本。  版本号 版本号形式：Major.minor.revision (M.m.r)  Major: 大版本号  里程碑版本   minor: 小版本号  稳定版本   revision: 修订号  稳定版分支的问题的修复    版本变化规则  Major在以下情况下增加1：  里程碑版本发布。   minor：  发布一个新的稳定版本； Major+1后，minor回到0。   revision：  修复了稳定版分支中的问题后，revision增加1； minor+1后，revision回到0； Major+1后，revision回到0。    ","categories":"","description":"XWOS的分支与版本号规范\n","excerpt":"XWOS的分支与版本号规范\n","ref":"/docs/criterion/version-branch/","tags":"","title":"分支与版本号规范"},{"body":"说明  XWOS不使用Newlib提供的动态内存管理的算法。使用的是内存池算法：  移植方法  重写Newlib的函数：  void * _malloc_r(struct _reent * r, size_t n); void * _realloc_r(struct _reent * r, void * p, size_t n); void * _calloc_r(struct _reent * r, size_t elem_nr, size_t elem_sz); void * _memalign_r(struct _reent * r, size_t alignment, size_t n); void * _valloc_r(struct _reent * r, size_t n); void * _pvalloc_r(struct _reent * r, size_t n); void _free_r(struct _reent * r, void * p);  源码路径：xwmd/libc/newlibac/mem.c  ","categories":"","description":"","excerpt":"说明  XWOS不使用Newlib提供的动态内存管理的算法。使用的是内存池算法：  移植方法  重写Newlib的函数：  void * …","ref":"/docs/note/newlib/mm/","tags":"","title":"动态内存管理"},{"body":"原子操作 XWOS提供了原子操作模板库，基本类型中定义的 各种非函数指针类型都可使用原子操作。原子操作函数模板包括：\n 读  xwaop_load()：加载  可以指定C11中6种内存序   xwaop_read()：读  内存序：acquire     写  xwaop_store()：存储  可以指定C11中6种内存序   xwaop_write()：写  内存序：release     读-改-写  基本运算  xwaop_add()：加 xwaop_sub()：减 xwaop_rsb()：反向减法 内存序：acq_rel   位运算  xwaop_and()：与 xwaop_or()：或 xwaop_xor()：异或 内存序：acq_rel   位操作  xwaop_s1m()：将数据掩码部分的位全部置1 xwaop_c0m()：将数据掩码部分的位全部清0 xwaop_x1m()：将数据掩码部分的位全部翻转 内存序：acq_rel     读-测试-改-写  所有名称匹配正则表达式xwaop_t.+_then_.+的函数  分为两种情况  测试成功，继续执行“改-写”操作，此时内存序为acq_rel 测试失败，相当于读操作，此时内存序为consume        所有原子操作函数的第一个参数均为基本类型，第二个参数 是原子数据的指针，例如：\nxwer_t rc; xwsq_a refcnt = v; xwsq_t nv, ov; /* * 测试refcnt是否为0： * + ture: refcnt增加1，nv返回refcnt增加以后的新值，ov返回refcnt增加以前的旧值， * 内存序：acq_rel，rc为返回值XWOK； * + false: nv与ov都返回refcnt的值，内存序：consume，rc为返回值-EACCES； */ rc = xwaop_teq_then_add(xwsq_t, \u0026refcnt, 0, 1, \u0026nv, \u0026ov); 位图原子操作 位图（xwbmp_t数组）与可进行原子操作，XWOS提供了基本函数库：\n 声明  xwbmpaop_declare()：声明原子位图   读  xwbmpaop_t1i()：测试位图中的某位是否被置1 内存序：consume   写  xwbmpaop_s1all()：将位图所有位置1 xwbmpaop_c0all()：将位图所有位清0 内存序：acq_rel   读-改-写  xwbmpaop_s1i()：将位图中某位置1 xwbmpaop_c1i()：将位图中某位清0 xwbmpaop_x1i()：将位图中某位翻转 内存序：acq_rel   读-测试-改-写  所有名字匹配正则表达式xwbmpaop_.+_then_.+的函数  xwbmpaop_t0i_then_s1i()：测试位图中某位是否为0，如果是，就将它置1 xwbmpaop_t1i_then_c0i()：测试位图中某位是否为1，如果是，就将它清0 xwbmpaop_fls_then_c0i()：从最高位起查找位图中第一个为1的位并将它清0 xwbmpaop_flz_then_s1i()：从最高位起查找位图中第一个为0的位并将它置1 xwbmpaop_ffs_then_c0i()：从最低位起查找位图中第一个为1的位并将它清0 xwbmpaop_ffz_then_s1i()：从最低位起查找位图中第一个为0的位并将它置1 分为两种情况  测试成功，继续执行“改-写”操作，此时内存序为acq_rel 测试失败，相当于读操作，此时内存序为consume        API参考  原子操作：文档未及时更新时，以头文件xwos/lib/xwaop.h中注释为准； 位图原子操作：文档未及时更新时，以头文件xwos/lib/xwbmpaop.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的原子操作库\n","excerpt":"XWOS的原子操作库\n","ref":"/docs/user-manual/xwlib/xwaop/","tags":"","title":"原子操作库"},{"body":"介绍  MCU: STM32F429BIT6 SDRAM: 16MiB 更多介绍: 淘宝店铺介绍 电路板目录： xwbd/FK429M1  开发环境  编译集成环境可参考：开发环境搭建指南  源码  仓库：https://gitee.com/xwos/FK429M1.git 下载：  git clone --recursive https://gitee.com/xwos/FK429M1.git  在已有的仓库中同步代码：  git pull git submodule update 导入工程到STM32CubeIDE 工程需放在STM32CubeIDE的工作目录内（即STM32CubeIDE启动时指定的目录），\n 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive  设置编译环境  打开菜单**“Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment”**； 点击**“Restore Defaults”**； 修改Debug配置的环境变量：  WKSPC:../../../${ConfigName} ~D:1 ~V:1     修改Release配置的环境变量：  WKSPC:../../../${ConfigName} ~D:0 ~V:1    环境变量PATH设置  修改Debug和Release两个配置的PATH环境变量  将STM32CubeIDE自带的工具链路径从PATH环境变量中删除； 将XWMCU工具链的路径放置到PATH环境变量中。    STM32CubeMX配置工程  STM32CubeMX配置文件：xwbd/FK429M1/bm/stm32cube/cubemx/FK429M1.ioc XWOS对中断优先级的要求：  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  NVIC设置  设置3个抢占优先级位和1个子优先级位 SVC中断设置成最高优先级，即Preemption Priority为0； PendSV中断设置成最低优先级，即Preemption Priority为7； Systick中断设置成最低优先级，即Preemption Priority为7； 系统Fault的优先级设置为0； 其他中断的优先级只可在1~6之间。    编译 调试 打开菜单Run –\u003e Debug Configurations…，根据仿真器类型，选择调试配置：\n FK429M1-openocd-daplink：gdb + openocd + DAPLink调试器 FK429M1-openocd-jlink：gdb + openocd + JLink调试器  调试步骤  准备一张SD卡，格式化为FAT32文件系统； 将文件夹xwem/vm/lua/test/内的lua脚本，拷贝到SD卡内； 将SD卡插入开发板； 使用MiniUSB线连接电路板上的USB-232接口与PC； 打开终端工具（windows可选putty、SecretCRT，Linux可选gtkterm、picocom、minicom）, 但先不要在终端工具中打开串口，否则MCU会进入下载模式； 上电，并在STM32CubeIDE中启动调试，等待MCU运行到初始断点； 在终端工具中打开串口，参数：1M波特率/8位数据/1位停止位/无奇偶校验； 开始单步调试或连续运行调试。  调试技巧 关闭DCache ARMv7-m4内核的MCU带有写缓冲区，常常会对定位程序BUG带来困扰，可以在调试时关闭。 将下面的宏开关注释掉或定义改为1后可关闭写缓冲区：\n/* xwbd/FK429M1/bm/stm32cube/cfg.h */ #define STM32CUBECFG_DISDEFWBUF 0 运行过程  程序入口：xwbd/FK429M1/bm/main/main.c 启动流程：  xwos_main()创建一个主线程main_task()； main_task()依次调用各个玄武模块的xxx_start()函数完成对各个模块加载； 开始并行执行各个模块中创建的线程；    示例 XWOS中有多个示例可帮助用户快速了解API的用法：\n 线程  创建线程：xwam/example/thread/create 线程睡眠：xwam/example/thread/sleep   定时器：xwam/example/timer 同步  信号量：xwam/example/sync/sem 条件量：xwam/example/sync/cond 事件标志：xwam/example/sync/flg 线程栅栏：xwam/example/sync/br 信号选择器：xwam/example/sync/sel   锁  中断管理：xwam/example/lock/cpuirq 自旋锁：xwam/example/lock/spinlock 顺序锁：xwam/example/lock/seqlock 互斥锁：xwam/example/lock/mtx   内存管理  简单内存分配器：xwam/example/mm/sma 内存切片分配器：xwam/example/mm/memslice 伙伴算法分配器：xwam/example/mm/bma 内存池：只用于比较大的内存区域的管理，例如外接的SDRAM， FK429M1工程已经为板载的SDRAM建立了内存池。   玄武C库  CRC：xwam/example/xwlib/crc    每个示例中都有一个启动函数xxx_start()，可在xwbd/FK429M1/bm/main/main.c文件中 的主线程main_task()启动示例，但最好一次只启动一个示例，避免日志冲突。\n实验过程中最好将Lua虚拟机关闭，防止竞争串口导致输出混乱。方法是将 配置文件xwbd/FK429M1/cfg/xwem.h中的配置XWEMCFG_vm_lua改为0。\n系统集成的原理  所有移植的第三方组件、驱动包、示例代码等都是以玄武模块独立编译成静态库**.a**， 之后再将它们链接成**ELF**文件，再由**ELF**生成**bin**、**hex**和**smot**文件。 每个玄武模块都是一个独立的子工程并进行独立编译，设计上借鉴了安卓系统的Android.mk：  每个玄武模块中都有一个xwmo.mk文件，其中定义的编译参数、头文件路径等 只对当前的玄武模块生效； 每个玄武模块都是一个封闭的包，外部一般不能直接引用内部头文件，需要封装对外可见的 类型以及接口函数，并统一放在专门的API头文件中； API头文件通常以mif.h作为文件名，含义是模块接口(Module InterFace)。   XWOS内已经包含了大量玄武模块：  xwcd：外设芯片的驱动； xwam：示例与应用； xwmd：中间件； xwem：第三方开源软件。   玄武模块的具体信息可以参考用户手册-构建系统-玄武模块。  代码启动流程  stm32cube_lowlevel_init()：初始化时钟 stm32cube_init()：初始化内存管理、cache、GPIO、DMA等基础设备 main_task()：初始化其他设备、启动其他子线程  功能 BSP  STM32Cube模块：xwbd/FK429M1/bm/stm32cube STM32CubeMX配置文件：xwbd/FK429M1/bm/stm32cube/cubemx/FK429M1.ioc STM32CubeMX生成源码目录：xwbd/FK429M1/bm/stm32cube/cubemx STM32Cube适配XWOS的源码：xwbd/FK429M1/bm/stm32cube/xwac 中断向量表：xwbd/FK429M1/bm/stm32cube/cubemx/IVT  中断向量表是使用命令自动生成的 命令：xwbs/util/el/stm32ivt/stm32ivt.el xwbd/FK429M1/bm/stm32cube   终端UART  设备：USART1 参数：1M波特率/8位数据/1位停止位/无奇偶校验 驱动  驱动框架 —— 设备栈：xwmd/ds/uart/dma.c 设备栈驱动：xwbd/FK429M1/bm/stm32cube/xwac/xwds/uart.c HAL库驱动：xwbd/FK429M1/bm/stm32cube/cubemx/Core/Src/usart.c 注意：HAL库中的驱动存在BUG，XWOS中所提供的代码已修复     SDRAM  映射地址：0xD0000000 大小：16MiB 驱动：xwbd/FK429M1/bm/stm32cube/cubemx/Core/Src/fmc.c 内存池  头文件  xwbd/FK429M1/bm/stm32cube/mif.h xwos/mm/mempool/allocator.h   内存池对象：sdram_mempool      Lua  版本：5.4 源码：xwem/vm/lua 适配代码：xwbd/FK429M1/bm/stm32cube/xwac/lua 已注册的驱动库：xwbd/FK429M1/bm/luamod/ds.c  SOC: stm32   REPL 运行sd卡中的脚本  FATFS  版本：0.14 源码：xwem/filesystem/fatfs 适配代码：xwbd/FK429M1/bm/stm32cube/xwac/fatfs 文件系统：路径以\"sd:/\"开始 SD卡  驱动：xwbd/FK429M1/bm/stm32cube/cubemx/Core/Src/sdmmc.c    libc  适配代码：xwbd/FK429M1/bm/stm32cube/xwac/newlib 标准输入、输出/错误：重定向至USART1 文件系统：位于SD卡内，从路径sd:/开始 动态内存管理：由SDRAM的内存池提供  电源管理  适配代码：xwbd/FK429M1/bm/stm32cube/xwac/xwds/pm.c  ","categories":"","description":"","excerpt":"介绍  MCU: STM32F429BIT6 SDRAM: 16MiB 更多介绍: 淘宝店铺介绍 电路板目录： xwbd/FK429M1   …","ref":"/docs/quick-guide/stm32/fk429m1/","tags":"","title":"反客Stm32F429核心板"},{"body":"基本类型 XWOS的所有基本类型定义如下：\n xwu8_t 8位无符号整数 xws8_t 8位有符号整数 xwu16_t 16位无符号整数 xws16_t 16位有符号整数 xwu32_t 32位无符号整数 xws32_t 32位有符号整数 xwu64_t 64位无符号整数 xws64_t 64位有符号整数 xwsz_t 大小值（无符号） xwssz_t 大小值（有符号） xwstk_t 栈帧（无符号），必须与指针位宽一致 xwptr_t 指针的整数值（无符号），必须与指针位宽一致 xwreg_t 寄存器（无符号），必须与指针位宽一致 xwsreg_t 寄存器（有符号），必须与指针位宽一致 xwer_t 错误码（有符号），通常为负数 xwsq_t 序列值/位置/偏移（无符号），必须与指针位宽一致 xwssq_t 序列值/位置/偏移（有符号），必须与指针位宽一致 xwsid_t ID（有符号），必须与指针位宽一致 xwid_t ID（无符号），必须与指针位宽一致 typedef void (* xwisr_f)(void) 中断向量（函数指针） xwirq_t 中断号（有符号），负的中断号表示系统异常，正的中断号表示外部中断 xwpr_t 优先级（有符号） xwbmp_t 位图（无符号） xwtm_t 时间（64位有符号整数，单位：纳秒） xwlfq_t 无锁队列 typedef void (* ctor_f)(void * /*obj*/) 构造函数 typedef void (* dtor_f)(void * /*obj*/) 析构函数 typedef xws64_t (* xwsc_f)(void * /*arg*/, ...) 系统调用  原子类型 类型后缀_t换成_a表示此类型的原子类型。 例如：__xwcc_atomic xwsq_t等价于xwsq_a。\n系统位数 XWOS内核支持32位与64位两种CPU。\n时间 XWOS内核使用64位有符号整数xwtm_t表示时间，单位为纳秒。\n对象 XWOS的对象全部继承于struct xwos_object，定义在xwos/lib/object.h，XWOS的对象 使用引用计数法管理生命周期。\n对象描述符 当XWOS的对象初始化时，会为其分配一个唯一的标签，对象的指针和标签组合在一起 被称为对象描述符。\n对象描述符是用来解决ABA问题的。因为动态内存算法的原因，当一个对象被销毁释放，然后再重新 申请对象，旧对象和新对象的内存地址很有可能是一样的，指针并不能作为对象的唯一性代表， 还有可能产生野指针的问题。\n解决的方法是为对象分配一个唯一的标签，每次访问对象前，先检查数值是否匹配，由此可确定 对象是否有效。\n对象描述符主要是为高级语言的**垃圾回收(GC, Garbage Collection)**准备的。现代的高级语言 几乎都具备GC特性，用户不需再像C/C++语言那样，申请和释放必须成对出现。例如在Lua语言中， 用户只管申请使用对象，不用关心对象的释放问题，虚拟机的GC机制会自动管理对象的生命周期。\n","categories":"","description":"XWOS的基本类型、约束\n","excerpt":"XWOS的基本类型、约束\n","ref":"/docs/user-manual/basic-promise/","tags":"","title":"基本约束"},{"body":"XWLUA API参考 包：xwos.cond xwos.cond.new()  简介：新建一个条件量 返回值：(userdata)新的条件量对象的强引用指针 示例：  mycond = xwos.cond.new() 类：condsp  说明：条件量对象强指针类  condsp:bind(sel)  简介：绑定条件量对象到信号选择器 参数condsp：(userdata, 输入)类成员函数的this参数，条件量对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ECHRNG: 位置超出范围 -EALREADY: 同步对象已经绑定到事件对象 -EBUSY: 通道已经被其他同步对象独占    condsp:unbind(sel)  简介：从信号选择器上解绑条件量对象 参数condsp：(userdata, 输入)类成员函数的this参数，条件量对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    condsp:freeze()  简介：解冻条件量 参数condsp：(userdata, 输入)类成员函数的this参数，条件量对象的强引用指针 返回值：(number)错误码  0：成功 -EALREADY：条件量已被冻结    condsp:thaw()  简介：解冻条件量 参数condsp：(userdata, 输入)类成员函数的this参数，条件量对象的强引用指针 返回值：(number)错误码  0：成功 -EALREADY：条件量未被冻结    condsp:unicast()  简介：单播条件量对象，只会唤醒第一个线程 参数condsp：(userdata, 输入)类成员函数的this参数，条件量对象的强引用指针 返回值：(number)错误码  0：成功 -ENEGATIVE：条件量已被冻结    condsp:broadcast()  简介：广播条件量对象，等待队列中的所有线程都会被唤醒 参数condsp：(userdata, 输入)类成员函数的this参数，条件量对象的强引用指针 返回值：(number)错误码  0：成功 -ENEGATIVE：条件量已被冻结    condsp:wait(lock, time)  简介：等待并获取条件量 参数condsp：(userdata, 输入)类成员函数的this参数，条件量对象的强引用指针 参数lock：(userdata, 输入)锁对象的强引用指针，可以是  spinlock seqlock mutex   可选参数time：(number, 输入)期望的等待时间，超时后返回错误码-ETIMEDOUT。 返回值：(number)错误码  0：无错误 -EINVAL：参数错误 -ETIMEDOUT：超时 -EINTR：等待被中断 -ENOTINTHD：不在线程上下文中    ","categories":"","description":"XWLUA的条件量\n","excerpt":"XWLUA的条件量\n","ref":"/docs/lua-manual/xwos/sync/cond/","tags":"","title":"条件量"},{"body":"介绍 条件量常用于多个线程间同步数据。XWOS提供的条件量与大部分系统/语言提供的条件量功能类似， 例如：\n POSIX的pthread_cond_t C++的std::condition_variable Java的java.util.concurrent.locks.Condition Python的threading.Condition  XWOS的条件量还可以用于中断与线程间同步数据。主要包括两个动作：\n 线程A等待条件量的**“条件”**成立而阻塞； 另一个线程B或中断使**“条件”**成立。为了防止两个上下文竞争**“条件”**， 条件量需要和一个**锁**一起使用，锁用于保护**“条件”**不被同时访问。 XWOS的条件量支持很多种类型的锁：  互斥锁：只可用于线程间同步**“条件”** 自旋锁 顺序锁 自定义的加锁与解锁函数    条件量的创建、初始化与删除、销毁 条件量支持静态初始化与销毁，动态创建与删除两种方式：\n  静态初始化与销毁\n 静态是指用户预先定义对象，这些对象在编译时由编译器分配内存。 初始化：xwos_cond_init() 销毁：xwos_cond_fini()    动态创建与删除\n 动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。 创建：xwos_cond_create() 删除：xwos_cond_delete()    等待条件量 XWOS提供2个API等待条件量：\nxwer_t xwos_cond_wait(struct xwos_cond * condid, union xwlk_ulock lock, xwsq_t lktype, void * lkdata, xwsq_t * lkst); xwer_t xwos_cond_timedwait(struct xwos_cond * condid, union xwlk_ulock lock, xwsq_t lktype, void * lkdata, xwtm_t * xwtm, xwsq_t * lkst);  只可在线程上下文中使用； 线程会阻塞等待条件量的单播或广播事件； xwos_cond_timedwait()还会设定一个超时时间，超时后线程被唤醒，并返回错误码-ETIMEDOUT； 超时的参数xwtm_t * xwtm用法可以参考超时API的统一形式； 线程的阻塞状态可被中断，中断将返回-EINTR； 所有锁统一使用union xwlk_ulock指代，此联合中包含所有锁的定义， 实际只是一个指针，具体意义由xwsq_t lktype决定：  XWOS_LK_MTX 互斥锁  lock代表互斥锁（访问方式：lock.osal.mtx）， lockdata无作用，设置为NULL即可；   XWOS_LK_MTX_UNINTR 不可中断的互斥锁  lock代表互斥锁（访问方式：lock.osal.mtx）， lockdata无作用，设置为NULL即可；   XWOS_LK_SPLK 自旋锁  lock代表自旋锁的指针（访问方式：lock.osal.splk）； lockdata无作用，设置为NULL即可；   XWOS_LK_SQLK_WR 顺序写锁  lock代表顺序锁的指针（访问方式：lock.osal.sqlk）； lockdata无作用，设置为NULL即可；   XWOS_LK_SQLK_RDEX 顺序读锁  lock代表顺序锁的指针（访问方式：lock.osal.sqlk）； lockdata无作用，设置为NULL即可；   XWOS_LK_CALLBACK 自定义的加锁与解锁函数  lock代表指向struct xwlk_cblk的指针（访问方式：lock.cb）； lockdata传递给struct xwlk_cblk中的lock与unlock函数的参数；     lkst指向输出缓冲区，此缓冲区可返回锁的状态：  XWOS_LKST_LOCKED函数返回时，已经上锁； XWOS_LKST_UNLOCKED函数返回时，未上锁。     !!!特别注意!!!\n  当使用了带中断管理的上锁函数时，例如：\n xwos_splk_lock_cpuirq() xwos_splk_lock_cpuirqsv() xwos_splk_lock_irqs() xwos_sqlk_wr_lock_cpuirq() xwos_sqlk_wr_lock_cpuirqsv() xwos_sqlk_wr_lock_irqs() xwos_sqlk_rdex_lock_cpuirq() xwos_sqlk_rdex_lock_cpuirqsv() xwos_sqlk_rdex_lock_irqs()  xwos_cond_timedwait()或xwos_cond_wait()返回时需要由用户恢复中断开关， 条件量不会管理中断开关，但可在关闭中断时使用条件量。\n  XWOS的条件量与pthread_cond_t不同：\n xwos_cond_timedwait()或xwos_cond_wait()返回值为XWOK时 才会对锁进行上锁，如果返回小于0的错误码，不会上锁，是否上锁的状态由lkst指向的缓冲区返回； pthread_cond_wait()无论如何都会等待互斥锁被上锁时才返回。     单播条件量 单播是指唤醒条件量队列中的第一个线程，条件量队列是一个先进先出（FIFO）队列：\n xwos_cond_unicast()；  可在中断上下文、中断底半部、线程上下文中使用；   若条件量绑定了信号选择器，单播不会向信号选择器发送选择信号。  广播条件量 广播是指唤醒条件量队列中的所有线程：\n xwos_cond_broadcast()；  此API可在中断上下文、中断底半部、线程上下文中使用；   若条件量绑定了信号选择器，广播会向信号选择器发送选择信号。  条件量的冻结与解冻操作 条件量可被冻结，冻结后的条件量不允许单播与广播，但可以被等待。\n 冻结：xwos_cond_freeze() 解冻：xwos_cond_thaw()  绑定选择器 可以将条件量绑定到一个特定的信号选择器上。当广播条件量时，可向信号选择器发送选择信号。\n 绑定API：xwos_cond_bind() 解绑API：xwos_cond_unbind()  可以参考信号选择器的章节获取更多的信息。\nAPI参考  文档未及时更新时，以头文件xwos/osal/sync/cond.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的条件量\n","excerpt":"XWOS的条件量\n","ref":"/docs/user-manual/sync/cond/","tags":"","title":"条件量"},{"body":"","categories":"","description":"XWOS的详细使用说明\n","excerpt":"XWOS的详细使用说明\n","ref":"/docs/user-manual/","tags":"","title":"用户手册"},{"body":"","categories":"","description":"XWLUA的锁\n","excerpt":"XWLUA的锁\n","ref":"/docs/lua-manual/xwos/lock/","tags":"","title":"锁"},{"body":"XWLUA顺序锁对象 XWLUA顺序锁对象是由XWOS内核的顺序锁（XWOS的顺序锁只是一种数据类型，并不 是对象）与XWOS内核对象组成，Lua虚拟机通过引用计数管理XWLUA顺序锁对象。\n在Lua语言中，通过对象强指针来表示Lua顺序锁对象。\nto-be-closed特性 XWLUA顺序锁对象支持Lua语言的to-be-closed特性，Lua顺序锁能在代码块结束时自动解锁。\nmysqlk = xwos.sqlk.new() function test() local lock\u003cclose\u003e = mysqlk lock:lock(\"wr\") -- 临界区 end -- 自动解锁顺序锁 XWLUA API参考 包：xwos.sqlk xwos.sqlk.new()  简介：新建一个Lua顺序锁 返回值：(userdata)新的Lua顺序锁对象的强引用指针 示例：  mysqlk = xwos.sqlk.new() 类：sqlksp  说明：顺序锁对象强指针类  sqlksp:rd_begin()  简介：开始读临界区 参数sqlksp：(userdata, 输入)类成员函数的this参数，Lua顺序锁对象的强引用指针 返回值：(number)锁的顺序值  sqlksp:rd_retry()  简介：测试顺序值是否改变 参数sqlksp：(userdata, 输入)类成员函数的this参数，Lua顺序锁对象的强引用指针 返回值：(boolean)  true：顺序值已经改变，读的结果无效 false：顺序值未改变，读的结果有效    sqlksp:get_seq()  简介：获取顺序锁的顺序值 参数sqlksp：(userdata, 输入)类成员函数的this参数，Lua顺序锁对象的强引用指针 返回值：(number)锁的顺序值  sqlksp:unlock()  简介：解锁顺序锁 参数sqlksp：(userdata, 输入)类成员函数的this参数，Lua顺序锁对象的强引用指针  sqlksp:lock(lktype, [\"t\"])  简介：锁定顺序锁 参数sqlksp：(userdata, 输入)类成员函数的this参数，Lua顺序锁对象的强引用指针 参数lktype：(string, 输入)锁类型，取值  “wr”：写锁 “rdex”：独占读锁   可选参数\"t\"：(string, 输入)尝试上锁顺序锁，若顺序锁已开启临界区，立即返回， 不会自旋等待。 返回值：(number)错误码  0：无错误 -EINVAL：参数错误 -EAGAIN：尝试上锁失败，仅当存在可选参数\"t\"时才会出现此错误值    ","categories":"","description":"XWLUA的顺序锁\n","excerpt":"XWLUA的顺序锁\n","ref":"/docs/lua-manual/xwos/lock/seqlock/","tags":"","title":"顺序锁"},{"body":"介绍 顺序锁是对自旋锁改良后的锁，顺序锁中包含一个自旋锁，并且带有一个顺序值。 顺序锁将临界区分为三种：\n 独占写  任何对顺序锁临界区的写操作都是独占的，每次写操作时，会先上锁自旋锁， 然后将顺序值加1，解锁之前也会将顺序值再加1。言外之意，每次写完之后，顺序值都加2，顺序值是偶数。\n 非独占读  如果多个CPU进行的是只读操作，它们可以同时进入非独占读临界区。 CPU进入非独占读临界区无需获得自旋锁，但需要先测试顺序值是否为偶数，并记录此时的顺序值。 当退出读临界区时，需要再次读取顺序值，并与之前记录的值进行比较：\n  如果相等，表示读的结果有效；\n  如果不相等，则表示读的过程中别的CPU进行了写操作，此次的读操作无效。\n  独占读\n  如果希望读临界区不会被写操作无效，可以使用独占读的方式， 独占读会排斥其他CPU上的独占写和独占读操作，但不会排斥非独占读， 其他CPU依然可以进入非独占读临界区。\n顺序锁的初始化 顺序锁基于自旋锁，因此同自旋锁一样，不需要提供动态创建、删除以及销毁等方法。\n 自旋锁的初始化  void xwos_sqlk_init(struct xwos_sqlk * sql); 临界区 访问写临界区 { /* 自旋等待 */ xwos_sqlk_wr_lock(\u0026lock); /* 写临界区：临界区只对线程上下文是安全的 */ xwos_sqlk_wr_unlock(\u0026lock); } 与spinlock类似，sqlk_wr还提供各种版本的API：\n 关闭/打开CPU中断：临界区对线程、中断、中断底半部上下文都是安全的  xwos_sqlk_wr_lock_cpuirq() xwos_sqlk_wr_trylock_cpuirq() xwos_sqlk_wr_unlock_cpuirq()   保存/恢复CPU中断：临界区里面还有子临界区，对线程、中断、中断底半部上下文都是安全的  xwos_sqlk_wr_lock_cpuirqsv() xwos_sqlk_wr_trylock_cpuirqsv() xwos_sqlk_wr_unlock_cpuirqrs()   关闭/打开外设中断：临界区对线程上下文、特定的外设中断是安全的  xwos_sqlk_wr_lock_irqs() xwos_sqlk_wr_trylock_irqs() xwos_sqlk_wr_unlock_irqs()   保存/恢复外设中断：临界区内有子临界区，对线程上下文、特定的外设中断是安全的  xwos_sqlk_wr_lock_irqssv() xwos_sqlk_wr_trylock_irqssv() xwos_sqlk_wr_unlock_irqsrs()   关闭/打开中断底半部：临界区对线程上下文、中断底半部是安全的  xwos_sqlk_wr_lock_bh() xwos_sqlk_wr_trylock_bh() xwos_sqlk_wr_unlock_bh()    访问独占读临界区 { /* 自旋等待 */ xwos_sqlk_rdex_lock(\u0026lock); /* 独占读临界区 */ xwos_sqlk_rdex_unlock(\u0026lock); } 与spinlock类似，sqlk_rdex还提供各种版本的API：\n 关闭/打开CPU中断：临界区对线程、中断、中断底半部上下文都是安全的  xwos_sqlk_rdex_lock_cpuirq() xwos_sqlk_rdex_trylock_cpuirq() xwos_sqlk_rdex_unlock_cpuirq()   保存/恢复CPU中断：临界区里面还有子临界区，对线程、中断、中断底半部上下文都是安全的  xwos_sqlk_rdex_lock_cpuirqsv() xwos_sqlk_rdex_trylock_cpuirqsv() xwos_sqlk_rdex_unlock_cpuirqrs()   关闭/打开外设中断：临界区对线程上下文、特定的外设中断是安全的  xwos_sqlk_rdex_lock_irqs() xwos_sqlk_rdex_trylock_irqs() xwos_sqlk_rdex_unlock_irqs()   保存/恢复外设中断：临界区内有子临界区，对线程上下文、特定的外设中断是安全的  xwos_sqlk_rdex_lock_irqssv() xwos_sqlk_rdex_trylock_irqssv() xwos_sqlk_rdex_unlock_irqsrs()   关闭/打开中断底半部：临界区对线程上下文、中断底半部是安全的  xwos_sqlk_rdex_lock_bh() xwos_sqlk_rdex_trylock_bh() xwos_sqlk_rdex_unlock_bh()    访问非独占读临界区 { seq = xwos_sqlk_rd_begin(\u0026lock); /* 进入临界区前先获取顺序值 */ do { /* 非独占读临界区 */ } while (xwos_sqlk_rd_retry(\u0026lock， seq)); /* 测试顺序值是否发生了变化 */ } API参考  文档未及时更新时，以头文件xwos/osal/lock/seqlock.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的顺序锁\n","excerpt":"XWOS的顺序锁\n","ref":"/docs/user-manual/lock/seqlock/","tags":"","title":"顺序锁"},{"body":"说明  Newlib中，标准头文件\u003cerrno.h\u003e的errno是一个宏：  /* \u003cerrno.h\u003e */ #define errno (*__errno()) extern int *__errno (void); int * __errno() { return \u0026_REENT-\u003e_errno; }  Newlib的底层代码对errno的处理非常奇怪，会将errno undef掉，然后重新定义成一个变量， 并要求libgloss中提供变量定义：  /* \u003cnewlib/libc/reent/readr.c\u003e */ #undef errno extern int errno; _ssize_t _read_r (struct _reent *ptr, int fd, void *buf, size_t cnt) { _ssize_t ret; errno = 0; if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 \u0026\u0026 errno != 0) ptr-\u003e_errno = errno; return ret; } /* \u003clibgloss/libnosys/read.c\u003e */ #undef errno extern int errno; int _read (int file, char *ptr, int len) { errno = ENOSYS; return -1; }  libgloss提供与平台相关的启动代码、I/O支持、系统函数等，其中libnosys是一个空实现；  移植方法  XWOS在每个线程对象结构体中定义了一个__errno变量，并 重新覆盖实现了int * __errno(void)函数， 返回当前线程对象的__errno的地址：  int * __errno() { struct xwos_thd * thd = xwos_cthd_self(); return \u0026thd-\u003eosthd.newlib.__errno; }  当使用\u003cerrno.h\u003e中的errno宏时，就可获取线程自身的__errno，不再 依赖libgloss。  ","categories":"","description":"","excerpt":"说明  Newlib中，标准头文件\u003cerrno.h\u003e的errno是一个宏：  /* \u003cerrno.h\u003e */ #define errno …","ref":"/docs/note/newlib/errno/","tags":"","title":"errno"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/quick-guide/gd32v/","tags":"","title":"GD32V"},{"body":"介绍 现代的MCU已经有足够的性能运行解释性语言，XWOS集成了Lua语言 —— 一种轻量小巧的脚本语言。 Lua语言在XWOS中的移植被称为XWLUA，XWLUA有以下特性：\n 交互式解释器：用户通过串口终端，可在线运行Lua语言的函数，也可运行文件系统中的脚本； 多线程：Lua语言并不支持多线程，XWLUA基于XWOS内核，扩展了Lua语言，实现了多线程的功能， 用户可以在Lua语言中使用XWOS的线程、信号量、条件量、事件标志、信号选择器、线程栅栏、 互斥锁、自旋锁、顺序锁等对象； 驱动库：用户可以根据硬件情况，自行扩展驱动库，使得Lua语言具备操作硬件的能力。  XWLUA交互式解释器   运行Lua虚拟机需要有足够的内存和浮点运算单元，因此只能在资源比较丰富的MCU上开启Lua语言， XWOS自带的参考工程中，以下工程开启了Lua语言：\n 微行电子MiniStm32H750开发板 野火电子Stm32H743开发板 正点原子阿波罗Stm32H743开发板 反客Stm32F429核心板  工程结构  工程路径：xwem/vm/lua 目录结构  src：lua的官方源码 xwlua：xwlua的实现  port.h, port.c, prefix.h, readline.c：Lua语言在XWOS上的适配代码 lua.c：以XWOS线程方式运行的交互式解释器(REPL) xwos：XWOS内核的binding库：包括线程、信号量、条件量、事件标志、信号选择器、线程栅栏、 互斥锁、自旋锁、顺序锁、电源管理 xwlib：XWOS基本C函数的binding库 xwds：玄武设备栈的binding库 xwxt：多线程共享数据的全局导出表   mif.h, mif.c：玄武模块的启动接口，交互式解释器(REPL)线程在此处启动； xwmo.mk：玄武模块的编译规则。    ","categories":"","description":"XWLUA的使用说明\n","excerpt":"XWLUA的使用说明\n","ref":"/docs/lua-manual/","tags":"","title":"Lua手册"},{"body":"UART对象 XWLUA不提供动态创建硬件的方法，硬件的创建与初始化都是在C语言中完成。因此， XWLUA虚拟机只提供C语言的API，用于将硬件的对象注册到虚拟机中。\nC API参考 xwlua_dmauartc_register void xwlua_dmauartc_register(lua_State * L, const char * name, struct xwds_dmauartc * uart)  简介：注册UART对象 参数L：(输入) 虚拟机 参数name：(输入) UART在虚拟机中的变量名 参数uart：(输入) UART对象 示例：  void xwlua_open_brdlibs(lua_State * L) { xwlua_uart_register(L, \"usart1\", \u0026stm32cube_usart1_cb); } xwlua_dmauartc_unregister void xwlua_dmauartc_unregister(lua_State * L, const char * name)  简介：删除UART对象 参数L：(输入) 虚拟机 参数name：(输入) UART在虚拟机中的变量名  XWLUA API参考 包：xwds.uart xwds.uart.rx(uart, size[, op])  简介：接收数据 参数uart：(userdata, 输入)BSP中注册的UART控制器 参数size：(number, 输入)期望接收的字节数 可选参数op：  “t”：(string, 输入)尝试接收，若接收队列为空，立即返回，不会等待； time：(number, 输入)若接收队列为空，期望等待的时间。   返回值：{(number)错误码, (number)实际接收的字节数, (string)接收到的数据}  错误码  0：无错误 -ENODATA：尝试上锁失败，仅当存在可选参数\"t\"或time为0时才会出现此错误值 -ETIMEDOUT: 超时 -EINTR: 等待被中断     示例：  -- 从usart1接收数据，最大接收10个字节，期望等待时间2s rc, rxsize, data = xwds.uart.rx(usart1, 10, 2000000000) xwds.uart.tx(uart, txd, size[, time])  简介：发送数据 参数uart：(userdata, 输入)BSP中注册的UART控制器 参数txd：(string, 输入)待发送的字节数组 参数size：(number, 输入)待发送的字节数 参数time：(number, 输入)期望等待的时间 返回值：{(number)错误码, (number)实际发送的字节数}  错误码  0：无错误 -ETIMEDOUT: 超时 -EINTR: 等待被中断     示例：  -- 打包{88, 87, 79, 83} txd = string.pack(\"BBBB\", 88, 87, 79, 83) -- 发送打包数据，期望等待时间2s rc, txsize = xwds.uart.tx(usart1, txd, #txd, 2000000000) ","categories":"","description":"XWLUA的UART库\n","excerpt":"XWLUA的UART库\n","ref":"/docs/lua-manual/xwds/uart/","tags":"","title":"UART"},{"body":"XWLUA API参考 包：xwos.flg xwos.flg.new(num)  简介：新建一个事件标志 参数num：(number, 输入)事件的数量 返回值：(userdata)新的事件标志对象的强引用指针 示例：  myflg = xwos.flg.new(32) 类：flgsp  说明：事件标志对象强指针类  flgsp:bmp()  简介：新建一个位图，位的数量与事件标志中的事件数量相等 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 返回值：(userdata)新的位图  flgsp:num()  简介：获取事件标志中事件（位）的数量 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 返回值：(number)数量  flgsp:bind(sel)  简介：绑定事件标志对象到信号选择器 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ECHRNG: 位置超出范围 -EALREADY: 同步对象已经绑定到事件对象 -EBUSY: 通道已经被其他同步对象独占    flgsp:unbind(sel)  简介：从信号选择器上解绑事件标志对象 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    flgsp:unbind(sel)  简介：从信号选择器上解绑事件标志对象 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    flgsp:read()  简介：发布事件标志 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 返回值：{(number)错误码, (userdata)位图}  错误码  0：成功 \u003c0：错误   位图：事件标志位图    flgsp:s1m(msk)  简介：同时设置多个事件标志位 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数msk：(userdata, 输入)事件的位图掩码 返回值：(number)错误码  0：成功 \u003c0：错误    flgsp:s1i(pos)  简介：设置单个事件标志位 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数pos：(number, 输入)事件的序号 返回值：(number)错误码  0：成功 \u003c0：错误    flgsp:c0m(msk)  简介：同时清除多个事件标志位 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数msk：(userdata, 输入)事件的位图掩码 返回值：(number)错误码  0：成功 \u003c0：错误    flgsp:c0i(pos)  简介：清除单个事件标志位 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数pos：(number, 输入)事件的序号 返回值：(number)错误码  0：成功 \u003c0：错误    flgsp:x1m(msk)  简介：同时翻转多个事件标志位 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数msk：(userdata, 输入)事件的位图掩码 返回值：(number)错误码  0：成功 \u003c0：错误    flgsp:x1i(pos)  简介：翻转单个事件标志位 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数pos：(number, 输入)事件的序号 返回值：(number)错误码  0：成功 \u003c0：错误    flgsp:wait(trigger, consumption, origin, msk, [op])  简介：等待并获取事件标志 参数flgsp：(userdata, 输入)类成员函数的this参数，事件标志对象的强引用指针 参数trigger：(string, 输入)事件触发条件  “sa”：所有事件位被置1触发 “so”：任意事件位被置1触发 “ca”：所有事件位被清0触发 “co”：任意事件位被清0触发 “ta”：所有事件位发生翻转触发 “to”：任意事件位发生翻转触发   参数consumption：(boolean, 输入)是否消费事件，线程可以选择是否消费事件， 消费事件是指，当线程等到事件被唤醒，可以选择是否清除事件标志。 清除的含义是：  当线程等待的是位图中的事件位被置1，清除是指将这些位清0； 当线程等待的是位图中的事件位被清0，清除是指将这些位置1；   参数origin：(userdata)事件的位图掩码  当参数trigger取值\"sa\"，“so”，“ca”，“co”：(输出) 返回触发时事件对象中位图状态 当参数trigger取值\"ta\"，“to”：  (输入) 用于比较的初始值 (输出) 返回触发时事件对象中位图状态     参数msk：(userdata, 输入)事件的位图掩码，表示只关注掩码部分的事件 可选参数op：  “t”：(string, 输入)尝试等待并获取事件标志，若事件标志的值小于等于0，立即返回， 不会等待； time：(number, 输入)期望的等待时间，超时后返回错误码-ETIMEDOUT。   返回值：(number)错误码  0：无错误 -EINVAL：参数错误 -ENODATA：尝试失败，仅当存在可选参数\"t\"时才会出现此错误值 -ETIMEDOUT：超时 -EINTR：等待被中断 -ENOTINTHD：不在线程上下文中    ","categories":"","description":"XWLUA的事件标志\n","excerpt":"XWLUA的事件标志\n","ref":"/docs/lua-manual/xwos/sync/flg/","tags":"","title":"事件标志"},{"body":"介绍 当系统需要处理很多事件，如果每个事件都绑定一个特定的条件量， 每个条件量又由一个线程进行等待处理，会导致系统需要大量内存来创建条件量和线程， 这种方法在小内存的MCU上显然不可行。条件量属于操作系统比较底层的功能， 用法虽然灵活但很复杂。因此，XWOS基于条件量实现了事件标志的功能。\n事件标志使用位图来管理一组事件，位图中的每个位代表一个事件， 当一个或多个事件状态发生变化时，事件对应的位也会发生变化，并唤醒正在等待的线程。 线程唤醒后，就可从事件位图中获取事件的状态。\nXWOS的事件标志：\n 线程可以等待位图中的事件位被置1，也可以等待事件位被清0； 线程可以等待位图中的事件位同时被置1（事件与事件之间是逻辑与的关系）， 也可以等待其中任意一个位被置1（事件与事件之间是逻辑或的关系）； 线程可以等待位图中的事件位同时被清0（事件与事件之间是逻辑与的关系）， 也可以等待其中任意一个位被清0（事件与事件之间是逻辑或的关系）； 线程可以选择是否消费事件，“消费”事件是指，当线程等到事件被 唤醒，可以选择是否清除事件标志。清除的含义是：  当线程等待的是位图中的事件位被置1，清除是指将这些位清0； 当线程等待的是位图中的事件位被清0，清除是指将这些位置1；   线程可以等待事件标志位发生翻转，翻转是指事件标志位由1变为0，或 由0变为1，当线程等待的是标志位发生翻转，不可清除事件标志； 事件位图中的位数可在创建时指定。  事件标志的创建、初始化与删除、销毁 事件标志支持静态初始化与销毁，动态创建与删除两种方式：\n 静态初始化与销毁  静态是指用户预先定义对象，这些对象在编译时由编译器分配内存。 初始化：xwos_flg_init() 销毁：xwos_flg_fini()   动态创建与删除  动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。 创建：xwos_flg_create() 删除：xwos_flg_delete()    等待事件 XWOS提供3个API等待触发事件：\n xwos_flg_trywait()  只是测试一下事件标志的触发事件，如果失败，就返回-ENODATA，不会阻塞调用的线程； 可在中断上下文、中断底半部、线程上下文中使用；   xwos_flg_wait():  只可在线程上下文中使用； 线程会阻塞等待事件标志的触发事件； 线程的阻塞状态可被中断，中断将返回-EINTR。   xwos_flg_timedwait():  只可在线程上下文中使用。 线程会限时阻塞等待事件标志的触发事件； 超时的参数用法可以参考超时API的统一形式； 线程的阻塞状态可被中断，中断将返回-EINTR。    触发条件 当调用等待事件的API时，需要指定一个触发条件（参数：trigger）。 触发条件分为电平触发和边沿触发。\n电平触发 电平触发的概念来源于数字电路中，是一种类比，是指事件特定的状态（1或0） 产生唤醒信号，下面的触发条件为电平触发：\n XWOS_FLG_TRIGGER_SET_ALL 所有事件位被置1 XWOS_FLG_TRIGGER_SET_ANY 任意事件位被置1 XWOS_FLG_TRIGGER_CLR_ALL 所有事件位被清0 XWOS_FLG_TRIGGER_CLR_ANY 任意事件位被清0  边沿触发 边沿触发的概念来源于数字电路中，是一种类比，是指事件状态发生改变 （1变0或0变1）时产生的唤醒信号，下面的触发条件为边沿触发：\n XWOS_FLG_TRIGGER_TGL_ALL 所有事件位发生翻转 XWOS_FLG_TRIGGER_TGL_ANY 任意事件位发生翻转  清除触发事件  当采用电平触发时，需要在触发后清除事件标志位，防止事件重复触发，可以 在调用等待事件的API指定参数action为XWOS_FLG_ACTION_CONSUMPTION； 当采用边沿触发时，不需要清除事件标志位。  产生触发事件 XWOS提供6个API产生触发事件：\n xwos_flg_s1m(): 同时设置多个事件标志位  可在中断上下文、中断底半部、线程上下文中使用；   xwos_flg_s1i(): 设置单个事件标志位  可在中断上下文、中断底半部、线程上下文中使用；   xwos_flg_c0m(): 同时清除多个事件标志位  可在中断上下文、中断底半部、线程上下文中使用；   xwos_flg_c0i(): 清除单个事件标志位  可在中断上下文、中断底半部、线程上下文中使用；   xwos_flg_x1m(): 同时翻转多个事件标志位  可在中断上下文、中断底半部、线程上下文中使用；   xwos_flg_x1i(): 翻转单个事件标志位  可在中断上下文、中断底半部、线程上下文中使用。    绑定选择器 可以将事件标志绑定到一个特定的信号选择器上，当触发事件产生时， 可向信号选择器发送**“选择信号”**。\n 绑定：xwos_flg_bind() 解绑：xwos_flg_unbind()  可以参考信号选择器的章节获取更多的信息。\nAPI参考  文档未及时更新时，以头文件xwos/osal/sync/flg.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的事件标志\n","excerpt":"XWOS的事件标志\n","ref":"/docs/user-manual/sync/flg/","tags":"","title":"事件标志"},{"body":"to-be-closed特性 互斥锁对象支持Lua语言的to-be-closed特性，互斥锁能在代码块结束时自动解锁。\n可重入锁 互斥锁是可重入锁，同一个Lua线程可以反复Lock。\nmymtx = xwos.mtx.new() function test() local lock\u003cclose\u003e = mymtx lock:lock() -- 临界区 end -- 自动解锁互斥锁 XWLUA API参考 包：xwos.mtx xwos.mtx.new()  简介：新建一个互斥锁 返回值：(userdata)新的互斥锁对象的强引用指针 示例：  mymtx = xwos.mtx.new() 类：mtxsp  说明：互斥锁对象强指针类  mtxsp:unlock()  简介：解锁互斥锁 参数mtxsp：(userdata, 输入)类成员函数的this参数，互斥锁对象的强引用指针 返回值：(number)错误码  0：成功 -EOWNER：线程并没有锁定此互斥锁 -ENOTINTHD：不在线程上下文中    mtxsp:lock([op])  简介：锁定互斥锁 参数mtxsp：(userdata, 输入)类成员函数的this参数，互斥锁对象的强引用指针 可选参数op：  “t”：(string, 输入)尝试上锁互斥锁，若互斥锁已开启临界区，立即返回， 不会等待； time：(number, 输入)期望的等待时间，超时后返回错误码-ETIMEDOUT。   返回值：(number)错误码  0：无错误 -EINVAL：参数错误 -ENODATA：尝试上锁失败，仅当存在可选参数\"t\"时才会出现此错误值 -ETIMEDOUT：超时 -EINTR：等待被中断 -ENOTINTHD：不在线程上下文中   示例：  mymtx = xwos.mtx.new() mymtx:lock() -- 上锁mymtx，若上锁失败，当前线程会阻塞等待 rc = mymtx:lock(\"t\") -- 尝试上锁mymtx，若上锁失败，会返回-ENODATA rc = mymtx:lock(1000000000) -- 上锁mymtx，若上锁失败，当前线程会阻塞等待，但最多等待1s ","categories":"","description":"XWLUA的互斥锁\n","excerpt":"XWLUA的互斥锁\n","ref":"/docs/lua-manual/xwos/lock/mutex/","tags":"","title":"互斥锁"},{"body":"介绍 互斥锁只能在线程上下文中使用，只能保证临界区对线程是安全的。 任何操作系统，都不可在非线程上下文中使用互斥锁。 与自旋锁及其派生锁不同，等待互斥锁的线程会被阻塞，并让出CPU。\n互斥锁存在优先级反转问题：\nXWOS互斥锁的优先级反转问题 Photo: xwos.tech / CC-BY\n  XWOS内核采取优先级天花板和优先级继承的混会策略解决此问题：\n 线程和互斥锁都拥有优先级，它们在创建时需要指定一个静态优先级， 当线程持有互斥锁时，线程可以获取互斥锁的优先级作为动态优先级， 当互斥锁被线程等待时，互斥锁可以获取线程的优先级作为动态优先级， 最终的优先级由静态优先级和动态优先级比较，取较大的一个； 假设线程A优先级低，线程B的优先级中，线程C的优先级高。 线程A已经获得锁的情况下，线程C等待锁，会临时提高锁的优先级， 锁的优先级再传递给线程A，此时线程A不会被线程B抢占。 优先级可以无限继承：假设线程A的优先级最低，线程T1、T2、…… 、Tn 的优先级依次递增，系统中有互斥锁L、M1、M2、…、Mn。 假设A持有L，T1持有M1去等待L，T2持有M2去等待M1，T3持有M3去等待M2，以此类推， Tn持有Mn去等待Mn-1。由此形成优先级传递链：Tn-\u003eMn-1-\u003eTn-1-\u003e\u0026#x2026;-\u003eM3-\u003eT3-\u003eM2-\u003eT2-\u003eM1-\u003eT1-\u003eL-\u003eA， Tn的优先级将会依次传递到Mn-1、Tn-1、…… 、M3、T3、M2、T2、M1、T1、L、A。 如何寻找互斥锁与线程的动态优先级，是寻找最大值的问题，因此可以采用与 时间树类似的方法，使用红黑树解决此问题：  使用一个rightmost指针指向最大值，需要时可直接从rightmost快速获取。 rightmost从红黑树中删除时，按照二叉树的性质，下一任rightmost是前任 的左孩子（即前驱）。如果前任的左孩子为叶子，下一任rightmost一定是前任 的父节点。 红黑树中不允许存在关键字相等的节点，因此拥有相同优先级的节点相互连接成链表。 互斥锁解锁时，从等待队列中选择最高优先级的线程获取互斥锁，若最高优先级的线程 不止一个，按照先进先出的方法选取线程。    互斥锁的创建、初始化与删除、销毁 互斥锁支持静态初始化与销毁，动态创建与删除两种方式：\n 静态初始化与销毁  静态是指用户预先定义对象，这些对象在编译时由编译器分配内存。 初始化：xwos_mtx_init() 销毁：xwos_mtx_fini()   动态创建与删除  动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。 创建：xwos_mtx_create() 删除：xwos_mtx_delete()    API参考  文档未及时更新时，以头文件xwos/osal/lock/mtx.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的互斥锁\n","excerpt":"XWOS的互斥锁\n","ref":"/docs/user-manual/lock/mutex/","tags":"","title":"互斥锁"},{"body":"介绍 伙伴算法分配器在分配时，会将内存不断地二等分，直到切割到能满足要求的最小内存大小为止。 释放时会检查与之相邻并等长的内存块（称为伙伴）是否也空闲， 如果是，就和“伙伴”合并成更大的内存块， 然后继续检测合并后的内存块是否也存在可以合并的伙伴，一直向上合并到不能合并为止。\n 优点：  支持释放操作； 支持大小不固定的内存申请操作； 反复申请与释放不会造成内存碎片。   缺点：  代码稍微复杂； 因为存在合并与切割的循环，申请与释放操作的所需要的时间不是特别稳定； 内存大小固定为2的指数，如果申请的内存过小，会造成内存浪费。   适用性：对内存复用性要求高的应用场合。 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。  API参考  文档未及时更新时，以头文件xwos/mm/bma.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的伙伴算法分配器\n","excerpt":"XWOS的伙伴算法分配器\n","ref":"/docs/user-manual/mm/bma/","tags":"","title":"伙伴算法分配器"},{"body":"","categories":"","description":"XWLUA的同步机制\n","excerpt":"XWLUA的同步机制\n","ref":"/docs/lua-manual/xwos/sync/","tags":"","title":"同步"},{"body":"","categories":"","description":"XWOS基本C函数的binding库\n","excerpt":"XWOS基本C函数的binding库\n","ref":"/docs/lua-manual/xwlib/","tags":"","title":"基本函数库"},{"body":"介绍  MCU：STM32H750 更多介绍：参考电路板主页 电路板目录：xwbd/WeActMiniStm32H750  开发环境  编译集成环境可参考：开发环境搭建指南  源码 WeActMiniStm32H750开发板使用外置的QSPI Flash存储代码，因此工程分为Bootloader和XWOS。\nBootloader  描述：位于内置Flash，负责初始化QSPI Flash后跳转至QSPI Flash中执行代码； 仓库：https://gitee.com/xwos/WeActMiniStm32H750Bootloader.git 下载：  git clone --recursive https://gitee.com/xwos/WeActMiniStm32H750Bootloader.git  在已有的仓库中同步代码：  git pull git submodule update XWOS  描述：XWOS，位于QSPI Flash 仓库：https://gitee.com/xwos/WeActMiniStm32H750.git 下载：  git clone --recursive https://gitee.com/xwos/WeActMiniStm32H750.git  在已有的仓库中同步代码：  git pull git submodule update 导入工程到STM32CubeIDE 工程需放在STM32CubeIDE的工作目录内（即STM32CubeIDE启动时指定的目录）。\n 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive  设置编译环境  打开菜单**“Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment”**； 点击**“Restore Defaults”**； 修改Debug配置的环境变量：  WKSPC:../../../${ConfigName} ~D:1 ~V:1     修改Release配置的环境变量：  WKSPC:../../../${ConfigName} ~D:0 ~V:1    环境变量PATH设置  修改Debug和Release两个配置的PATH环境变量  将STM32CubeIDE自带的工具链路径从PATH环境变量中删除； 将XWMCU工具链的路径放置到PATH环境变量中。    STM32CubeMX配置工程  STM32CubeMX配置文件：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx/WeActMiniStm32H750.ioc XWOS对中断优先级的要求：  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  NVIC设置  设置3个抢占优先级位和1个子优先级位 SVC中断设置成最高优先级，即Preemption Priority为0； PendSV中断设置成最低优先级，即Preemption Priority为7； Systick中断设置成最低优先级，即Preemption Priority为7； 系统Fault的优先级设置为0； 其他中断的优先级只可在1~6之间。    编译 调试 打开菜单Run –\u003e Debug Configurations…，根据仿真器类型，选择调试配置：\n WeActMiniStm32H750：gdb + STLink GDB Server + STLink调试器；   设置外部QSPI Flash的下载算法  算法文件：xwbd/WeActMiniStm32H750/cfg/stldr/WeActMiniStm32H750.stldr 需要拷贝到STM32CubeIDE的安装目录： plugins/com.st.stm32cube.ide.mcu.externaltools.cubeprogrammer.\u003c版本号\u003e/tools/bin/ExternalLoader； 设置External Loader为W25Q128_STM32H7xx_WeActStudio, 0x90000000, SPI_FLASH, WeActMiniStm32H750.stldr。    调试步骤  准备一张SD卡，格式化为FAT32文件系统； 将文件夹xwam/example/lua内的lua脚本，拷贝到SD卡内； 将SD卡插入开发板； 使用USB串口与开发板上的USART1(TX:PB14,RX:PB15)链接； 打开终端工具（windows可选putty、SecretCRT，Linux可选gtkterm、picocom、minicom）， 串口参数：1M波特率/8位数据/1位停止位/无奇偶校验 上电，并在STM32CubeIDE中启动调试，等待MCU运行到初始断点； 开始单步调试或连续运行调试。  调试技巧 关闭DCache ARMv7-m7内核的MCU带有Cache，常常会对定位程序BUG带来困扰。 将下面的宏开关注释掉或定义改为0后可关闭Cache：\n/* xwbd/WeActMiniStm32H750/bm/stm32cube/cfg.h */ #define STM32CUBECFG_DCACHE 1 #define STM32CUBECFG_ICACHE 1 运行过程  程序入口：xwbd/WeActMiniStm32H750/bm/main/main.c 启动流程：  xwos_main()创建一个主线程main_task()； main_task()依次调用各个玄武模块的xxx_start()函数完成对各个模块加载； 开始并行执行各个模块中创建的线程；    示例 XWOS中有很多示例，可帮助用户快速了解API的用法：\n 线程  创建线程：xwam/example/thread/create 线程睡眠：xwam/example/thread/sleep   定时器：xwam/example/timer 同步  信号量：xwam/example/sync/semaphore 条件量：xwam/example/sync/condition 事件标志：xwam/example/sync/flg 线程栅栏：xwam/example/sync/br 信号选择器：xwam/example/sync/sel   锁  中断管理：xwam/example/lock/cpuirq 自旋锁：xwam/example/lock/spinlock 顺序锁：xwam/example/lock/seqlock 互斥锁：xwam/example/lock/mtx   内存管理  简单内存分配器：xwam/example/mm/sma 内存切片分配器：xwam/example/mm/memslice 伙伴算法分配器：xwam/example/mm/bma 内存池：只用于比较大的内存区域的管理，WeActMiniStm32H750工程已经为AXI-SRAM建立了内存池。   玄武C库  CRC：xwam/example/xwlib/crc    每个示例中都有一个启动函数xxx_start()，可在xwbd/WeActMiniStm32H750/bm/main/main.c文件中 的主线程main_task()启动示例，但最好一次只启动一个示例，避免日志冲突。\n实验过程中最好将Lua虚拟机关闭，防止竞争串口导致输出混乱。方法是将 配置文件xwbd/WeActMiniStm32H750/cfg/xwem.h中的配置XWEMCFG_vm_lua改为0。\n系统集成的原理  所有移植的第三方组件、驱动包、示例代码等都是以玄武模块独立编译成静态库**.a**， 之后再将它们链接成**ELF**文件，再由**ELF**生成**bin**、**hex**和**smot**文件； 每个玄武模块都是一个独立的子工程并进行独立编译，设计上借鉴了安卓系统的Android.mk：  每个玄武模块中都有一个xwmo.mk文件，其中定义的编译参数、头文件路径等 只对当前的玄武模块生效； 每个玄武模块都是一个封闭的包，外部一般不能直接引用内部头文件，需要封装对外可见的 类型以及接口函数，并统一放在专门的API头文件内 API头文件通常以mif.h作为文件名，含义是模块接口(Module InterFace)；   XWOS内已经包含了大量玄武模块：  xwcd：外设芯片的驱动； xwam：示例与应用； xwmd：中间件； xwem：第三方开源软件；   玄武模块的具体信息可以参考用户手册-构建系统-玄武模块。  代码启动流程  stm32cube_lowlevel_init()：初始化时钟 stm32cube_init()：初始化内存管理、cache、GPIO、DMA等基础设备 main_task()：初始化其他设备、启动其他子线程  功能 BSP  STM32Cube模块：xwbd/WeActMiniStm32H750/bm/stm32cube STM32CubeMX配置文件：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx/WeActMiniStm32H750.ioc STM32CubeMX生成源码目录：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx 适配XWOS的源码：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac 中断向量表：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx/IVT  中断向量表是使用命令自动生成的 命令：xwbs/util/el/stm32ivt/stm32ivt.el xwbd/WeActMiniStm32H750/bm/stm32cube   终端UART  设备：USART1 参数：1M波特率/8位数据/1位停止位/无奇偶校验 驱动  设备栈驱动框架：xwmd/ds/uart/dma.c 设备栈驱动：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/xwds/uart.c HAL库驱动：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx/Core/Src/usart.c 注意：HAL库中的驱动存在BUG，XWOS中所提供的代码已修复     AXI-SRAM  映射地址：0x24000000 大小：512KiB 内存池  头文件  xwbd/WeActMiniStm32H750/bdl/axisram.h xwos/mm/mempool/allocator.h   内存池对象：axisram_mempool     QSPI Flash  映射地址：0x90000000 大小：8MiB 驱动：xwbd/WeActMiniStm32H750Bootloader/bm/stm32cube/cubemx/Core/Src/quadspi.c   SPI  驱动  设备栈驱动框架：xwmd/ds/spi/master.c 设备栈驱动：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/xwds/spim.c HAL库驱动：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx/Core/Src/spi.c     SPI Flash  大小：8MiB 驱动  设备栈驱动框架：xwcd/perpheral/spi/flash/w25qxx 设备栈驱动：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/xwds/w25q64jv.c     SPI LCD  分辨率：160x80 驱动  设备栈驱动框架：xwcd/perpheral/spi/lcd/st7735 设备栈驱动：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/xwds/st7735.c      Lua  版本：5.4 源码：xwem/vm/lua 适配代码：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/lua 已注册的驱动库：xwbd/WeActMiniStm32H750/bm/luamod/ds.c  SOC: stm32 UART: uart1, uart3   REPL 运行sd卡中的脚本  FATFS  版本：0.14 源码：xwem/filesystem/fatfs 适配代码：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/fatfs 文件系统：路径以\"sd:/\"开始 SD卡  驱动：xwbd/WeActMiniStm32H750/bm/stm32cube/cubemx/Core/Src/sdmmc.c    libc  适配代码：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/newlib 标准输入、输出/错误：重定向至USART1 文件系统：位于SD卡内，从路径sd:/开始 动态内存管理：由AXI-SRAM的内存池提供  电源管理  适配代码：xwbd/WeActMiniStm32H750/bm/stm32cube/xwac/xwds/pm.c  ","categories":"","description":"","excerpt":"介绍  MCU：STM32H750 更多介绍：参考电路板主页 电路板目录：xwbd/WeActMiniStm32H750  开发环境  编译 …","ref":"/docs/quick-guide/stm32/weactministm32h750/","tags":"","title":"微行电子MiniStm32H750"},{"body":"介绍 XWOS提供了日志框架，用户可以输出带有等级的日志：\n VERBOSE，等级1，冗长 DEBUG，等级2，调试 INFO，等级3，信息 NOTICE，等级4，提醒 WARNING，等级5，警告 ERR，等级6，错误 CRIT，等级7，危险 EMERG，等级8，紧急  用户可以通过配置XWLIBCFG_XWLOG_LEVEL来控制各种等级的日志是否输出：\n 当等级大于等于XWLIBCFG_XWLOG_LEVEL的日志才会输出， 当XWLIBCFG_XWLOG_LEVEL配置为0将关闭所有日志。  XWOS的日志框架需要用户在BSP中提供后端驱动接口，以决定日志最终输出到串口、SD卡、还是别的设备：\n 当配置SOCCFG_LOG为1时，BSP中需要提供函数soc_log_write()； 当配置BRDCFG_LOG为1时，BSP中需要提供函数board_log_write()； 当配置SOCCFG_LOG与配置BRDCFG_LOG同时为1时，SOCCFG_LOG具有更高优先级；  API参考  文档未及时更新时，以头文件xwos/lib/xwlog.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的日志\n","excerpt":"XWOS的日志\n","ref":"/docs/user-manual/xwlib/log/","tags":"","title":"日志"},{"body":"配置 XWOS所有配置文件都集中于xwbd/电路板名称/cfg文件夹中：\n cfg/XuanWuOS.h：总配置文件 cfg/arch.h：ARCH配置 cfg/cpu.h：CPU配置 cfg/soc.h：SOC配置 cfg/board.h：电路板配置 cfg/xwos.h：内核配置 cfg/xwmd.h：中间件配置 cfg/xwcd.h：芯片与外设配置 cfg/xwem.h：第三方组件配置 cfg/xwam.h：应用配置 cfg/oem.h：OEM模块配置  配置说明 XWOS在设计之初曾考虑过使用现成的配置生成工具，例如Linux内核的Kconfig工具。 但为了降低跨平台开发的工作量和难度，最终选择使用C语言的头文件来描述所有配置。\nXuanWuOS.h：总配置文件  架构文件夹  XuanWuOS_CFG_ARCH：架构，可在xwcd/soc/中选择架构文件夹 XuanWuOS_CFG_SUBARCH：子架构，可在架构文件夹中选择子架构文件夹 XuanWuOS_CFG_COMPILER：编译器   CPU文件夹  XuanWuOS_CFG_CPU：CPU子集，可在架构文件夹中选择CPU文件夹   SOC文件夹  XuanWuOS_CFG_SOC：片上系统，可在CPU文件夹中选择SOC文件夹   电路板文件夹  XuanWuOS_CFG_BOARD：电路板，可在xwbd/中选择电路板文件夹   链接配置  XuanWuOS_CFG_LDSCRIPT：链接脚本的的相对路径，相对于电路板文件夹   makefile配置  XuanWuOS_CFG_ELF_MK：编译ELF的makefile，位于xwbs/文件夹中 XuanWuOS_CFG_XWMO_MK：编译玄武模块的makefile，位于xwbs/文件夹中 XuanWuOS_CFG_XWMO_PREBUILT_MK：导入已编译成静态库的玄武模块的makefile，位于xwbs/文件夹中   XuanWuOS_CFG_CORE：单核与多核的选择，可选择编译xwos/下的哪种内核  mp：多核 up：单核   XuanWuOS_CFG_XWCD：是否需要引用芯片、驱动库，路径xwcd/，取值：1或0 XuanWuOS_CFG_XWMD：是否需要引用中间件库，路径xwmd/，取值：1或0 XuanWuOS_CFG_XWEM：是否需要引用第三方组件库，路径xwem/，取值：1或0 XuanWuOS_CFG_XWAM：是否需要引用应用组件库，路径xwam/，取值：1或0 XuanWuOS_CFG_OEMPATH：OEM模块的搜索路径  可以是相对于$(XuanWuOS_BRD_DIR)的相对路径 可以为绝对路径 路径可指向XWOS根目录之外    arch.h：ARCH配置  数据大小端选择，只可选择一种配置为1：  ARCHCFG_LITTLE_ENDIAN：小端 ARCHCFG_BIG_ENDIAN：大端   架构位宽，只可选择一种配置为1：  ARCHCFG_32BIT：32位 ARCHCFG_64BIT：64位   浮点单元  ARCHCFG_FPU：是否包含浮点单元，取值：1或0   C标准库  ARCHCFG_COMPILER_CLIB：是否使用编译器的C库，取值：1或0 ARCHCFG_COMPILER_ERRNO：是否使用编译器的errno.h，取值：1或0   位操作与原子操作  ARCHCFG_LIB_XWBOP_\u003cOP\u003e：是否使用汇编实现的位操作函数\u003cOP\u003e，取值：1或0 ARCHCFG_LIB_XWBMPOP_\u003cOP\u003e：是否使用汇编实现的位图操作函数\u003cOP\u003e，取值：1或0 ARCHCFG_LIB_XWAOP_\u003cOP\u003e：是否使用汇编实现的原子操作函数集\u003cOP\u003e，取值：1或0 ARCHCFG_LIB_XWBMPAOP_\u003cOP\u003e：是否使用汇编实现的位图原子操作函数集\u003cOP\u003e，取值：1或0   二进制标记  ARCHCFG_IMAGE_FLAG_OFFSET：定义文件信息在二进制文件中存放的位置偏移，用于检查文件是否完整 ARCHCFG_IMAGE_TAILFLAG：定义二进制文件尾的标记字符串，用于检查文件是否完整    cpu.h：CPU配置  CPUCFG_CPU_NUM：CPU数量； CPUCFG_L1_CACHELINE_SIZE：1机缓存的Cache Line大小，仅对有1级缓冲的SOC有效；  soc.h：SOC配置  ARM-M  SOCCFG_EXC_NUM：SOC异常数量，固定为16 SOCCFG_IRQ_NUM：SOC外设中断数量 SOCCFG_RO_IVT：中断向量表是否为const的，取值：1或0 SOCCFG_NVIC_PRIO_BITNUM：ARM-M中断优先级寄存器的位数 SOCCFG_NVIC_SUBPRIO_BITIDX：ARM-M子中断优先级从第几位开始 SOCCFG_BKPT：SOC是否提供断点调试指令，取值：1或0 SOCCFG_CRC32：SOC是否提供CRC32计算单元，取值：1或0 SOCCFG_CRC8：SOC是否提供CRC8计算单元，取值：1或0   nuclei RISC-V bumblebee (rv32imac)  SOCCFG_EXC_NUM：SOC异常数量，固定为16 SOCCFG_IRQ_NUM：SOC外设中断数量 SOCCFG_RO_IVT：中断向量表是否为const的，取值：1或0 SOCCFG_BKPT：SOC是否提供断点调试指令，取值：1或0 SOCCFG_CRC32：SOC是否提供CRC32计算单元，取值：1或0 SOCCFG_CRC8：SOC是否提供CRC8计算单元，取值：1或0    board.h：电路板配置  系统HOOK  BRDCFG_XWSKD_IDLE_HOOK：是否使用空闲任务HOOK，取值：1或0  当取值1时，需要提供void board_xwskd_idle_hook(struct xwospl_skd *)的定义   BRDCFG_XWSKD_PRE_SWCX_HOOK：是否使用任务切换前HOOK，取值：1或0  当取值1时，需要提供void board_xwskd_pre_swcx_hook(struct xwospl_skd *)的定义   BRDCFG_XWSKD_POST_SWCX_HOOK：是否使用任务切换后HOOK，取值：1或0  当取值1时，需要提供void board_xwskd_post_swcx_hook(struct xwospl_skd *)的定义   BRDCFG_XWSKD_SYSHWT_HOOK：是否使用系统滴答定时器中断HOOK，取值：1或0  当取值1时，需要提供void board_xwskd_syshwt_hook(struct xwospl_skd *)的定义   BRDCFG_XWSKD_THD_STACK_POOL：是否提供了线程栈的内存池，取值：1或0  当取值1时，需要提供xwer_t board_thd_stack_pool_alloc(xwsz_t , xwstk_t **) 与xwer_t board_thd_stack_pool_free(xwstk_t *)的定义   BRDCFG_XWSKD_THD_POSTINIT_HOOK：是否使用线程初始化后HOOK，取值：1或0  当取值1时，需要提供void board_thd_postinit_hook(struct xwospl_thd *)     电路板模块的路径需要按照构建系统的规则转换为配置宏，取值：1或0  xwos.h：内核配置 操作系统相关的配置\n XWKNCFG_CHECK_PARAMETERS：是否开启API参数检查，取值：1或0 XWKNCFG_BUG：是否启用BUG调试，取值：1或0 XWKNCFG_RELOCATE_DATA：是否需要在初始化时将xwos.data的从flash中拷贝到RAM内，取值：1或0  当链接脚本将xwos.data存放在独立的section时需要定义为1 当链接脚本将xwos.data存放在**.data section**时需要定义为0   玄武C库：  日志  XWLIBCFG_LOG：是否启用Log调试，取值：1或0 XWLIBCFG_XWLOG_LEVEL：最低日志等级； XWLIBCFG_XWLOG_BUFSIZE：日志格式化缓冲区大小；   原子操作  XWLIBCFG_XWAOP8：是否启用8位原子操作库，取值：1或0 XWLIBCFG_XWAOP16：是否启用16位原子操作库，取值：1或0 XWLIBCFG_XWAOP32：是否启用32位原子操作库，取值：1或0 XWLIBCFG_XWAOP64：是否启用64位原子操作库，取值：1或0 XWLIBCFG_XWBMPAOP：是否启用位图原子操作库，取值：1或0   数据结构  XWLIBCFG_MAP：是否启用键值对，取值：1或0   CRC  XWLIBCFG_CRC32：是否启用CRC32，取值：1或0 XWLIBCFG_CRC32_0X04C11DB7：是否启用CRC32多项式0x04C11DB7，取值：1或0 XWLIBCFG_CRC32_0XEDB88320：是否启用CRC32多项式0xEDB88320，取值：1或0 XWLIBCFG_CRC8：是否启用CRC8，取值：1或0 XWLIBCFG_CRC8_0X07：是否启用CRC8多项式0x07，取值：1或0 XWLIBCFG_CRC8_0X31：是否启用CRC8多项式0x31，取值：1或0 XWLIBCFG_CRC8_0X9B：是否启用CRC8多项式0x9B，取值：1或0   长跳转  XWLIBCFG_SETJMP：是否启用setjmp()/longjmp()，取值：1或0     内存管理  XWMMCFG_STACK_ALIGNMENT：线程栈对齐的字节数，通常设置为8字节； 栈的类型，只可选择一种配置为1：  XWMMCFG_FD_STACK：满递减栈 XWMMCFG_ED_STACK：空递减栈 XWMMCFG_FA_STACK：满递增栈 XWMMCFG_EA_STACK：满递增栈   XWMMCFG_MEMSLICE：是否启用内存切片算法，取值：1或0 XWMMCFG_BMA：是否启用伙伴算法，取值：1或0 XWMMCFG_MEMPOOL：是否启用内存池，取值：1或0   MP内核配置  调度器  XWMPCFG_SYSHWT_PERIOD：硬件定时器周期，单位纳秒 XWMPCFG_SKD_PRIORITY_RT_NUM：调度器实时优先级数量，数量越小越省内存 XWMPCFG_SKD_IDLE_STACK_SIZE：空闲任务栈大小 XWMPCFG_SKD_BH：是否启用中断底半部，取值：1或0 XWMPCFG_SKD_BH_STACK_SIZE：中断底半部栈大小 XWMPCFG_SKD_THD_MEMSLICE：是否启用memslice线程对象缓存，取值：1或0 XWMPCFG_SKD_THD_STDC_MM：是否启用C标准库中malloc()来动态创建线程对象，取值：1或0 XWMPCFG_SKD_THD_LOCAL_DATA_NUM：线程私有数据的数量 XWMPCFG_SKD_SWT：是否启用软件定时器，取值：1或0 XWMPCFG_SKD_SWT_MEMSLICE：是否启用memslice软件定时器对象缓存，取值：1或0 XWMPCFG_SKD_SWT_STDC_MM：是否启用C标准库中malloc()来动态创建定时器对象，取值：1或0   同步  XWMPCFG_SYNC_PLSEM：是否启用管道信号量，取值：1或0 XWMPCFG_SYNC_RTSEM：是否启用实时信号量，取值：1或0 XWMPCFG_SYNC_SEM_MEMSLICE：是否启用memslice信号量对象缓存，取值：1或0 XWMPCFG_SYNC_SEM_STDC_MM：是否启用C标准库中malloc()来动态创建信号量对象，取值：1或0 XWMPCFG_SYNC_COND_MEMSLICE：是否启用memslice条件量对象缓存，取值：1或0 XWMPCFG_SYNC_COND_STDC_MM：是否启用C标准库中malloc()来动态创建条件量对象，取值：1或0 XWMPCFG_SYNC_EVT：是否启用事件，取值：1或0 XWMPCFG_SYNC_EVT_STDC_MM：是否启用C标准库中malloc()来动态创建事件对象，取值：1或0   锁  XWMPCFG_LOCK_MTX_MEMSLICE：是否启用memslice互斥锁对象缓存，取值：1或0 XWMPCFG_LOCK_MTX_STDC_MM：是否启用C标准库中malloc()来动态创建互斥锁对象，取值：1或0     UP内核配置  调度器  XWUPCFG_SYSHWT_PERIOD：硬件定时器周期，单位纳秒 XWUPCFG_SKD_PRIORITY_RT_NUM：调度器实时优先级数量，数量越小越省内存 XWUPCFG_SKD_IDLE_STACK_SIZE：空闲任务栈大小 XWUPCFG_SKD_BH：是否启用中断底半部，取值：1或0 XWUPCFG_SKD_BH_STACK_SIZE：中断底半部栈大小； XWUPCFG_SKD_PM：是否启用电源管理，取值：1或0 XWUPCFG_SKD_THD_STDC_MM：是否启用C标准库中malloc()来动态创建线程对象，取值：1或0 XWUPCFG_SKD_THD_LOCAL_DATA_NUM：线程私有数据的数量 XWUPCFG_SKD_THD_EXIT：是否启用线程退出，取值：1或0 XWUPCFG_SKD_SWT：是否启用软件定时器，取值：1或0 XWUPCFG_SKD_SWT_STDC_MM：是否启用C标准库中malloc()来动态创建定时器对象，取值：1或0   同步  XWUPCFG_SYNC_PLSEM：是否启用管道信号量，取值：1或0 XWUPCFG_SYNC_PLSEM_STDC_MM：是否启用C标准库中malloc()来动态创建管道信号量对象，取值：1或0 XWUPCFG_SYNC_RTSEM：是否启用实时信号量，取值：1或0 XWUPCFG_SYNC_RTSEM_STDC_MM：是否启用C标准库中malloc()来动态创建实时信号量对象，取值：1或0 XWUPCFG_SYNC_COND：是否启用条件量，取值：1或0 XWUPCFG_SYNC_COND_STDC_MM：是否启用C标准库中malloc()来动态创建条件量对象，取值：1或0 XWUPCFG_SYNC_EVT：是否启用事件，取值：1或0 XWUPCFG_SYNC_EVT_STDC_MM：是否启用C标准库中malloc()来动态创建事件对象，取值：1或0   锁  XWUPCFG_LOCK_MTX：是否启用互斥锁，取值：1或0 XWUPCFG_LOCK_MTX_STDC_MM：是否启用C标准库中malloc()来动态创建实时互斥锁对象，取值：1或0 XWUPCFG_LOCK_FAKEMTX：是否启用虚假互斥锁，取值：1或0      xwmd.h：：中间件配置 中间件模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值1或0表示模块的是否被编译。\n XWMDCFG_CHECK_PARAMETERS：是否开启API参数检查，取值：1或0 XWMDCFG_isc_xwpcp：是否启用点对点通讯协议，取值：1或0  XWMDCFG_isc_xwpcp_LOG：是否开启日志，取值：1或0 XWMDCFG_isc_xwpcp_PORT_NUM：消息通道的数量 XWMDCFG_isc_xwpcp_PRI_NUM：消息优先级的数量 XWMDCFG_isc_xwpcp_RETRY_PERIOD：重发消息的周期 XWMDCFG_isc_xwpcp_RETRY_NUM：重发消息的最大次数 XWMDCFG_isc_xwpcp_MEMBLK_SIZE：伙伴算法分配器的单位内存块的大小 XWMDCFG_isc_xwpcp_MEMBLK_ODR：以2的n次方形式表示的伙伴算法分配器内存块的数量，此处配置的是指数n XWMDCFG_isc_xwpcp_RXTHD_PRIORITY：接收线程的优先级 XWMDCFG_isc_xwpcp_TXTHD_PRIORITY：发送线程的优先级   XWMDCFG_isc_xwscp：是否启用精简的点对点通讯协议，取值：1或0  XWMDCFG_isc_xwscp_LOG：是否开启日志，取值：1或0 XWMDCFG_isc_xwscp_PERIOD：重发消息的周期 XWMDCFG_isc_xwscp_MEMBLK_SIZE：伙伴算法分配器的单位内存块的大小 XWMDCFG_isc_xwscp_MEMBLK_ODR：以2的n次方形式表示的伙伴算法分配器内存块的数量，此处配置的是指数n XWMDCFG_isc_xwscp_THD_PRIORITY：线程的优先级   XWMDCFG_isc_xwmq：是否启用消息队列，取值：1或0  XWMDCFG_isc_xwmq_LOG：是否开启日志，取值：1或0 XWMDCFG_isc_xwmq_MEMSLICE：是否启用memslice对象缓存，取值：1或0 XWMDCFG_isc_xwmq_STDC_MM：是否启用C标准库中malloc()来动态创建对象，取值：1或0   XWMDCFG_isc_xwcq：是否启用循环队列，取值：1或0  XWMDCFG_isc_xwcq_LOG：是否开启日志，取值：1或0 XWMDCFG_isc_xwcq_STDC_MM：是否启用C标准库中malloc()来动态创建对象，取值：1或0   XWMDCFG_libc_newlibac：是否启用libc/newlib的适配代码，取值：1或0  XWMDCFG_libc_newlibac_string：是否编译string.c，取值：1或0 XWMDCFG_libc_newlibac_mem：是否编译mem.c，取值：1或0 XWMDCFG_libc_newlibac_fops：是否编译fops.c，取值：1或0   XWMDCFG_ramcode：是否启用Ramcode，取值：1或0  xwcd.h：芯片与外设配置 芯片与外设模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值1或0表示模块的是否被编译。\nxwem.h：第三方软件配置 第三方软件模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值1或0表示模块的是否被编译。\n XWEMCFG_serializing_nanopb：是否启用protobuf-nanopb，取值：1或0 XWEMCFG_fs_fatfs：是否启用FatFs，取值：1或0 XWEMCFG_fs_littlefs：是否启用littlefs，取值：1或0 XWEMCFG_fs_spiffs：是否启用spiffs，取值：1或0 XWEMCFG_fs_dhara：是否启用dhara，取值：1或0 XWEMCFG_vm_lua：是否启用Lua语言，取值：1或0  XWEMCFG_vm_lua_INT_TYPE：Lua语言中整数类型 XWEMCFG_vm_lua_FLOAT_TYPE：Lua语言中浮点类型 XWEMCFG_vm_lua_THD_STACK：Lua交互式解释器线程的栈大小 XWEMCFG_vm_lua_BRDLIBS：是否启用BSP中Lua库，取值：1或0    xwam.h：应用配置 应用模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值1或0表示模块的是否被编译。\noem.h：OEM模块配置 OEM模块的路径需要按照构建系统的规则转换为配置宏，配置宏取值1或0表示模块的是否被编译。\n","categories":"","description":"XWOS的配置\n","excerpt":"XWOS的配置\n","ref":"/docs/user-manual/configuration/","tags":"","title":"配置"},{"body":"CRC8 CRC32 API参考  CRC8：文档未及时更新时，以头文件xwos/lib/crc8.h中注释为准； CRC32：文档未及时更新时，以头文件xwos/lib/crc32.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的CRC算法库\n","excerpt":"XWOS的CRC算法库\n","ref":"/docs/user-manual/xwlib/crc/","tags":"","title":"CRC"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/quick-guide/s32k/","tags":"","title":"S32K"},{"body":"SPI主机模式控制器对象 XWLUA不提供动态创建硬件的方法，硬件的创建与初始化都是在C语言中完成。因此， XWLUA虚拟机只提供C语言的API，用于将硬件的对象注册到虚拟机中。\nC API参考 xwlua_spim_register void xwlua_spim_register(lua_State * L, const char * name, struct xwds_spim * spim)  简介：注册SPI对象 参数L：(输入) 虚拟机 参数name：(输入) SPI在虚拟机中的变量名 参数spi：(输入) SPI对象 示例：  void xwlua_open_brdlibs(lua_State * L) { xwlua_spim_register(L, \"spi1m\", \u0026stm32cube_spi1m_cb); } xwlua_spim_unregister void xwlua_spim_unregister(lua_State * L, const char * name)  简介：删除SPI对象 参数L：(输入) 虚拟机 参数name：(输入) SPI在虚拟机中的变量名  XWLUA API参考 包：xwds.spim xwds.spim.xfer(spim, txd, rx, size[, time])  简介：启动数据传输 参数spim：(userdata, 输入)BSP中注册的SPI控制器 参数txd：(string, 输入)待发送的字节数组，可为nil，表示只接收不发送 参数rx：(boolean, 输入)是否接收数据 参数size：(number, 输入)期望传输的字节数 参数time：(number, 输入)期望等待的时间 返回值：{(number)错误码, (number)实际传输的字节数, (string)接收到的数据}  错误码  0：无错误 -ETIMEDOUT: 超时 -EINTR: 等待被中断   实际传输的字节数：\u003c=期望传输的字节数 接收到的数据：当rx为false时，此返回值不存在   示例：  -- 打包{88, 87, 79, 83} txd = string.pack(\"BBBB\", 88, 87, 79, 83) -- 发送打包数据，返回接收到的数据，期望等待时间2s rc, size, rxd = xwds.spim.xfer(spi1m, txd, true, 4, 2000000000) ","categories":"","description":"XWLUA的SPI主机模式库\n","excerpt":"XWLUA的SPI主机模式库\n","ref":"/docs/lua-manual/xwds/spi-master/","tags":"","title":"SPI主机模式"},{"body":"介绍 内存池是结合了内存切片分配器与伙伴算法分配器的算法。内存管理的基本单位为页， 一页内存为4096字节，页内存使用伙伴算法分配器管理。 内存池还使用对象缓存算法建立各种小尺寸的块：8字节、16字节、32字节、 64字节、96字节、128字节、160字节、192字节、256字节、320字节、384字节、 512字节、768字节、1024字节、2048字节。 当申请内存大于2048字节，直接分配页内存；当申请的内存小于等于2048字节， 就从尺寸最合适的对象缓存分配器中分配一块内存。\n 优点：  支持释放操作； 支持大小不固定的内存申请操作； 反复申请与释放不会造成内存碎片； 小内存块不会浪费过多的内存。   缺点：  代码复杂； 申请与释放操作的所需要的时间不稳定。   适用性：外接尺寸较大的SRAM或SDRAM的内存管理，C++和Lua虚拟机的对象池。 上下文的安全性：在任何上下文（中断、中断底半部、线程）都是安全的。  API参考  文档未及时更新时，以头文件xwos/mm/mempool/allocator.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的内存池\n","excerpt":"XWOS的内存池\n","ref":"/docs/user-manual/mm/mempool/","tags":"","title":"内存池"},{"body":"介绍 XWOS的构建系统：\n 支持纯命令行方式编译，可用于持续集成环境中，例如jenkins； 可在ubuntu、Windows上运行； 支持基于Eclipse的IDE：  NXP S32DS IDE STM32CubeIDE NXP MCUXpressoIDE   为了方便集成其他项目的软件，XWOS参考了Android的构建系统， 通过编写xwmo.mk，可快速集成其他软件，就像Android.mk一样工作。  编译环境设置 xwtool XWOS提供了各平台的gcc和llvm编译工具链，可从百度网盘下载：\n https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ 提取码：xwos  ubuntu 安装必要的工具 sudo dpkg-reconfigure dash # 选择“否” sudo apt install build-essential sudo apt-add-repository ppa:kelleyk/emacs sudo apt-get update sudo apt install emacs27 工具链 XWOS的工具链可从百度网盘下载：\n https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ 提取码：xwos 文件：xwtool/ubuntu-x86_64.tar.xz 解压命令：  # 注意带上选项p，否则解压后脚本可能丢失执行权限 tar xvfJp ubuntu-x86_64.tar.xz  文件列表  \u003c安装路径\u003e ├── 60-openocd.rules ├── 80-gdlink.rules ├── 81-daplink.rules ├── 安装说明.md ├── install.sh ├── xwtool │ ├── armgcc │ ├── armllvm │ ├── openocd │ ├── ppcvlegcc │ ├── riscvgcc │ └── xwtoolwd └── xwtool.sh  安装：参考安装说明.md  windows 工具链 XWOS的工具链可从百度网盘下载：\n https://pan.baidu.com/s/1WwSaEajt6JqgMOLOa8iPEQ 提取码：xwos 文件：xwtool/windows-x86_64.7z 文件列表  \u003c安装路径\u003e ├── 安装说明.md └── xwtool ├── armgcc ├── armllvm └── xwtoolwd  安装：参考安装说明.md  IDE  STM32: STM32CubeIDE NXP S32K: S32K GD32: Eclipse GD32V:  NucleiStudio    编译器 XWOS对不同SOC的编译器支持情况不同，主要取决于上游以及官方的支持情况：\n  ARM-M\n SOC  STM32 NXP S32K I.MX.RT GD32   工具链  gcc  std: gnu11 libc: newlib   g++  std: gnu++17 C++STL: libstdc++, libsupc++   llvm(clang)  std: gnu11 libc: newlib   llvm(clang++)  std: gnu++14 C++STL: libc++.a, libc++abi.a        芯莱RISC-V\n SOC  GD32V   工具链  gcc  std: gnu11 libc: newlib   g++  std: gnu++17 C++STL: libstdc++, libsupc++   llvm      PowerPC\n SOC  MPC560x   工具链  gcc  std: gnu11 libc: newlib   g++ llvm      构建流程  XWOS的构建是从电路板目录下执行命令make开始的。 以$(XuanWuOS_BRD_DIR)代表此目录。生成的文件全部位于$(WKSPC)，$(WKSPC)的 默认路径为$(XuanWuOS_BRD_DIR)/wkspc，可在在编译之前将环境变量WKSPCexport到环境变量中； XWOS的构建系统在构建内核、xwmd模块、xwcd模块、xwem模块、 xwam模块、oem模块时都是独立编译成静态库**.a**，然后再链接。 各个模块的编译配置（头文件、编译器选项）都是完全独立的，可以理解为不同的子工程。  flowchart TD make(\"make\") --\u003e cfg cfg[\"生成配置\"] --\u003e arch arch[\"编译arch.a\"] --\u003e cpu cpu[\"编译cpu.a\"] --\u003e soc soc[\"编译soc.a\"] --\u003e brd brd[\"编译brd.a\"] --\u003e xwos xwos[\"编译XWOS内核\"] --\u003e xwmd xwmd[\"编译中间件模块\"] --\u003e xwcd xwcd[\"编译设备模块\"] --\u003e bm bm[\"编译电路板模块\"] --\u003e xwem xwem[\"编译第三方软件模块\"] --\u003e xwam xwam[\"编译应用模块\"] --\u003e oem oem[\"编译OEM模块\"] --\u003e elf elf[\"链接ELF文件\"] --\u003e bin bin[\"生成bin文件\"] 生成配置  构建系统调用脚本xwbs/util/el/mkcfg.el处理$(XuanWuOS_BRD_DIR)/cfg下的 所有配置文件，将它们转化成三个文件：  $(WKSPC)/XuanWuOS.cfg，makefile环境变量，之后被makefile引入 $(WKSPC)/autogen.h，自动生成的头文件，被顶级头文件xwos/standard.h包含 $(WKSPC)/env.rc，shell环境变量脚本，可通过source命令引入这个文件， 使得辅助功能生效    编译arch.a 构建系统会根据编译规则$(XuanWuOS_ARCH_DIR)/arch.mk， 编译架构描述层(Arch Description Layer)的源码， 并输出静态库arch.a到$(WKSPC)/obj目录下。\n编译cpu.a 构建系统会根据编译规则$(XuanWuOS_CPU_DIR)/arch.mk， 编译CPU描述层(CPU Description Layer)的源码， 并输出静态库cpu.a到$(WKSPC)/obj目录下。\n编译soc.a 构建系统会根据编译规则$(XuanWuOS_SOC_DIR)/soc.mk， 编译SOC描述层(SOC Description Layer)的源码， 并输出静态库soc.a到$(WKSPC)/obj目录下。\n编译brd.a 构建系统会根据编译规则$(XuanWuOS_BRD_DIR)/brd.mk， 编译电路板描述层(Board Description Layer)的源码， 并输出静态库brd.a到$(WKSPC)/obj目录下。\n编译XWOS内核 构建系统会加载位于xwos/xwos.mk的编译规则，最后输出静态库xwos.a到$(WKSPC)/obj目录下。\n编译中间件模块  构建系统会扫描xwmd/文件夹以及子文件下的所有xwmo.mk文件，生成模块列表， 依次将它们编译成**.a**静态库，输出到$(WKSPC)/obj目录下。 每个xwmo.mk文件代表了一个模块，其中定义了模块相关的参数：源代码列表、 附加编译选项、头文件路径等。 每个中间件模块在$(XuanWuOS_BRD_DIR)/cfg/xwmd.h中都有一个编译开关的宏定义， 定义为1时表示编译这个模块，0或未定义表示排除这个模块。 编译开关的命名规则参考模块编译开关的命名规则。  编译设备模块  构建系统会扫描xwcd文件夹以及子文件下的所有xwmo.mk文件，生成模块列表， 依次将它们编译成**.a**静态库，输出到$(WKSPC)/obj目录下。 每个xwmo.mk文件代表了一个模块，其中定义了模块相关的参数：源代码列表、 附加编译选项、头文件路径等。 每个外设库模块在$(XuanWuOS_BRD_DIR)/cfg/xwcd.h中都有一个编译开关的宏定义， 定义为1时表示编译这个模块，0或未定义表示排除这个模块。 编译开关的命名规则参考模块编译开关的命名规则。  编译电路板模块  构建系统会扫描$(XuanWuOS_BM_DIR)文件夹以及子文件下的所有xwmo.mk文件，生成模块列表， 依次将它们编译成**.a**静态库，输出到$(WKSPC)/obj目录下。 每个xwmo.mk文件代表了一个模块，其中定义了模块相关的参数：源代码列表、 附加编译选项、头文件路径等。 每个电路板模块在$(XuanWuOS_BRD_DIR)/cfg/board.h中都有一个编译开关的宏定义， 定义为1时表示编译这个模块，0或未定义表示排除这个模块。 编译开关的命名规则参考模块编译开关的命名规则。  编译第三方软件模块  构建系统会扫描xwem文件夹以及子文件下的所有xwmo.mk文件，生成模块列表， 依次将它们编译成**.a**静态库，输出到$(WKSPC)/obj目录下。 每个xwmo.mk文件代表了一个模块，其中定义了模块相关的参数：源代码列表、 附加编译选项、头文件路径等。 每个外设库模块在$(XuanWuOS_BRD_DIR)/cfg/xwem.h中都有一个编译开关的宏定义， 定义为1时表示编译这个模块，0或未定义表示排除这个模块。 编译开关的命名规则参考模块编译开关的命名规则。  编译应用模块  构建系统会扫描xwam文件夹以及子文件下的所有xwmo.mk文件，生成模块列表， 依次将它们编译成**.a**静态库，输出到$(WKSPC)/obj目录下。 每个xwmo.mk文件代表了一个模块，其中定义了模块相关的参数：源代码列表、 附加编译选项、头文件路径等。 每个外设库模块在$(XuanWuOS_BRD_DIR)/cfg/xwam.h中都有一个编译开关的宏定义， 定义为1时表示编译这个模块，0或未定义表示排除这个模块。 编译开关的命名规则参考模块编译开关的命名规则。  编译OEM模块  OEM文件夹路径由配置XuanWuOS_CFG_OEMPATH指定，此配置位于cfg/XuanWuOS.h中：  可以是相对于$(XuanWuOS_BRD_DIR)的相对路径 可以为绝对路径 路径可指向XWOS根目录之外   构建系统会扫描OEM文件夹以及子文件下的所有xwmo.mk文件，生成模块列表， 依次将它们编译成**.a**静态库，输出到$(WKSPC)/obj/oem目录下。 每个xwmo.mk文件代表了一个模块，其中定义了模块相关的参数：源代码列表、 附加编译选项、头文件路径等。 每个外设库模块在$(XuanWuOS_BRD_DIR)/cfg/oem.h中都有一个编译开关的宏定义， 定义为1时表示编译这个模块，0或未定义表示排除这个模块。 编译开关的命名规则参考模块编译开关的命名规则。  链接ELF文件 构建系统最终会将以上生成的所有**.a**静态库链接成**XWOS.elf**文件， 连接脚本由$(XuanWuOS_BRD_DIR)/$(XuanWuOS_CFG_LDSCRIPT)定义。\n生成bin文件 构建系统会将XWOS.elf文件转换成**.bin**文件以及**.hex**文件。\n构建选项  ~V  取值：  1: 开启选项 0: 关闭选项（默认值）   用法：    make ~V=1   作用：输出完整的编译过程\n  ~D\n 取值：  1: 开启选项（默认值） 0: 关闭选项   用法：    make ~D=0  作用：优化编译，输出体积较小的二进制，但不利于调试。  玄武模块 XWOS的设备模块、电路板模块、中间件模块、第三方软件模块以及OEM模块， 都是使用xwmo.mk来描述编译规则的，将它们统一称为玄武模块(XWMO)。 编译规则xwmo.mk的原理类似于Android系统中的Android.mk：每个玄武模块都是 独立编译的，其中定义的编译参数、头文件只对当前有效。\n示例，xwam/example/cxx的xwmo.mk：\ninclude $(XuanWuOS_WKSPC_DIR)/XuanWuOS.cfg # 包含环境变量 include $(XWBS_UTIL_MK_XWMO) # 包含一些辅助的Makefile函数  XWMO_CSRCS := mif.c # 指定C源文件 XWMO_CFLAGS := # 指定附加的C编译选项 XWMO_CXXSRCS := task.cxx # 指定C++源文件 XWMO_CXXSRCS += test/literal.cxx test/vector.cxx # 增加C++源文件 XWMO_CXXFLAGS := -Wno-unused-value # C++编译选项 XWMO_CXXFLAGS_llvm += -Wno-error=gnu-string-literal-operator-template # 当编译器为llvm时一增加的C++编译选项 XWMO_INCDIRS := $(call getXwmoDir) # 指定附加的头文件搜索路径，其中使用函数getXwmoDir获得当前xwmo的路径 include xwbs/$(XuanWuOS_CFG_XWMO_MK) # 引用编译Makefile执行编译 模块路径命名规则  由于模块路径需要对应于C语言中的一个宏定义作为编译开关， 因此模块路径需要符合C语言标识符的规则，但可以包含几个特殊符号：  路径不能以数字开头； 路径中每级目录以/隔开； 路径中可包含.，但不能出现../和./； 路径中可包含-；    模块编译开关的命名规则  模块路径只需要转换相对路径部分：  中间件模块：取xwmd（不含）之后的路径； 设备驱动模块：取xwcd（不含）之后的路径； 电路板模块：取$(XuanWuOS_BRD_DIR)/bm（不含）之后的路径； 第三方软件模块：取xwem（不含）之后的路径； 应用模块：取xwam（不含）之后的路径； OEM模块：取OEM文件夹（不含）之后的路径。   路径中的_，需要两个_来表示； 路径中的/被转换成_； 路径中的.被转换成_； 路径中的-被转换成_； 增加前缀：  中间件模块：XWMDCFG 设备模块：XWCDCFG 电路板模块：BMCFG 第三方软件模块：XWEMCFG 应用模块：XWAMCFG OEM模块：OEMCFG   示例：  中间件模块：xwmd/isc/xwpcp –\u003e XWMDCFG_isc_xwpcp； 设备驱动模块：xwcd/perpheral/ds/i2c/eeprom –\u003e *XWCDCFG_perpheral_ds_i2c_eeprom； 电路板模块：xwbd/fk429m/bm/stm32_cube –\u003e BMCFG_stm32__cube； 第三方软件模块：xwem/vm/l__u_a-5.4.2 –\u003e XWEMCFG_vm_l____u__a_5_4_2； 应用模块：xwam/example/cxx –\u003e XWAMCFG_example_cxx； OEM模块：oem/s32ksdk –\u003e OEMCFG_s32ksdk；   可以借助辅助功能中的xwmc命令生成编译开关的宏标识符。  增加模块  中间件模块  模块位于xwmd/目录中； 编译开关以XWMDCFG为前缀，位于文件$(XuanWuOS_BRD_DIR)/cfg/xwmd.h， 定义为1表示编译模块。   设备驱动模块  模块位于xwcd/目录中； 编译开关以 XWCDCFG为前缀，位于文件$(XuanWuOS_BRD_DIR)/cfg/xwcd.h， 定义为1表示编译模块。   电路板模块  模块位于$(XuanWuOS_BRD_DIR)/bm/目录中； 编译开关以BMCFG为前缀，位于文件$(XuanWuOS_BRD_DIR)/cfg/board.h， 定义为1表示编译模块。   第三方软件模块  模块位于xwem/目录中； 编译开关以XWEMCFG为前缀，位于文件$(XuanWuOS_BRD_DIR)/cfg/xwem.h， 定义为1表示编译模块。   应用模块  模块位于xwam/目录中； 编译开关以XWAMCFG为前缀，位于文件$(XuanWuOS_BRD_DIR)/cfg/xwam.h， 定义为1表示编译模块。   OEM模块  模块位于配置XuanWuOS_CFG_OEMPATH指定的路径中； 编译开关以OEMCFG为前缀，位于文件$(XuanWuOS_BRD_DIR)/cfg/oem.h， 定义为1表示编译模块。   xwmo.mk模板  include $(XuanWuOS_WKSPC_DIR)/XuanWuOS.cfg # 包含配置文件 include $(XWBS_UTIL_MK_XWMO) # 包含一些Makefile函数，例如下面调用的getXwmoDir XWMO_CSRCS := # C源文件 XWMO_CFLAGS := # 增加C编译选项 XWMO_CXXSRCS := # C++源文件 XWMO_CXXFLAGS := # 增加C++编译选项 XWMO_INCDIRS := $(call getXwmoDir) # 获取模块路径并附加到头文件搜索路径 XWMO_LUASRCS := # 增加Lua源文件 include xwbs/$(XuanWuOS_CFG_XWMO_MK) # 引用编译Makefile执行编译 辅助功能 为了方便开发，XWOS定义了一些与模块编译相关的辅助命令。\n初始化环境 source xwbd/WeActMiniStm32H750/env.sh # 以电路板WeActMiniStm32H750为例 命令  xwmc  功能：获取模块编译开关的C语言宏标识符。 用法举例：    cd ${XWOS_PATH}/xwem/vm/lua # 进入到vm/lua模块中 xwmc \u003e XWEMCFG_vm_lua # 输出结果  xwmn  功能：获取模块的**.a**文件名。 用法举例：    cd ${XWOS_PATH}/xwem/vm/lua # 进入到vm/lua模块中 xwmn \u003e xwem_vm_lua.a # 输出  xwm  功能：编译整个XWOS工程，类似Android的m命令。 用法：xwm [选项] [目标] 选项 -B：全部重新编译一次 目标：make的目标 用法举例：    xwm # 编译整个工程 xwm c # 清理 xwm d # 侧底清理  xwmm  功能：单独编译模块，类似Android的mm命令，使用当前路径作为模块的路径。 选项 -B：全部重新编译一次 用法举例：    cd ${XWOS_PATH}/xwem/vm/lua # 进入到vm/lua模块中 xwmm  xwmmm  功能：单独编译模块，类似Android的mmm命令，需要指定模块的路径。 选项 -B：全部重新编译一次 用法举例：    xwmmm xwem/vm/lua   xwcroot\n 功能：切换到XWOS的根目录，类似Android的croot命令。    xwcbd\n 功能：切换到电路板目录。    ","categories":"","description":"XWOS的构建系统\n","excerpt":"XWOS的构建系统\n","ref":"/docs/user-manual/build-system/","tags":"","title":"构建系统"},{"body":"","categories":"","description":"玄武设备栈的binding库\n","excerpt":"玄武设备栈的binding库\n","ref":"/docs/lua-manual/xwds/","tags":"","title":"玄武设备栈"},{"body":"XWLUA API参考 包：xwos.pm xwos.pm.suspend()  简介：系统进入低功耗模式  ","categories":"","description":"XWLUA的电源管理\n","excerpt":"XWLUA的电源管理\n","ref":"/docs/lua-manual/xwos/pm/","tags":"","title":"电源管理"},{"body":"XWLUA API参考 包：xwos.br xwos.br.new(num)  简介：新建一个线程栅栏 参数num：(number, 输入)线程槽的数量 返回值：(userdata)新的线程栅栏对象的强引用指针 示例：  mybr = xwos.br.new(32) 类：brsp  说明：线程栅栏对象强指针类  brsp:bmp()  简介：新建一个位图，位的数量与线程栅栏中的线程槽数量相等 参数brsp：(userdata, 输入)类成员函数的this参数，线程栅栏对象的强引用指针 返回值：(userdata)新的位图  brsp:num()  简介：获取线程栅栏中线程槽（位）的数量 参数brsp：(userdata, 输入)类成员函数的this参数，线程栅栏对象的强引用指针 返回值：(number)数量  brsp:bind(sel)  简介：绑定线程栅栏对象到信号选择器 参数brsp：(userdata, 输入)类成员函数的this参数，线程栅栏对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ECHRNG: 位置超出范围 -EALREADY: 同步对象已经绑定到事件对象 -EBUSY: 通道已经被其他同步对象独占    brsp:unbind(sel)  简介：从信号选择器上解绑线程栅栏对象 参数brsp：(userdata, 输入)类成员函数的this参数，线程栅栏对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    brsp:unbind(sel)  简介：从信号选择器上解绑线程栅栏对象 参数brsp：(userdata, 输入)类成员函数的this参数，线程栅栏对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    brsp:sync(pos, msk, [time])  简介：等待并获取线程栅栏 参数brsp：(userdata, 输入)类成员函数的this参数，线程栅栏对象的强引用指针 可选参数time：(number, 输入)期望的等待时间，超时后返回错误码-ETIMEDOUT。 返回值：(number)错误码  错误码  0：无错误 -ECHRNG：位置超出范围 -ETIMEDOUT：超时 -EINTR：等待被中断 -ENOTINTHD：不在线程上下文中      ","categories":"","description":"XWLUA的线程栅栏\n","excerpt":"XWLUA的线程栅栏\n","ref":"/docs/lua-manual/xwos/sync/br/","tags":"","title":"线程栅栏"},{"body":"介绍 XWOS的线程栅栏是用于协调多个线程并行工作的同步机制。当线程到达线程栅栏时会暂停运行 并等待，直到所有合作的线程都达到线程栅栏，所有线程从线程栅栏开始“同时”执行。\n线程栅栏的创建、初始化与删除、销毁 线程栅栏支持静态初始化与销毁，动态创建与删除两种方式：\n 静态初始化与销毁  静态是指用户预先定义对象，这些对象在编译时由编译器分配内存。 初始化：xwos_br_init() 销毁：xwos_br_fini()   动态创建与删除  动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。 创建：xwos_br_create() 删除：xwos_br_delete()   线程栅栏在初始化/创建时，需要指定线程数量。  线程栅栏的工作原理 XWOS提供2个API：\nxwer_t xwos_br_wait(struct xwos_br * br); xwer_t xwos_br_timedwait(struct xwos_br * br, xwtm_t * xwtm);  只可在线程上下文中使用； 每当一个线程到达栅栏，线程就会阻塞等待，线程栅栏中数量就会增加1； xwos_br_timedwait()还会设定一个超时时间，超时后线程被唤醒，并返回错误码-ETIMEDOUT； 超时的参数xwtm_t * xwtm用法可以参考超时API的统一形式； 线程的阻塞状态可被中断，中断将返回-EINTR； 当线程栅栏中线程数量达到线程栅栏初始化/创建时指定线程数量后，所有线程都被唤醒，开始“同时”执行。  绑定与解绑选择器 线程栅栏也时同步对象，也可以将绑定到一个特定的信号选择器上。所有线程从线程栅栏开始“同时”执行时， 可向信号选择器发送一个选择信号。\n 绑定API：xwos_br_bind() 解绑API：xwos_br_unbind()  可以参考信号选择器的章节获取更多的信息。\nAPI参考  文档未及时更新时，以头文件xwos/osal/sync/br.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的线程栅栏\n","excerpt":"XWOS的线程栅栏\n","ref":"/docs/user-manual/sync/br/","tags":"","title":"线程栅栏"},{"body":"介绍  MCU: STM32H743XIHx SDRAM: 64MiB 更多介绍: 主页 电路板目录：xwbd/EmbedFireStm32H743  开发环境  编译集成环境可参考：开发环境搭建指南  源码  仓库：https://gitee.com/xwos/EmbedFireStm32H743.git 下载：  git clone --recursive https://gitee.com/xwos/EmbedFireStm32H743.git  在已有的仓库中同步代码：  git pull git submodule update 导入工程到STM32CubeIDE 工程需放在STM32CubeIDE的工作目录内（即STM32CubeIDE启动时指定的目录）。\n 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive  设置编译环境  打开菜单**“Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment”**； 点击**“Restore Defaults”**； 修改Debug配置的环境变量：  WKSPC:../../../${ConfigName} ~D:1 ~V:1     修改Release配置的环境变量：  WKSPC:../../../${ConfigName} ~D:0 ~V:1    环境变量PATH设置  修改Debug和Release两个配置的PATH环境变量  将STM32CubeIDE自带的工具链路径从PATH环境变量中删除； 将XWMCU工具链的路径放置到PATH环境变量中。    STM32CubeMX配置工程  STM32CubeMX配置文件：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/EmbedFireStm32H743.ioc XWOS对中断优先级的要求：  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  NVIC设置  设置3个抢占优先级位和1个子优先级位 SVC中断设置成最高优先级，即Preemption Priority为0； PendSV中断设置成最低优先级，即Preemption Priority为7； Systick中断设置成最低优先级，即Preemption Priority为7； 系统Fault的优先级设置为0； 其他中断的优先级只可在1~6之间。    编译 调试 打开菜单Run –\u003e Debug Configurations…，根据仿真器类型，选择调试配置：\n EmbedFireStm32H743-openocd-daplink：gdb + openocd + DAPLink调试器 EmbedFireStm32H743-openocd-jlink：gdb + openocd + JLink调试器 EmbedFireStm32H743-stlink：gdb + STLink GDB Server + JLink调试器  调试步骤  准备一张SD卡，格式化为FAT32文件系统； 将文件夹xwam/example/lua内的lua脚本，拷贝到SD卡内； 将SD卡插入开发板；   使用MiniUSB线连接电路板上的USB-232接口与PC； 打开终端工具（windows可选putty、SecretCRT，Linux可选gtkterm、picocom、minicom）, 但先不要在终端工具中打开串口，否则MCU会进入下载模式；   上电，并在STM32CubeIDE中启动调试，等待MCU运行到初始断点；   在终端工具中打开串口，参数：1M波特率/8位数据/1位停止位/无奇偶校验；   开始单步调试或连续运行调试。  调试技巧 关闭DCache ARMv7-m7内核的MCU带有Cache，常常会对定位程序BUG带来困扰。 将下面的宏开关注释掉或定义改为0后可关闭Cache：\n/* xwbd/EmbedFireStm32H743/bm/stm32cube/cfg.h */ #define STM32CUBECFG_DCACHE 1 #define STM32CUBECFG_ICACHE 1 运行过程  程序入口：xwbd/EmbedFireStm32H743/bm/main/main.c 启动流程：  xwos_main()创建一个主线程main_task()； main_task()依次调用各个玄武模块的xxx_start()函数完成对各个模块加载； 开始并行执行各个模块中创建的线程；    示例 XWOS中有很多示例，可帮助用户快速了解API的用法：\n 线程  创建线程：xwam/example/thread/create 线程睡眠：xwam/example/thread/sleep   定时器：xwam/example/timer 同步  信号量：xwam/example/sync/semaphore 条件量：xwam/example/sync/condition 事件标志：xwam/example/sync/flg 线程栅栏：xwam/example/sync/br 信号选择器：xwam/example/sync/sel   锁  中断管理：xwam/example/lock/cpuirq 自旋锁：xwam/example/lock/spinlock 顺序锁：xwam/example/lock/seqlock 互斥锁：xwam/example/lock/mtx   内存管理  简单内存分配器：xwam/example/mm/sma 内存切片分配器：xwam/example/mm/memslice 伙伴算法分配器：xwam/example/mm/bma 内存池：只用于比较大的内存区域的管理，例如外接的SDRAM， EmbedFireStm32H743工程已经为板载的SDRAM建立了内存池。   玄武C库  CRC：xwam/example/xwlib/crc    每个示例中都有一个启动函数xxx_start()，可在xwbd/EmbedFireStm32H743/bm/main/main.c文件中 的主线程main_task()启动示例，但最好一次只启动一个示例，避免日志冲突。\n实验过程中最好将Lua虚拟机关闭，防止竞争串口导致输出混乱。方法是将 配置文件xwbd/EmbedFireStm32H743/cfg/xwem.h中的配置XWEMCFG_vm_lua改为0。\n系统集成的原理  所有移植的第三方组件、驱动包、示例代码等都是以玄武模块独立编译成静态库**.a**， 之后再将它们链接成**ELF**文件，再由**ELF**生成**bin**、**hex**和**smot**文件； 每个玄武模块都是一个独立的子工程并进行独立编译，设计上借鉴了安卓系统的Android.mk：  每个玄武模块中都有一个xwmo.mk文件，其中定义的编译参数、头文件路径等 只对当前的玄武模块生效； 每个玄武模块都是一个封闭的包，外部一般不能直接引用内部头文件，需要封装对外可见的 类型以及接口函数，并统一放在专门的API头文件内 API头文件通常以mif.h作为文件名，含义是模块接口(Module InterFace)；   XWOS内已经包含了大量玄武模块：  xwcd：外设芯片的驱动； xwam：示例与应用； xwmd：中间件； xwem：第三方开源软件；   玄武模块的具体信息可以参考用户手册-构建系统-玄武模块。  代码启动流程  stm32cube_lowlevel_init()：初始化时钟 stm32cube_init()：初始化内存管理、cache、GPIO、DMA等基础设备 main_task()：初始化其他设备、启动其他子线程  功能 BSP  STM32Cube模块：xwbd/EmbedFireStm32H743/bm/stm32cube STM32CubeMX配置文件：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/EmbedFireStm32H743.ioc STM32CubeMX生成源码目录：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx 适配XWOS的源码：xwbd/EmbedFireStm32H743/bm/stm32cube/xwac 中断向量表：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/IVT  中断向量表是使用命令自动生成的； 命令：xwbs/util/el/stm32ivt/stm32ivt.el xwbd/EmbedFireStm32H743/bm/stm32cube   终端UART  设备：USART1 参数：1M波特率/8位数据/1位停止位/无奇偶校验 驱动  驱动框架 —— 设备栈：xwmd/ds/uart/dma.c 设备栈驱动：xwbd/EmbedFireStm32H743/bm/stm32cube/xwac/xwds/uart.c HAL库驱动：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/Core/Src/usart.c 注意：HAL库中的驱动存在BUG，XWOS中所提供的代码已修复     QSPI Flash  映射地址：0x90000000 大小：32MiB 驱动：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/Core/Src/quadspi.c   SDRAM  映射地址：0xD0000000 大小：64MiB 驱动：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/Core/Src/fmc.c 内存池  头文件  xwbd/EmbedFireStm32H743/bm/stm32cube/mif.h xwos/mm/mempool/allocator.h   内存池对象：newlibac_mempool      Lua  版本：5.4 源码：xwem/vm/lua 适配代码：xwbd/EmbedFireStm32H743/bm/stm32cube/xwac/lua 已注册的驱动库：xwbd/EmbedFireStm32H743/bm/luamod/ds.c  SOC: stm32 UART: uart1, uart5   REPL 运行sd卡中的脚本  FATFS  版本：0.14 源码：xwem/filesystem/fatfs 适配代码：xwbd/EmbedFireStm32H743/bm/stm32cube/xwac/fatfs 文件系统：路径以\"sd:/\"开始 SD卡  驱动：xwbd/EmbedFireStm32H743/bm/stm32cube/cubemx/Core/Src/sdmmc.c    libc  适配代码：xwbd/EmbedFireStm32H743/bm/stm32cube/xwac/newlib 标准输入、输出/错误：重定向至USART1 文件系统：位于SD卡内，从路径sd:/开始 动态内存管理：由SDRAM的内存池提供  电源管理  适配代码：xwbd/EmbedFireStm32H743/bm/stm32cube/xwac/xwds/pm.c  ","categories":"","description":"","excerpt":"介绍  MCU: STM32H743XIHx SDRAM: 64MiB 更多介绍: 主页 电路板目 …","ref":"/docs/quick-guide/stm32/embedfirestm32h743/","tags":"","title":"野火Stm32H743 Pro开发板"},{"body":"IIC主机模式控制器对象 XWLUA不提供动态创建硬件的方法，硬件的创建与初始化都是在C语言中完成。因此， XWLUA虚拟机只提供C语言的API，用于将硬件的对象注册到虚拟机中。\nC API参考 xwlua_i2cm_register void xwlua_i2cm_register(lua_State * L, const char * name, struct xwds_i2cm * i2cm)  简介：注册I2C对象 参数L：(输入) 虚拟机 参数name：(输入) I2C在虚拟机中的变量名 参数i2c：(输入) I2C对象 示例：  void xwlua_open_brdlibs(lua_State * L) { xwlua_i2cm_register(L, \"i2c2m\", \u0026stm32cube_i2c2m_cb); } xwlua_i2cm_unregister void xwlua_i2cm_unregister(lua_State * L, const char * name)  简介：删除I2C对象 参数L：(输入) 虚拟机 参数name：(输入) I2C在虚拟机中的变量名  XWLUA API参考 类：i2cm i2cm:xfer(addr, start, stop, read, size[, txd, time])  简介：启动数据传输 参数addr：(number, 输入)I2C外设的地址 参数start：(boolean, 输入)是否产生Start条件 参数stop：(boolean, 输入)是否产生Stop条件 参数read：(boolean, 输入)方向是否为读 参数size：(number, 输入)本次数据传输的的字节数 参数txd：(string, 输入)待发送的字节数组 参数time：(number, 输入)期望等待的时间 返回值：{(number)错误码, (string)接收到的数据}  错误码  0：无错误 -ETIMEDOUT: 超时 -EINTR: 等待被中断     示例：  -- 向EEPROM的0地址写入4字节数据 addr = string.pack(\"\", 0x00) -- 打包{地址, 88, 87, 79, 83} txd = string.pack(\"BBBBB\", 0, 88, 87, 79, 83) -- 写入地址和数据 rc = i2c2m:xfer(0xA0, true, true, false, #txd, txd, 2000000000) -- 向EEPROM的0地址读出4字节数据 addr = string.pack(\"\", 0x00) -- 打包{0} txd = string.pack(\"B\", 0) -- 写入地址 rc = i2c2m:xfer(0xA0, true, true, false, #txd, txd, 2000000000) -- 读出数据 rc, rxd = i2c2m:xfer(0xA0, false, true, true, 4, 2000000000) ","categories":"","description":"XWLUA的IIC主机模式库\n","excerpt":"XWLUA的IIC主机模式库\n","ref":"/docs/lua-manual/xwds/iic-master/","tags":"","title":"IIC主机模式"},{"body":"XWLUA API参考 包：xwos.sel xwos.sel.new(num)  简介：新建一个信号选择器 参数num：(number, 输入)信号槽的数量 返回值：(userdata)新的信号选择器对象的强引用指针 示例：  mysel = xwos.sel.new(32) 类：selsp  说明：信号选择器对象强指针类  selsp:bmp()  简介：新建一个位图，位的数量与信号选择器中的信号槽数量相等 参数selsp：(userdata, 输入)类成员函数的this参数，信号选择器对象的强引用指针 返回值：(userdata)新的位图  selsp:num()  简介：获取信号选择器中信号槽（位）的数量 参数selsp：(userdata, 输入)类成员函数的this参数，信号选择器对象的强引用指针 返回值：(number)数量  selsp:bind(sel)  简介：绑定信号选择器对象到信号选择器 参数selsp：(userdata, 输入)类成员函数的this参数，信号选择器对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ECHRNG: 位置超出范围 -EALREADY: 同步对象已经绑定到事件对象 -EBUSY: 通道已经被其他同步对象独占    selsp:unbind(sel)  简介：从信号选择器上解绑信号选择器对象 参数selsp：(userdata, 输入)类成员函数的this参数，信号选择器对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    selsp:unbind(sel)  简介：从信号选择器上解绑信号选择器对象 参数selsp：(userdata, 输入)类成员函数的this参数，信号选择器对象的强引用指针 参数sel：(userdata, 输入)信号选择器对象的强引用指针 返回值：(number)错误码  0：成功 -ENOTCONN: 同步对象没有绑定到事件对象上    selsp:wait(msk, [op])  简介：等待并获取信号选择器 参数selsp：(userdata, 输入)类成员函数的this参数，信号选择器对象的强引用指针 参数msk：(userdata, 输入)待触发的同步对象位图掩码 可选参数op：  “t”：(string, 输入)尝试等待并获取事件标志，若事件标志的值小于等于0，立即返回， 不会等待； time：(number, 输入)期望的等待时间，超时后返回错误码-ETIMEDOUT。   返回值：{(number)错误码, (userdata)位图}  错误码  0：无错误 -ETIMEDOUT：超时 -EINTR：等待被中断 -ENOTINTHD：不在线程上下文中   位图：已触发的同步对象位图掩码    ","categories":"","description":"XWLUA的信号选择器\n","excerpt":"XWLUA的信号选择器\n","ref":"/docs/lua-manual/xwos/sync/sel/","tags":"","title":"信号选择器"},{"body":"介绍 信号选择器类似于事件标志，使用位图来管理一组同步对象。使得单一线程可以同时等待 一组不同的同步对象，类似于POSIX中的select()。 每个同步对象在信号选择器位图中都绑定一个特定的位， 当这些同步对象发送选择信号时，信号选择器位图中特定的位被置1， 同时使得等待信号选择器的线程被唤醒。\n发送信号对于不同的同步对象有不同解释：\n 信号量：指发布操作（V操作），API xwos_sem_post()； 条件量：指广播操作，API xwos_cond_broadcast()，注意， 单播xwos_cond_unicast()不会向信号选择器发送选择信号； 事件标志：指事件标志位图中任何一位发生改变，对应于API：  xwos_flg_s1m() xwos_flg_s1i() xwos_flg_c0m() xwos_flg_c0i() xwos_flg_x1m() xwos_flg_x1i()   线程栅栏：指所有线程抵达栅栏处，并同时被唤醒； 信号选择器：信号选择器本身也时同步对象，当任何绑定在信号选择器中的同步对象向 信号选择器发送了选择信号，信号选择器亦会向其父信号选择器发送选择信号。 信号选择器之间可以依次绑定，形成传递链，将选择信号在传递链上传递。但要注意， 信号选择器不可相互绑定形成循环链，否则会造成无限传递。  XWOS信号选择器示意图 Photo: xwos.tech / CC-BY\n  信号选择器的创建、初始化与删除、销毁 信号选择器支持静态初始化与销毁，动态创建与删除两种方式：\n 静态初始化与销毁  静态是指用户预先定义对象，这些对象在编译时由编译器分配内存。 初始化：xwos_sel_init() 销毁：xwos_sel_fini()   动态创建与删除  动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。 创建：xwos_sel_create() 删除：xwos_sel_delete()    绑定与解绑 XWOS中所有同步对象（包括信号选择器本身）都带有两个相似的API:\n/* 绑定 */ xwer_t xwos_sem_bind(); xwer_t xwos_cond_bind(); xwer_t xwos_flg_bind(); xwer_t xwos_br_bind(); xwer_t xwos_sel_bind(); /* 解绑 */ xwer_t xwos_sem_unbind(); xwer_t xwos_cond_unbind(); xwer_t xwos_flg_unbind(); xwer_t xwos_br_unbind(); xwer_t xwos_sel_unbind(); 同步对象绑定操作又分为独占绑定与非独占绑定：\n 独占绑定：是指同步对象一旦绑定了信号选择器位图中的某一位后，其他同步对象 不可再绑定此位； 非独占绑定：是指同步对象一旦绑定了信号选择器位图中的某一位后，其他同步对象 还可继续再绑定此位。  同步对象采用的绑定方式：\n 信号量：独占绑定 条件量：非独占绑定 事件标志：非独占绑定 线程栅栏：非独占绑定 信号选择器：非独占绑定  API参考  文档未及时更新时，以头文件xwos/osal/sync/sel.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的信号选择器\n","excerpt":"XWOS的信号选择器\n","ref":"/docs/user-manual/sync/sel/","tags":"","title":"信号选择器"},{"body":"flowchart LR poweron(\"上电\") --\u003e 低级初始化阶段 --\u003e 系统初始化阶段 --\u003e 用户程序 subgraph 低级初始化阶段 direction TB arch_lowlevel_init[\"arch_lowlevel_init()\"] --\u003e cpu_lowlevel_init cpu_lowlevel_init[\"cpu_lowlevel_init()\"] --\u003e soc_lowlevel_init soc_lowlevel_init[\"soc_lowlevel_init()\"] --\u003e board_lowlevel_init board_lowlevel_init[\"board_lowlevel_init()\"] end subgraph 系统初始化阶段 direction TB xwos_init[\"xwos_init()\"] --\u003e arch_relocate arch_relocate[\"arch_relocate()\"] --\u003e arch_init arch_init[\"arch_init()\"] --\u003e cpu_init cpu_init[\"cpu_init()\"] --\u003e soc_init soc_init[\"soc_init()\"] --\u003e board_init end subgraph 用户程序 direction LR subgraph \"xwos_main()\" direction LR skd[\"启动调度器\"] thd[\"线程初始化\"] device[\"设备驱动初始化\"] libc[\"C/C++标准库初始化\"] lua[\"Lua虚拟机初始化\"] end end 低级初始化阶段 低级初始化阶段，程序只能访问寄存器，不可以访问全局变量。\narch_lowlevel_init() 架构层的低级初始化，例如：ARM的异常、数据cache、指令cache、 浮点运算单元等的初始化。\ncpu_lowlevel_init() CPU层的低级初始化。\nsoc_lowlevel_init() SOC层的低级初始化。\nboard_lowlevel_init() 电路板的低级初始化。通常系统的时钟、电源等在这一层进行进行初始化。\n系统初始化阶段 xwos_init() 初始化玄武OS的数据段(.xwos.data)，并初始化最简单的内核内存分配器。\narch_relocate() 初始化用户的数据段(.data)，经过此函数之后，用户才可以访问全局变量。\narch_init() 架构层的初始化。\ncpu_init() CPU层的初始化。\nsoc_init() SOC层的初始化。通常中断控制器在这一层进行初始化。\nboard_init() 电路板的初始化。通常外设驱动在此处进行初始化，例如：SDRAM、GPIO、DMA等。\n用户程序 xwos_main() 用户程序主函数，用户可在此处建立一个主线程，然后启动调度器。 主线程中还可以初始化设备驱动、初始化C/C++标准库、初始化Lua虚拟机、启动子线程等。\n","categories":"","description":"XWOS的启动流程\n","excerpt":"XWOS的启动流程\n","ref":"/docs/user-manual/boot-flow/","tags":"","title":"启动流程"},{"body":"介绍  MCU: STM32H743IIT6 SDRAM: 32MiB 更多介绍: 主页 电路板目录：xwbd/ATKStm32H743  开发环境  编译集成环境可参考：开发环境搭建指南  源码  仓库：https://gitee.com/xwos/ATKStm32H743.git 下载：  git clone --recursive https://gitee.com/xwos/ATKStm32H743.git  在已有的仓库中同步代码：  git pull git submodule update 导入工程到STM32CubeIDE 工程需放在STM32CubeIDE的工作目录内（即STM32CubeIDE启动时指定的目录）。\n 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive  设置编译环境  打开菜单**“Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment”**； 点击**“Restore Defaults”**； 修改Debug配置的环境变量：  WKSPC:../../../${ConfigName} ~D:1 ~V:1     修改Release配置的环境变量：  WKSPC:../../../${ConfigName} ~D:0 ~V:1    环境变量PATH设置  修改Debug和Release两个配置的PATH环境变量  将STM32CubeIDE自带的工具链路径从PATH环境变量中删除； 将XWMCU工具链的路径放置到PATH环境变量中。    STM32CubeMX配置工程  STM32CubeMX配置文件：xwbd/ATKStm32H743/bm/stm32cube/cubemx/ATKStm32H743.ioc XWOS对中断优先级的要求：  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  NVIC设置  设置3个抢占优先级位和1个子优先级位 SVC中断设置成最高优先级，即Preemption Priority为0； PendSV中断设置成最低优先级，即Preemption Priority为7； Systick中断设置成最低优先级，即Preemption Priority为7； 系统Fault的优先级设置为0； 其他中断的优先级只可在1~6之间。    编译 调试 打开菜单Run –\u003e Debug Configurations…，根据仿真器类型，选择调试配置：\n ATKStm32H743-openocd-daplink：gdb + openocd + DAPLink调试器 ATKStm32H743-openocd-jlink：gdb + openocd + JLink调试器 ATKStm32H743-stlink：gdb + STLink GDB Server + JLink调试器  调试步骤  准备一张SD卡，格式化为FAT32文件系统； 将文件夹xwam/example/lua内的lua脚本，拷贝到SD卡内； 将SD卡插入开发板；   使用MiniUSB线连接电路板上的USB-232接口与PC； 打开终端工具（windows可选putty、SecretCRT，Linux可选gtkterm、picocom、minicom）, 但先不要在终端工具中打开串口，否则MCU会进入下载模式；   上电，并在STM32CubeIDE中启动调试，等待MCU运行到初始断点；   在终端工具中打开串口，参数：1M波特率/8位数据/1位停止位/无奇偶校验；   开始单步调试或连续运行调试。  调试技巧 关闭DCache ARMv7-m7内核的MCU带有Cache，常常会对定位程序BUG带来困扰。 将下面的宏开关注释掉或定义改为0后可关闭Cache：\n/* xwbd/ATKStm32H743/bm/stm32cube/cfg.h */ #define STM32CUBECFG_DCACHE 1 #define STM32CUBECFG_ICACHE 1 运行过程  程序入口：xwbd/ATKStm32H743/bm/main/main.c 启动流程：  xwos_main()创建一个主线程main_task()； main_task()依次调用各个玄武模块的xxx_start()函数完成对各个模块加载； 开始并行执行各个模块中创建的线程；    示例 XWOS中有很多示例，可帮助用户快速了解API的用法：\n 线程  创建线程：xwam/example/thread/create 线程睡眠：xwam/example/thread/sleep   定时器：xwam/example/timer 同步  信号量：xwam/example/sync/semaphore 条件量：xwam/example/sync/condition 事件标志：xwam/example/sync/flg 线程栅栏：xwam/example/sync/br 信号选择器：xwam/example/sync/sel   锁  中断管理：xwam/example/lock/cpuirq 自旋锁：xwam/example/lock/spinlock 顺序锁：xwam/example/lock/seqlock 互斥锁：xwam/example/lock/mtx   内存管理  简单内存分配器：xwam/example/mm/sma 内存切片分配器：xwam/example/mm/memslice 伙伴算法分配器：xwam/example/mm/bma 内存池：只用于比较大的内存区域的管理，例如外接的SDRAM， ATKStm32H743工程已经为板载的SDRAM建立了内存池。   玄武C库  CRC：xwam/example/xwlib/crc    每个示例中都有一个启动函数xxx_start()，可在xwbd/ATKStm32H743/bm/main/main.c文件中 的主线程main_task()启动示例，但最好一次只启动一个示例，避免日志冲突。\n实验过程中最好将Lua虚拟机关闭，防止竞争串口导致输出混乱。方法是将 配置文件xwbd/ATKStm32H743/cfg/xwem.h中的配置XWEMCFG_vm_lua改为0。\n系统集成的原理  所有移植的第三方组件、驱动包、示例代码等都是以玄武模块独立编译成静态库**.a**， 之后再将它们链接成**ELF**文件，再由**ELF**生成**bin**、**hex**和**smot**文件； 每个玄武模块都是一个独立的子工程并进行独立编译，设计上借鉴了安卓系统的Android.mk：  每个玄武模块中都有一个xwmo.mk文件，其中定义的编译参数、头文件路径等 只对当前的玄武模块生效； 每个玄武模块都是一个封闭的包，外部一般不能直接引用内部头文件，需要封装对外可见的 类型以及接口函数，并统一放在专门的API头文件内 API头文件通常以mif.h作为文件名，含义是模块接口(Module InterFace)；   XWOS内已经包含了大量玄武模块：  xwcd：外设芯片的驱动； xwam：示例与应用； xwmd：中间件； xwem：第三方开源软件；   玄武模块的具体信息可以参考用户手册-构建系统-玄武模块。  代码启动流程  stm32cube_lowlevel_init()：初始化时钟 stm32cube_init()：初始化内存管理、cache、GPIO、DMA等基础设备 main_task()：初始化其他设备、启动其他子线程  功能 BSP  STM32Cube模块：xwbd/ATKStm32H743/bm/stm32cube STM32CubeMX配置文件：xwbd/ATKStm32H743/bm/stm32cube/cubemx/ATKStm32H743.ioc STM32CubeMX生成源码目录：xwbd/ATKStm32H743/bm/stm32cube/cubemx 适配XWOS的源码：xwbd/ATKStm32H743/bm/stm32cube/xwac 中断向量表：xwbd/ATKStm32H743/bm/stm32cube/cubemx/IVT  中断向量表是使用命令自动生成的； 命令：xwbs/util/el/stm32ivt/stm32ivt.el xwbd/ATKStm32H743/bm/stm32cube   终端UART  设备：USART1 参数：1M波特率/8位数据/1位停止位/无奇偶校验 驱动  驱动框架 —— 设备栈：xwmd/ds/uart/dma.c 设备栈驱动：xwbd/ATKStm32H743/bm/stm32cube/xwac/xwds/uart.c HAL库驱动：xwbd/ATKStm32H743/bm/stm32cube/cubemx/Core/Src/usart.c 注意：HAL库中的驱动存在BUG，XWOS中所提供的代码已修复     QSPI Flash  映射地址：0x90000000 大小：32MiB 驱动：xwbd/ATKStm32H743/bm/stm32cube/cubemx/Core/Src/quadspi.c   SDRAM  映射地址：0xC0000000 大小：32MiB 驱动：xwbd/ATKStm32H743/bm/stm32cube/cubemx/Core/Src/fmc.c 内存池  头文件  xwbd/ATKStm32H743/bm/stm32cube/mif.h xwos/mm/mempool/allocator.h   内存池对象：sdram_mempool     SPI  驱动  设备栈驱动框架：xwmd/ds/spi/master.c 设备栈驱动：xwbd/ATKStm32H743/bm/stm32cube/xwac/xwds/spim.c HAL库驱动：xwbd/ATKStm32H743/bm/stm32cube/cubemx/Core/Src/spi.c     I2C  驱动  设备栈驱动框架：xwmd/ds/i2c/master.c 设备栈驱动：xwbd/ATKStm32H743/bm/stm32cube/xwac/xwds/i2cm.c HAL库驱动：xwbd/ATKStm32H743/bm/stm32cube/cubemx/Core/Src/i2c.c     I2C EEPROM  大小：256B 驱动  设备栈驱动框架：xwcd/perpheral/i2c/eeprom 设备栈驱动：xwbd/ATKStm32H743/bm/stm32cube/xwac/xwds/at24c02.c      Lua  版本：5.4 源码：xwem/vm/lua 适配代码：xwbd/ATKStm32H743/bm/stm32cube/xwac/lua 已注册的驱动库：xwbd/ATKStm32H743/bm/luamod/ds.c  SOC: stm32 UART: uart1, uart2 I2C: i2c2m SPI: spi1m, spi2m   REPL 运行sd卡中的脚本  FATFS  版本：0.14 源码：xwem/filesystem/fatfs 适配代码：xwbd/ATKStm32H743/bm/stm32cube/xwac/fatfs 文件系统：路径以\"sd:/\"开始 SD卡  驱动：xwbd/ATKStm32H743/bm/stm32cube/cubemx/Core/Src/sdmmc.c    libc  适配代码：xwbd/ATKStm32H743/bm/stm32cube/xwac/newlib 标准输入、输出/错误：重定向至USART1 文件系统：位于SD卡内，从路径sd:/开始 动态内存管理：由SDRAM的内存池提供  电源管理  适配代码：xwbd/ATKStm32H743/bm/stm32cube/xwac/xwds/pm.c  ","categories":"","description":"","excerpt":"介绍  MCU: STM32H743IIT6 SDRAM: 32MiB 更多介绍: 主页 电路板目录：xwbd/ATKStm32H743   …","ref":"/docs/quick-guide/stm32/atkstm32h743/","tags":"","title":"正点原子阿波罗Stm32H743开发板"},{"body":"安装编译工具 emacs  用途：执行elisp脚本 安装方法  sudo apt-add-repository ppa:kelleyk/emacs sudo apt-get update sudo apt install emacs27 bash  用途：执行shell脚本 安装方法  sudo dpkg-reconfigure dash # 选择“否” build-essential  用途：这是一个虚包，此包会通过依赖将相关的一系列工具(make, gcc, …) 全部安装到系统。 安装方法  sudo apt install build-essential 在Linux内核中运行玄武内核模块 假定工作目录为 ~ 。\n下载源码 cd ~ git clone https://gitee.com/xwos/XWKO.git 编译 cd ~/XWKO/xwbd/pc make 运行演示代码：hixwos 玄武内核模块中已经包含演示代码：\n 路径：xwam/example/hixwos 源文件：xwmo.c 头文件：mif.h 编译规则：xwmo.mk  hixwos的运行流程  在xwbd/pc/cfg/xwam.h中将宏开关XWAMCFG_example_hixwos定义为1即可； 玄武内核模块安装到内核(insmod)时，位于xwbd/pc/bdl/board.c中 的board_example_init()函数会调用hixwos_init()完成初始化工作； 玄武内核模块卸载(rmmod)时，board_example_exit()会调用hixwos_exit()完成清理工作。  安装模块 cd ~/XWKO/xwbd/pc sudo insmod wkspc/xwos.ko 查看玄武内核模块的输出 dmesg 此演示代码中创建了两个线程，Producer线程与Consumer线程，从log中可以看到 两个线程通过信号量进行同步，3秒钟后退出。\n卸载模块 sudo rmmod xwos.ko ","categories":"","description":"","excerpt":"安装编译工具 emacs  用途：执行elisp脚本 安装方法  sudo apt-add-repository …","ref":"/docs/quick-guide/xwko/","tags":"","title":"玄武内核模块"},{"body":"约束 异常与中断 XWOS将中断分为EXC和IRQ：\n EXC是指架构中定义的中断，在某些架构中被称为异常(Exception)，中断号用负数表示； IRQ是指外设中断，例如UART的中断等，中断号用0和正数表示。  中断优先级 XWOS对中断优先级的要求：\n切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断 中断向量 中断向量通常位于ivt.c文件中，此文件可能存放在\n xwbd/电路板名称/bdl； xwbd/电路板名称/bm下的某个玄武模块。  XWOS要求给出下列形式的中断向量的定义：\n__xwos_ivt __xwos_ivt_qualifier struct soc_ivt xwospl_ivt; __xwos_ivt_qualifier struct soc_idvt xwospl_idvt;  __xwos_ivt：中断向量的段落属性.xwos.ivt，链接脚本通过此属性，识别 中断向量，并在链接时将它安排在特定的内存区域内； __xwos_ivt_qualifier：中断向量的读写修饰符，与xwbd/电路板/cfg/soc.h中配置有关，  SOCCFG_RO_IVT配置为1：__xwos_ivt_qualifier为const，表示只读； SOCCFG_RO_IVT配置为0：__xwos_ivt_qualifier为空，表示可读写；   struct soc_ivt：操作系统移植实现层(XWOSIMPL)中需要定义的中断向量表结构体类型， 在xwosimpl_soc_irq.h文件中定义； xwospl_ivt：中断向量表结构体； struct soc_idvt：操作系统移植实现层(XWOSIMPL)中需要定义的中断数据表结构体类型， 在xwosimpl_soc_irq.h文件中定义，用于给每个中断存放私有数据； xwospl_idvt：中断数据表结构体。  不同的SOC，中断向量的实现可能有细微的差异，具体可参考移植笔记：\n ARMv6/v7/v8-M GD32V MPC560x  CPU总中断 XWOS可对CPU的总中断开关进行操作：\n xwos_cpuirq_disable_lc()：关闭 xwos_cpuirq_enable_lc()：开启 xwos_cpuirq_save_lc()：保存当前开关状态后关闭 xwos_cpuirq_restore_lc()：恢复之前保存的状态  XWOS要求操作系统移植实现层(XWOSIMPL)中给出上面4个函数的实现方法：\n 源文件：xwosimpl_irq.h/xwosimpl_irq.c xwospl_cpuirq_disable_lc()：关闭 xwospl_cpuirq_enable_lc()：开启 xwospl_cpuirq_save_lc()：保存当前开关状态后关闭 xwospl_cpuirq_restore_lc()：恢复之前保存的状态  使用局限  关闭与开启CPU总中断开关需要确保不会发生嵌套，例如下面的嵌套代码就是错误的：  void func1(void) { xwos_cpuirq_disable_lc(); /* ... 临界区 ... */ xwos_cpuirq_enable_lc(); \u003c} void func0(void) { xwos_cpuirq_disable_lc(); /* ... 临界区 ... */ func1(); /* 错误！！！发生嵌套 */ /* ... 临界区 ... */ xwos_cpuirq_enable_lc(); }  当关闭中断的代码发生嵌套时，需要保存与恢复CPU总中断开关，上面的例子可以更正为：  void func1(void) { xwreg_t cpuirq; xwos_cpuirq_save_lc(\u0026cpuirq); /* ... 临界区 ... */ xwos_cpuirq_restore_lc(cpuirq); } void func0(void) { xwreg_t cpuirq; xwos_cpuirq_save_lc(\u0026cpuirq); /* ... 临界区 ... */ func1(); /* ... 临界区 ... */ xwos_cpuirq_restore_lc(cpuirq); } 外设中断 XWOS可对CPU的外设中断进行控制：\n xwos_irq_request()：申请中断 xwos_irq_release()：释放中断 xwos_irq_enable()：开启中断 xwos_irq_disable()：关闭中断 xwos_irq_save()：保存中断的开关，然后将其关闭 xwos_irq_restore()：恢复中断的开关 xwos_irq_pend()：挂起中断标志 xwos_irq_clear()：清除中断标志 xwos_irq_tst()：测试中断是否挂起 xwos_irq_cfg()：配置中断 xwos_irq_get_cfg()：获取中断的配置 xwos_irq_get_data()：获取中断的数据 xwos_irq_get_id()；判断当前的上下文是否为中断上下文，并取得当前中断的中断号  XWOS要求操作系统移植实现层(XWOSIMPL)中给出上面4个函数的实现方法：\n 源文件：xwosimpl_irq.h/xwosimpl_irq.c xwospl_irq_request()：申请中断 xwospl_irq_release()：释放中断 xwospl_irq_enable()：开启中断 xwospl_irq_disable()：关闭中断 xwospl_irq_save()：保存中断的开关，然后将其关闭 xwospl_irq_restore()：恢复中断的开关 xwospl_irq_pend()：挂起中断标志 xwospl_irq_clear()：清除中断标志 xwospl_irq_tst()：测试中断是否挂起 xwospl_irq_cfg()：配置中断 xwospl_irq_get_cfg()：获取中断的配置 xwospl_irq_get_data()：获取中断的数据 xwospl_irq_get_id()；判断当前的上下文是否为中断上下文，并取得当前中断的中断号  API与示例  文档未及时更新时，以头文件xwos/osal/irq.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的中断控制\n","excerpt":"XWOS的中断控制\n","ref":"/docs/user-manual/irq/","tags":"","title":"中断控制"},{"body":"介绍  MCU: STM32F407ZET6 SRAM: 1MiB 更多介绍: 主页 电路板目录：xwbd/ATKStm32F407Core  开发环境  编译集成环境可参考：开发环境搭建指南  源码  仓库：https://gitee.com/xwos/ATKStm32F407Core.git 下载：  git clone --recursive https://gitee.com/xwos/ATKStm32F407Core.git  在已有的仓库中同步代码：  git pull git submodule update 导入工程到STM32CubeIDE 工程需放在STM32CubeIDE的工作目录内（即STM32CubeIDE启动时指定的目录），\n 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive  设置编译环境  打开菜单**“Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment”**； 点击**“Restore Defaults”**； 修改Debug配置的环境变量：  WKSPC:../../../${ConfigName} ~D:1 ~V:1     修改Release配置的环境变量：  WKSPC:../../../${ConfigName} ~D:0 ~V:1    环境变量PATH设置  修改Debug和Release两个配置的PATH环境变量  将STM32CubeIDE自带的工具链路径从PATH环境变量中删除； 将XWMCU工具链的路径放置到PATH环境变量中。    STM32CubeMX配置工程  STM32CubeMX配置文件：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx/ATKStm32F407Core.ioc XWOS对中断优先级的要求：  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  NVIC设置  设置3个抢占优先级位和1个子优先级位 SVC中断设置成最高优先级，即Preemption Priority为0； PendSV中断设置成最低优先级，即Preemption Priority为7； Systick中断设置成最低优先级，即Preemption Priority为7； 系统Fault的优先级设置为0； 其他中断的优先级只可在1~6之间。    编译 调试 打开菜单Run –\u003e Debug Configurations…，根据仿真器类型，选择调试配置：\n ATKStm32F407Core-openocd-daplink：gdb + openocd + DAPLink调试器 ATKStm32F407Core-openocd-jlink：gdb + openocd + JLink调试器 ATKStm32F407Core-stlink：gdb + STLink GDB Server + JLink调试器  调试步骤  使用MicroUSB线连接电路板上的USB-232接口与PC；   插入一张4GB左右的SD卡，并在之前格式化为FAT32文件系统； 打开终端工具（windows可选putty、SecretCRT，Linux可选gtkterm、picocom、minicom）, 但先不要在终端工具中打开串口，否则MCU会进入下载模式； 上电，STM32CubeIDE中启动调试，等待MCU运行到初始断点； 在终端工具中打开串口，参数：1M波特率/8位数据/1位停止位/无奇偶校验； 开始单步调试或连续运行调试。  调试技巧 复位系统 因为板子的调试接口是4线SWD，与调试器之间没有复位线连接，经常无法完成自动复位， 时常发生在下载完程序，等待MCU运行到初始断点处时。可按以下步骤处理：\n 在程序的初始化流程中设置一个断点，例如xwos_main()函数内部； 若MCU处于停止运行状态，需要让MCU处于运行状态： 手动按一下板子上的复位按键，此时MCU可停在预设的断点处。  示例 XWOS中有很多示例，可帮助用户快速了解API的用法：\n 线程  创建线程：xwam/example/thread/create 线程睡眠：xwam/example/thread/sleep   定时器：xwam/example/timer 同步  信号量：xwam/example/sync/sem 条件量：xwam/example/sync/cond 事件标志：xwam/example/sync/flg 线程栅栏：xwam/example/sync/br 信号选择器：xwam/example/sync/sel   锁  中断管理：xwam/example/lock/cpuirq 自旋锁：xwam/example/lock/spinlock 顺序锁：xwam/example/lock/seqlock 互斥锁：xwam/example/lock/mtx   内存管理  简单内存分配器：xwam/example/mm/sma 内存切片分配器：xwam/example/mm/memslice 伙伴算法分配器：xwam/example/mm/bma 内存池：只用于比较大的内存区域的管理，例如外接的SRAM。 ATKStm32F407Core工程已经为板载的SRAM建立了内存池。   玄武C库  CRC：xwam/example/xwlib/crc    每个示例中都有一个xxx_start()函数，可在xwbd/ATKStm32F407Core/bm/main/main.c文件中的 主线程main_task()中调用这些函数启动示例，但最好一次只启动一个示例，避免冲突。\n系统集成的原理  所有移植的第三方组件、驱动包、示例代码等都是以玄武模块独立编译成静态库**.a**， 之后再将它们链接成**ELF**文件，再由**ELF**生成**bin**、**hex**和**smot**文件。 每个玄武模块都是一个独立的子工程并进行独立编译，设计上借鉴了安卓系统的Android.mk：  每个玄武模块中都有一个xwmo.mk文件，其中定义的编译参数、头文件路径等 只对当前的玄武模块生效； 每个玄武模块都是一个封闭的包，外部一般不能直接引用内部头文件，需要封装对外可见的 类型以及接口函数，并统一放在专门的API头文件中； API头文件通常以mif.h作为文件名，含义是模块接口(Module InterFace)。   XWOS内已经包含了大量玄武模块：  xwcd：外设芯片的驱动； xwam：示例与应用； xwmd：中间件； xwem：第三方开源软件。   玄武模块的具体信息可以参考用户手册-构建系统-玄武模块。  代码启动流程  stm32cube_lowlevel_init()：初始化时钟 stm32cube_init()：初始化内存管理、cache、GPIO、DMA等基础设备 main_task()：初始化其他设备、启动其他子线程  功能 BSP  STM32Cube模块：xwbd/ATKStm32F407Core/bm/stm32cube STM32CubeMX配置文件：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx/ATKStm32F407Core.ioc STM32CubeMX生成源码目录：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx 适配XWOS的源码：xwbd/ATKStm32F407Core/bm/stm32cube/xwac 中断向量表：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx/IVT：  中断向量表是使用命令自动生成的； 命令：xwbs/util/el/stm32ivt/stm32ivt.el xwbd/ATKStm32F407Core/bm/stm32cube；   终端UART  设备：USART1 参数：1M波特率/8位数据/1位停止位/无奇偶校验 驱动  驱动框架 —— 设备栈：xwmd/ds/uart/dma.c 设备栈驱动：xwbd/ATKStm32F407Core/bm/stm32cube/xwac/xwds/uart.c HAL库驱动：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx/Core/Src/usart.c 注意：HAL库中的驱动存在BUG，XWOS中所提供的代码已修复；     SRAM  映射地址：0x68000000 大小：1MiB 驱动：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx/Core/Src/fsmc.c 内存池  头文件  xwbd/ATKStm32F407Core/bm/stm32cube/mif.h xwos/mm/mempool/allocator.h   内存池对象：sram_mempool     SD卡  驱动：xwbd/ATKStm32F407Core/bm/stm32cube/cubemx/Core/Src/sdio.c    ","categories":"","description":"","excerpt":"介绍  MCU: STM32F407ZET6 SRAM: 1MiB 更多介绍: 主页 电路板目录：xwbd/ATKStm32F407Core …","ref":"/docs/quick-guide/stm32/atkstm32f407core/","tags":"","title":"正点原子Stm32F407核心板"},{"body":"介绍  MCU: STM32F103ZET6 SRAM: 1MiB 更多介绍: 主页 电路板目录：xwbd/ATKStm32F103Core  开发环境  编译集成环境可参考：开发环境搭建指南  源码  仓库：https://gitee.com/xwos/ATKStm32F103Core.git 下载：  git clone --recursive https://gitee.com/xwos/ATKStm32F103Core.git  在已有的仓库中同步代码：  git pull git submodule update 导入工程到STM32CubeIDE 工程需放在STM32CubeIDE的工作目录内（即STM32CubeIDE启动时指定的目录），\n 菜单：File –\u003e Import… –\u003e General –\u003e Projects from Folder or Archive  设置编译环境  打开菜单**“Project –\u003e Properties –\u003e C/C++ Build –\u003e Environment”**； 点击**“Restore Defaults”**； 修改Debug配置的环境变量：  WKSPC:../../../${ConfigName} ~D:1 ~V:1     修改Release配置的环境变量：  WKSPC:../../../${ConfigName} ~D:0 ~V:1    环境变量PATH设置  修改Debug和Release两个配置的PATH环境变量  将STM32CubeIDE自带的工具链路径从PATH环境变量中删除； 将XWMCU工具链的路径放置到PATH环境变量中。    STM32CubeMX配置工程  STM32CubeMX配置文件：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx/ATKStm32F103Core.ioc XWOS对中断优先级的要求：  切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断 切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断  NVIC设置  设置3个抢占优先级位和1个子优先级位 SVC中断设置成最高优先级，即Preemption Priority为0； PendSV中断设置成最低优先级，即Preemption Priority为7； Systick中断设置成最低优先级，即Preemption Priority为7； 系统Fault的优先级设置为0； 其他中断的优先级只可在1~6之间。    编译 调试 打开菜单Run –\u003e Debug Configurations…，根据仿真器类型，选择调试配置：\n ATKStm32F103Core-openocd-daplink：gdb + openocd + DAPLink调试器 ATKStm32F103Core-openocd-jlink：gdb + openocd + JLink调试器 ATKStm32F103Core-stlink：gdb + STLink GDB Server + JLink调试器  调试步骤  使用MicroUSB线连接电路板上的USB-232接口与PC；   插入一张4GB左右的SD卡，并在之前格式化为FAT32文件系统； 打开终端工具（windows可选putty、SecretCRT，Linux可选gtkterm、picocom、minicom）, 但先不要在终端工具中打开串口，否则MCU会进入下载模式； 上电，STM32CubeIDE中启动调试，等待MCU运行到初始断点； 在终端工具中打开串口，参数：1M波特率/8位数据/1位停止位/无奇偶校验； 开始单步调试或连续运行调试。  调试技巧 复位系统 因为板子的调试接口是4线SWD，与调试器之间没有复位线连接，经常无法完成自动复位， 时常发生在下载完程序，等待MCU运行到初始断点处时。可按以下步骤处理：\n 在程序的初始化流程中设置一个断点，例如xwos_main()函数内部； 若MCU处于停止运行状态，需要让MCU处于运行状态： 手动按一下板子上的复位按键，此时MCU可停在预设的断点处。  示例 XWOS中有多个示例可帮助用户快速了解API的用法：\n 线程  创建线程：xwam/example/thread/create 线程睡眠：xwam/example/thread/sleep   定时器：xwam/example/timer 同步  信号量：xwam/example/sync/sem 条件量：xwam/example/sync/cond 事件标志：xwam/example/sync/flg 线程栅栏：xwam/example/sync/br 信号选择器：xwam/example/sync/sel   锁  中断管理：xwam/example/lock/cpuirq 自旋锁：xwam/example/lock/spinlock 顺序锁：xwam/example/lock/seqlock 互斥锁：xwam/example/lock/mtx   内存管理  简单内存分配器：xwam/example/mm/sma 内存切片分配器：xwam/example/mm/memslice 伙伴算法分配器：xwam/example/mm/bma 内存池：只用于比较大的内存区域的管理，例如外接的SRAM。 ATKStm32F103Core工程已经为板载的SRAM建立了内存池。   玄武C库  CRC：xwam/example/xwlib/crc    每个示例中都有一个xxx_start()函数，可在xwbd/ATKStm32F103Core/bm/main/main.c文件中的 主线程main_task()中调用这些函数启动示例，但最好一次只启动一个示例，避免冲突。\n系统集成的原理  所有移植的第三方组件、驱动包、示例代码等都是以玄武模块独立编译成静态库**.a**， 之后再将它们链接成**ELF**文件，再由**ELF**生成**bin**、**hex**和**smot**文件。 每个玄武模块都是一个独立的子工程并进行独立编译，设计上借鉴了安卓系统的Android.mk：  每个玄武模块中都有一个xwmo.mk文件，其中定义的编译参数、头文件路径等 只对当前的玄武模块生效； 每个玄武模块都是一个封闭的包，外部一般不能直接引用内部头文件，需要封装对外可见的 类型以及接口函数，并统一放在专门的API头文件中； API头文件通常以mif.h作为文件名，含义是模块接口(Module InterFace)。   XWOS内已经包含了大量玄武模块：  xwcd：外设芯片的驱动； xwam：示例与应用； xwmd：中间件； xwem：第三方开源软件。   玄武模块的具体信息可以参考用户手册-构建系统-玄武模块。  代码启动流程  stm32cube_lowlevel_init()：初始化时钟 stm32cube_init()：初始化内存管理、cache、GPIO、DMA等基础设备 main_task()：初始化其他设备、启动其他子线程  功能 BSP  STM32Cube模块：xwbd/ATKStm32F103Core/bm/stm32cube STM32CubeMX配置文件：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx/ATKStm32F103Core.ioc STM32CubeMX生成源码目录：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx STM32Cube适配XWOS的源码：xwbd/ATKStm32F103Core/bm/stm32cube/xwac 中断向量表：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx/IVT：  中断向量表是使用命令自动生成的； 命令：xwbs/util/el/stm32ivt/stm32ivt.el xwbd/ATKStm32F103Core/bm/stm32cube；   终端UART  设备：USART1 参数：1M波特率/8位数据/1位停止位/无奇偶校验 驱动  驱动框架 —— 设备栈：xwmd/ds/uart/dma.c 设备栈驱动：xwbd/ATKStm32F103Core/bm/stm32cube/xwac/xwds/uart.c HAL库驱动：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx/Core/Src/usart.c   注意：HAL库中的驱动存在BUG，XWOS中所提供的代码已修复；   SRAM  映射地址：0x68000000 大小：1MiB 驱动：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx/Core/Src/fsmc.c 内存池  头文件  xwbd/ATKStm32F103Core/bm/stm32cube/mif.h xwos/mm/mempool/allocator.h   内存池对象：sram_mempool     SD卡  驱动：xwbd/ATKStm32F103Core/bm/stm32cube/cubemx/Core/Src/sdio.c    ","categories":"","description":"","excerpt":"介绍  MCU: STM32F103ZET6 SRAM: 1MiB 更多介绍: 主页 电路板目录：xwbd/ATKStm32F103Core …","ref":"/docs/quick-guide/stm32/atkstm32f103core/","tags":"","title":"正点原子Stm32F103核心板"},{"body":"介绍  XWOS调度器最基本的调度单位是线程，暂时不支持MMU虚拟内存与进程； 每个线程都有自己独立的栈内存，但所有内存对所有线程都可见，除非使用MPU增加限制； 每个线程都有调度优先级，优先级的值越小，优先级越低，优先级的值越大，优先级越高； 调度器始终选择优先级最高的线程，高优先级的线程可以抢占低优先级的线程； 相同的优先级的线程，调度器按照先进先出的方法调度，同优先级线程之间不能相互抢占； 调度器可以冻结线程，支持电源管理； 每个CPU都有自己独立的调度器，线程只能在自身CPU的调度器中调度，如果需要在CPU间移动， 需要进行迁移操作；  调度算法 数据类型  每个优先级都有一个先进先出(FIFO)的就绪队列； 使用一个位图标记每个优先级队列是否为空；非空的队列对应的位被置1，否则被清0。  XWOS调度器就绪队列 Photo: xwos.tech / CC-BY\n  调度流程   定义操作fls：从最高位起查找第一个被置1的位，并返回其序号， 如果所有位都为0，返回-1。此操作需要CPU的相关指令来实现，例如ARM的clz， DEC Alpha的ctlz，x86的lzcnt，PowerPC的cntlz等。\n  流程图\n  flowchart TB start --\u003e fls fls --\u003e idx idx --否--\u003e idle idx --是--\u003e q q --\u003e t t --\u003e skd skd --\u003e e idle --\u003e e start(\"开始\") fls[\"idx = fls(bitmap)\"] idx{\"idx \u003e= 0 ?\"} idle[\"调度空闲任务\"] q[\"选择优先级为idx的就绪队列\"] t[\"从就绪队列头部选择第一个线程\"] skd[\"调度选择的线程\"] e(\"结束\") 调度器中的特殊任务 空闲任务  当调度器中没有任何线程就绪，调度器会调度空闲任务； 空闲任务比较特殊，属于最低优先级的线程，但不能使用任何会导致睡眠、阻塞的函数。 用户可在空闲任务中HOOK用户代码，方法：  在配置文件xwbd/电路板/cfg/board.h中定义配置BRDCFG_XWSKD_IDLE_HOOK为1； 定义函数board_xwskd_idle_hook()并在其中增加用户代码。    中断底半部任务  当调度器配置XWMPCFG_SD_BH（多核）或XWUPCFG_SD_BH（单核）为1时， 调度器会为系统预留一个最高优先级线程； 中断底半部任务比较特殊，属于线程上下文，但不能使用任何会导致睡眠、阻塞的函数； 中断底半部任务可抢占任何线程； 当开启中断底半部时，调度器的滴答定时器任务运行在中断底半部中； XWOS的中断底半部并未完全开发完成，目前只开放给滴答定时器任务使用。  滴答定时器任务  操作系统内核通常都会包含一个定时器，用于产生固定周期的“滴答”（或称为“节拍”）中断； 滴答定时器任务也即是在此定时器中断中执行的周期性任务； 如果中断底半部任务配置为1，滴答定时器任务运行在中断底半部任务内部； 如果中断底半部任务配置为0，滴答定时器任务运行在中断上下文中； 用户可以在滴答定时器任务中HOOK自己的代码，方法：  在配置文件xwbd/电路板/cfg/board.h中定义配置BRDCFG_XWSKD_SYSHWT_HOOK为1； 定义函数board_xwskd_syshwt_hook()并在其中增加用户代码。    调度器的中断 切换上下文的中断  调度器用于切换正在执行的线程的中断 中断优先级：最低  滴答定时器的中断  用于产生固定周期的“滴答”（或称为“节拍”）的定时器中断， 滴答定时器任务由此中断触发执行 中断优先级：切换上下文的中断 \u003c= 滴答定时器的中断 \u003c 调度器服务中断  调度器服务中断  用于执行调度器特殊操作的软中断，包括：  调度器暂停 xwosplcb_skd_suspend_lic() 线程退出 xwosplcb_thd_exit_lic() 线程冻结 xwosplcb_thd_freeze_lic() 线程迁移 xwosplcb_thd_immigrate_lic()和xwosplcb_thd_outmigrate_lic()   中断优先级：最高   注意\n切换上下文的中断 \u003c 其他中断 \u003c 调度器服务中断\n 硬件定时器  XWOS内核要求每个CPU都有一个私有的滴答定时器，产生固定频率的中断； 通常配置为1000HZ，参考配置文件xwbd/电路板/cfg/xwos.h中的 配置XWMPCFG_SYSHWT_PERIOD（多核）或XWUPCFG_SYSHWT_PERIOD（单核）； XWOS的滴答定时器会产生三个变量：  tickcount滴答计数  在每次滴答定时器中断时，tickcount都会自增1； tickcount可以表示滴答定时器中断了多少次； tickcount是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的tickcount； 通过APIxwos_skd_get_tickcount_lc()可以获取当前CPU的tickcount， API的后缀\"_lc“表示此函数是一个Local CPU函数。   timetick滴答时间  XWOS内核使用**纳秒(ns)**作为时间的基本单位，假设滴答器频率1000HZ， tickcount每1ms增加一次，即每1ms增加(xwtm_t)1000000； timetick与tickcount的关系：timetick = tickcount * (xwtm_t)1000000； timetick是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的timetick； 通过APIxwos_skd_get_timetick_lc()可以获取当前CPU的timetick， API的后缀”_lc“表示此函数是一个”Local CPU“函数。   timestamp时间戳  timestamp是以纳秒为单位的时间戳； timestamp会使用滴答定时器中计数器的数值，计算精确到纳秒的时间戳， 但精度由SOC的主频与计数器的位宽决定； timestamp是一个每CPU变量，代码运行在哪个CPU上，访问的就是哪个CPU的timestamp； 通过APIxwos_skd_get_timestamp_lc()可以获取当前CPU的timestamp， API的后缀”_lc“表示此函数是一个”Local CPU“函数。      超时管理 原理 —— 时间树 XWOS内核中，每个需要超时管理的对象（线程、软件定时器）都是以时间树节点组织 到时间树中。时间树节点中包含了超时的滴答时间，调度器每次进入 滴答定时器任务时，都会检测时间树中是否有节点超时。在时间树中，所有节点的滴答 时间都是未来的时间。最先超时的节点的滴答时间一定是最小值。 因此时间树的超时问题是寻找最小值的问题。 XWOS使用红黑树解决此最小值的问题，因此算法原理被称为时间树：\n 使用一个leftmost指针指向最小值，需要时可直接从leftmost快速获取； 超时后，leftmost从红黑树中被删除，按照二叉树的性质，下一任leftmost是 前任的右孩子（即后继）。如果前任的右孩子为叶子，下一任leftmost一定是 前任的父节点； 红黑树中不允许存在关键字相同的节点，因此拥有相同超时滴答时间的节点相互 形成链表，超时后它们全部被唤醒。  XWOS时间树 Photo: xwos.tech / CC-BY\n  超时函数的统一形式 当调用带超时管理的API，传入时间参数时，都是通过一个```xwtm_t``类型的指针传入，例如：\n/* 睡眠 */ xwer_t xwos_cthd_sleep(xwtm_t * xwtm); /* 等待信号量 */ xwer_t xwos_sem_timedwait(struct xwos_sem * sem, xwtm_t * xwtm); /* 等待条件量 */ xwer_t xwos_cond_timedwait(struct xwos_cond * cond, union xwlk_ulock lock, xwsq_t lktype, void * lkdata, xwtm_t * xwtm, xwsq_t * lkst); /* 等待互斥锁 */ xwer_t xwos_mtx_timedlock(struct xwos_mtx * mtx, xwtm_t * xwtm); /* 等待信号旗 */ xwer_t xwos_flg_timedwait(struct xwos_flg * flg, xwsq_t trigger, xwsq_t action, xwbmp_t origin[], xwbmp_t msk[], xwtm_t * xwtm); /* 选择信号选择器 */ xwer_t xwos_sel_timedselect(struct xwos_sel * sel, xwbmp_t msk[], xwbmp_t trg[], xwtm_t * xwtm); /* 线程同步 */ xwer_t xwos_br_timedsync(struct xwos_br * br, xwsq_t pos, xwbmp_t sync[], xwtm_t * xwtm); 这是因为xwtm指向的缓冲区既作为输入，又作为输出：\n 作为输入时，表示期望的超时时间； 作为输出时，返回剩余的时间。超时后，剩余的时间应该小于等于0。  例如：\n 假设调用xwos_mtx_timedlock()时，disired作为输入，期望等待10s。 4s后就已获得互斥锁，函数返回，disired作为输出，剩余时间为(10 - 4) = 6s。  /* 等待互斥锁 */ { xwer_t rc; xwtm_t disired; disired = 10 * XWTM_S; rc = xwos_mtx_timedlock(mid, \u0026disired); if (XWOK == rc) { /* 临界区 */ xwos_mtx_unlock(mid); } } 多核与单核 API参考  文档未及时更新时，以头文件xwos/osal/skd.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的调度器\n","excerpt":"XWOS的调度器\n","ref":"/docs/user-manual/skd/","tags":"","title":"调度器"},{"body":"介绍 线程是操作系统最基本的调度单位，在其他RTOS中可能称之为任务。XWOS的线程， 除了最基本的运行、睡眠、退出操作外，还支持冻结与解冻，迁移等操作。\n线程的状态 XWOS线程状态图 Photo: xwos.tech / CC-BY\n   待命（standby） ：线程对象已被初始化，但未指定主函数； 就绪（ready） ：线程已加入到就绪队列中； 运行（running） ：线程正在运行，每个CPU中只可能存在一个线程正在运行； 睡眠（sleeping） ：线程正在睡眠； 阻塞（blocking） ：线程正在等待，可与睡眠态组合； 冻结（frozen） ：线程已被冻结； 退出（exiting） ：线程即将结束； 迁移（migrating） ：线程正处于迁移到别的CPU的过程中。  线程属性 线程在创建时，可通过参数attr设定其属性，取值：\n XWOS_SKDATTR_PRIVILEGED：表示线程拥有系统特权，  CPU的一些寄存器需要开启特权后才可访问，例如全局中断的开关：  在ARMv6m/ARMv7m中，是通过CONTROL寄存器的bit0(nPRIV)来实现的； 在Embedded PowerPC中，是通过MSR寄存器的bit17(PR)来实现的； 在Embedded PowerPC中，是通过MCAUSE寄存器的bit28和bit29(MPP)来实现的；     XWOS_SKDATTR_DETACHED：表示线程是分离的  类似于POSIX线程的detached属性，DETACHED的线程退出后，系统自动回收其资源。   XWOS_SKDATTR_JOINABLE：表示线程是可连接的，此为默认属性  类似于POSIX线程的joinable属性，JOINABLE的线程退出后，父线程必须 调用xwos_thd_stop()或xwos_thd_join()回收其资源。    线程的创建、初始化与删除、销毁 XWOS内核提供静态初始化和动态创建两种方式建立线程：\n 静态初始化与销毁  初始化：xwos_thd_init()； 销毁：xwos_thd_fini()； 静态是指用户预先定义对象，这些对象在编译时由编译器分配内存； 静态初始化线程还需预先定义栈数组，作用域应该为全局。 栈数组的首地址与大小，必须要满足CPU的ABI规则，例如ARM，就要求8字节对齐， 因此在定义栈数组时需要使用__xwcc__aligned(8)来修饰，且大小是8的倍数。   动态创建与删除  创建：xwos_thd_create()； 删除：xwos_thd_delete()； 动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要通过删除来释放内存； 动态方式创建的线程，其栈内存地址对齐问题由操作系统内核处理。    线程的睡眠 线程睡眠常用来做精度要求不高的延迟，XWOS内核提供两种睡眠方式：\n xwos_cthd_sleep()：睡眠的时间的起点相对于当前的系统时间，这种方式使用简单，但精度较低； xwos_cthd_sleep_from()：睡眠时间的起点由调用者提供，这种方式用来做精确的周期性定时。 第一次调用时，需要提供初始时间起点和增量，此函数超时返回时，会返回当前超时的系统时间， 可作为下一次调用的时间起点，由此循环可形成精准的周期性定时。  线程的退出与返回值 线程的退出 线程退出通常有两种方式：\n 主函数直接return  xwer_t foo_task_thd(void * arg) { /* 省略 ... */ return rc; }  主函数中调用xwos_cthd_exit(rc)  此API的用法类似于POSIX中的函数pthread_exit()，调用的线程会立即终止并抛出返回值。\nxwer_t foo_task_thd(void *arg) { xwer_t rc; /* 省略 ... */ xwos_cthd_exit(rc); /* 线程在此处结束，并抛出返回值rc */ /* 后面的代码不再执行 ... */ } 线程的退出的方式 XWOS的线程类似于pthread，分为Detached属性与Joinable属性，可在创建线程时的attr参 数中指明属性：\n XWOS_SKDATTR_DETACHED：线程是分离的 XWOS_SKDATTR_JOINABLE：线程是可连接的（默认属性）  XWOS_SKDATTR_JOINABLE线程  类似于POSIX线程的Joinable属性，JOINABLE的线程退出后，父线程必须 调用xwos_thd_stop()或xwos_thd_join()回收其资源； 父线程可通过xwos_thd_stop()或xwos_thd_join()获取子线程退出时抛出的返回值； 函数xwos_thd_stop()或xwos_thd_join()会阻塞调用的父线程，直到子线程退出； 函数xwos_thd_cancel()只通知子线程退出，不会等待； 函数xwos_thd_join()只会等待子线程退出，不会通知子线程退出； 函数xwos_thd_stop()会先通知子线程退出，再等待子线程退出，相当 于xwos_thd_cancel()+xwos_thd_join()；  XWOS_SKDATTR_DETACHED线程  类似于POSIX线程的detached属性，DETACHED的线程退出后，系统自动回收其资源。 不可对DETACHED的线程使用xwos_thd_join()和xwos_thd_stop()， 但可使用xwos_thd_cancel()通知其退出。  线程的退出通知  子线程收到退出通知后，只会中断阻塞态和睡眠态，并不会被**“暗杀”**； 子线程可通过xwos_cthd_shld_stop()获取是否收到了退出通知； 子线程收到退出通知后，可以选择忽略，也可选择清理资源后退出。  xwer_t thread_main(void * arg) { xwer_t rc = XWOK; while (!xwos_cthd_shld_stop()) { /* 判断是否收到了退出通知 */ 线程循环...; } return rc; } 线程的冻结与解冻 冻结 线程的冻结，是用来支持内核的一些特殊功能的。用户不能随意冻结线程。 在以下情况，XWOS内核要求线程进入冻结状态：\n 系统准备进入低功耗模式。如果此时线程还在运行，很有可能因其正在访问硬件资源、 占用锁，导致系统关闭硬件、清理资源时发生异常。因此线程需要运行到一个 特殊的点后冻结，这个点就是冻结点。线程进入冻结点前，需要返回到最外层的 主函数中，并释放掉所有的锁和硬件资源。 线程迁移至另一个CPU。线程迁移时，也需要返回至最外层的冻结点，保证不能占用当前 CPU的任何资源。  解冻 线程的解冻一般不由用户来操作，系统完成特殊功能后会自动对线程进行解冻：\n 系统退出低功耗模式时； 线程迁移操作已经完成。  示例 XWOS的线程被要求进入冻结时，会中断阻塞态或睡眠态，这些函数会返回 错误码-EINTR。然后线程可由此释放掉占用的锁和资源，最后执行到主函数的冻结点进行冻结。\nxwer_t foo_task_thread(void *arg) { xwer_t rc; bool was_frz; /* 初始化... */ /* 冻结点在函数xwos_cthd_frz_shld_stop()内部： + 此函数会判断当前线程是否需要冻结，若是，在函数内部冻结线程，冻结点在函数内部； + 此函数同时还判断线程是否需要退出，若是，返回false； + 线程解冻时，从此函数内部冻结点继续执行，直至返回； + 此函数的参数用来告诉用户刚才线程是否被冻结过，若是，was_frz被置为true，否则为false。 */ while (!xwos_cthd_frz_shld_stop(\u0026was_frz)) { 线程循环...; } /* ... */ return rc; } 上面的例子比较简单，在不需要释放锁和资源的场合使用。如果线程冻结前需要 做一些清理操作，可以这样来写主函数中的循环：\nxwer_t foo_task_thread(void *arg) { xwer_t rc; /* 初始化... */ /* 线程循环 */ while (!xwos_cthd_shld_stop()) { /* 只判断线程是否需要退出 */ rc = fsm(...); /* 在状态机中阻塞在某个同步对象或锁上 */ if (-EINTR == rc) { /* 线程的阻塞态或睡眠态被中断时，会收到错误码-EINTR， 进一步判断是否被系统要求冻结。 */ if (xwos_cthd_shld_frz()) { /* 判断是否需要冻结 */ free_resource(); /* 释放锁和资源... */ xwos_cthd_freeze(); /* 冻结点 */ /* 线程解冻后，代码回到这里，如果对线程进行了迁移， 另一个CPU从此处开始运行此线程 */ alloc_resource(); /* 重新请求资源和锁... */ } else { /* 处理其他原因导致的中断，例如终止请求 */ } } } /* ... */ return rc; } 线程的迁移 在多核系统中，XWOS的线程只会在某个CPU上被调度，XWOS内核并不会自动对线程做均衡处理， 但支持将线程迁移到另一个CPU上，相关API：xwos_thd_migrate()。\n迁移流程  假定条件：线程正在CPU-A上，准备迁移到CPU-B上 流程：  用户在任意CPU的任意上下文调用API：xwos_thd_migrate()；  系统向CPU-A发送调度器服务中断，提出“迁移出”的申请； CPU-A切换至调度器服务中断，向线程设置冻结标志，并中断线程的阻塞态和睡眠态， 然后退出中断上下文； CPU-A中线程被重新调度，并运行到冻结点； 线程在冻结点向CPU-A发送调度器服务中断，执行冻结操作； 线程冻结后，CPU-A向CPU-B申请调度器服务中断，提出“迁移进”的申请； CPU-B切换至调度器服务中断，把线程加入到自己的调度器中，解除线程的冻结状态， 并加入就绪列表中； 迁移完成，线程开始在CPU-B中调度。      API参考  文档未及时更新时，以头文件xwos/osal/skd.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的线程\n","excerpt":"XWOS的线程\n","ref":"/docs/user-manual/thd/","tags":"","title":"线程"},{"body":"介绍 软件定时器是基于调度器的滴答定时器任务实现的， 因此时间精度最小为滴答定时器的中断频率。\n软件定时器的回调函数 软件定时器的回调函数运行在滴答定时器任务中。\n 当开启中断底半部时，软件定时器的回调函数运行在中断底半部中； 当关闭中断底半部时，软件定时器的回调函数运行在中断上下文中。  无论是运行在中断底半部还是中断上下文，软件定时器的回调函数都 不可使用任何会导致睡眠、阻塞的API。\n软件定时器的标志  XWOS_SWT_FLAG_RESTART：定时器超时后自动重新开始。  软件定时器的创建、初始化与删除、销毁 软件定时器同线程一样，支持静态初始化与销毁，动态创建与删除两种方式：\n 静态初始化与销毁  初始化：xwos_swt_init() 销毁：xwos_swt_fini() 静态是指用户预先定义对象，这些对象在编译时由编译器分配内存。   动态创建与删除  创建：xwos_swt_create() 删除：xwos_swt_delete() 动态是指程序在运行时，通过内存分配函数从某个内存区域上申请分配一块内存， 并把这块内存初始化为所需要的对象。使用完毕后，需要释放内存。    API参考  文档未及时更新时，以头文件xwos/osal/swt.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的软件定时器\n","excerpt":"XWOS的软件定时器\n","ref":"/docs/user-manual/swt/","tags":"","title":"软件定时器"},{"body":"介绍 XWOS有两套电源管理框架，分别用于MP系统和UP系统。\nXWOS的电源管理框架只提供了基本流程，最终SOC如何休眠由BSP中的回调函数实现： 用户可以自行决定是否保持SDRAM的刷新、是否保持某些GPIO的输出、或则是否进入最低功耗的待机等等。\nMP系统的电源管理 电源管理领域 MP系统中，CPU不唯一，XWOS中使用电源管理领域(PMDM)来统一管理所有CPU的休眠与唤醒。\n流程 MP系统电源管理流程 Photo: xwos.tech / CC-BY\n  图中，左列为休眠流程，右列为唤醒流程，箭头代表了可以进行电源管理阶段转换的方向。 电源管理领域将电源管理分为四个阶段（图中绿色的框）：\n正在运行 (XWMP_PMDM_STAGE_RUNNING) 所有CPU正常运行，可以使用下面API进入休眠的流程：\nxwer_t xwos_pm_suspend(void); 此API是操作系统抽象层OSAL中的API，实际调用的是：\nxwer_t xwmp_pmdm_suspend(void); 冻结调度器 —— 解冻调度器 (XWMP_PMDM_STAGE_FREEZING - XWMP_PMDM_STAGE_THAWING) 一旦开始休眠流程，PMDM会通知所有CPU冻结线程。当调度器中线程 全部冻结后，调度器会向PMDM报告已经暂停的状态。调度器冻结 线程的过程是一个比较复杂的过程，这个阶段又分为几个子阶段（图中蓝色的框）：\n冻结线程 —— 解冻线程 (XWMP_SKD_WKLKCNT_FREEZING - XWMP_SKD_WKLKCNT_THAWING) 调度器会中断所有线程的等待和睡眠态，并为所有线程设置可冻结标志， 然后依次调度每个线程，直到它们运行到冻结点进行冻结，这个过程耗时比较长， 在执行过程中如果遇到唤醒事件，调度器会在唤醒事件中断中切换为解冻流程： 解冻已经冻结的线程，并取消未冻结的线程的可冻结标志。\n全部线程已经冻结 (XWMP_SKD_WKLKCNT_ALLFRZ) 最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。 如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断。 休眠流程切换为唤醒流程，并重新打开滴答定时器。 按照调度器的中断中的约束，唤醒事件中断的优先级低于 调度器服务中断，因此唤醒事件中断一定会在调度器服务中断退出后才开始执行， 滴答定时器一定会先关闭，然后再打开，顺序不会错乱。\n调度器已经暂停 (XWMP_SKD_WKLKCNT_SUSPENDED) CPU从上一步骤的调度器服务中断中退出后，会切换回线程上下文，此时因所有 线程已经冻结，CPU只可能运行在空闲任务中。 CPU会在空闲任务中向PMDM报告调度器已经暂停的状态。此过程不能在调度器服务中断 中进行，因为调度器服务中断是最高优先级中断，不能被唤醒事件中断打断， 有可能会导致无法唤醒的问题。\n正在暂停 —— 正在恢复 (XWMP_PMDM_STAGE_SUSPENDING - XWMP_PMDM_STAGE_RESUMING) 当最后一个CPU报告了已经暂停的状态后，会在最后一个CPU的空闲任务中执行用户 的suspend()回调函数。此时，如果出现唤醒事件，电源管理的阶段会从正在暂停切换 为正在恢复，并执行用户的resume()回调函数。\n suspend()回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等； resume()回调函数用于在唤醒之前执行与suspend()回调函数相反的操作； 执行这两个函数时，PMDM会自动锁定resume-suspend锁，并关闭当前 CPU的总中断开关。resume-suspend锁是自旋锁，如果CPU-1正在 执行suspend()回调函数，此时出现了唤醒事件，会分下面两种情况进行处理：  唤醒事件中断也绑定在CPU-1上，唤醒事件中断会挂起，直到suspend()回调函数 返回，PMDM解锁resume-suspend锁并打开CPU总中断开关，才被处理， 然后执行resume()回调函数； 唤醒事件中断绑定在CPU-2上，CPU-2会立即进入唤醒事件中断，但一直会 自旋等待CPU-1释放resume-suspend锁，直到获得resume-suspend锁后， 才会执行resume()回调函数；   示例WeActMiniStm32H750的resume()与suspend()回调函数：  /* xwbd/WeActMiniStm32H750/bm/stm32cube/xwds/pm.c */ void stm32cube_pm_resume(void) { ... /* 恢复stm32cube中的所有设备 */ xwds_pm_resume(\u0026stm32cube_ds); } void stm32cube_pm_suspend(void) { ... /* 暂停stm32cube： + 暂停所有设备 + 配置GPIO */ xwds_pm_suspend(\u0026stm32cube_ds); /* 设置休眠方式为STOP模式： STOP模式下寄存器与内部RAM数据不丢失， 因此休眠方式为SuspendToRAM，唤醒后运行状态可恢复。*/ LL_PWR_SetRegulModeDS(LL_PWR_REGU_DSMODE_LOW_POWER); LL_PWR_EnableFlashPowerDown(); LL_PWR_CPU_SetD1PowerMode(LL_PWR_CPU_MODE_D1STOP); LL_PWR_CPU_SetD2PowerMode(LL_PWR_CPU_MODE_D2STOP); LL_PWR_CPU_SetD3PowerMode(LL_PWR_CPU_MODE_D3STOP); LL_LPM_EnableDeepSleep(); /* 设置ARMv7-m的DEEPSLEEP位 */ LL_LPM_EnableDeepSleep(); } 已经暂停 (XWMP_PMDM_STAGE_SUSPENDED) 此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。 此阶段提供给用户的回调函数：\n sleep()：休眠SOC wakeup()：唤醒SOC  当最后一个CPU的空闲任务执行完上一阶段的suspend()回调函数后， PMDM将电源管理步骤切换到此阶段，并执行sleep()回调函数。 SOC系统在sleep()回调函数内部进入低功耗状态， 此时时钟停止，代码停止运行，sleep()回调函数不会返回。\nXWOS将sleep()回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能 导致系统无法唤醒。例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了 休眠指令（wfi），低优先级的唤醒中断无法把系统唤醒。\n当唤醒事件出现，**wakeup()**回调函数在唤醒事件中断中执行。\n回调函数sleep()与wakeup()之间没有锁的保护， 因此sleep()回调函数需要设计成能被wakeup()回调函数打断。\n示例，WeActMiniStm32H750的wakeup()与sleep()回调函数：\n/* xwbd/WeActMiniStm32H750/bm/stm32cube/xwds/pm.c */ void stm32cube_pm_wakeup(void) { LL_LPM_EnableSleep(); /* 清除DEEPSLEEP位 */ SystemClock_Config(); /* 从STOP模式恢复后，需要重新配置时钟 */ } void stm32cube_pm_sleep(void) { /* 位置1 */ cm_wfi(); /* 位置2 */ } 分为两种情况讨论：\n stm32cube_pm_sleep()中的WFI指令执行后出现唤醒事件： 唤醒流程执行完毕后，代码会回到stm32cube_pm_sleep()中位置2； stm32cube_pm_sleep()中的WFI指令执行之前出现唤醒事件： 唤醒事件中断会打断stm32cube_pm_sleep()函数，然后 执行stm32cube_pm_wakeup()函数，LL_LPM_EnableSleep() 会清除ARMv7-m的DEEPSLEEP位，接下来的唤醒流程也会将滴答定时器重新打开，当 再次回到stm32cube_pm_sleep()的位置1时，WFI指令只会使CPU进入 ARMv7-m的SLEEP模式，只是短暂地暂停了一下CPU时钟，即将到来的滴答定时器中断 可使系统恢复正常。  UP内核的电源管理 流程 UP系统电源管理流程 Photo: xwos.tech / CC-BY\n  图中，左列为休眠流程，右列为唤醒流程，箭头代表了电源管理阶段切换的方向。 UP系统电源管理分为五个阶段：\n正在运行 (XWUP_PM_STAGE_RUNNING) 调度器正常运行，可以使用下面API进入休眠的流程：\nxwer_t xwup_skd_suspend(void); 正在冻结线程 —— 正在解冻线程 (XWUP_PM_STAGE_FREEZING - XWUP_PM_STAGE_THAWING) 一旦开始休眠流程，调度器会中断所有线程的等待和睡眠态，并通知所有线程冻结。 这个过程耗时比较长，在执行过程中如果遇到唤醒事件，调度器可在唤醒事件中断中 切换为解冻流程：解冻已冻结的线程，并将调度器状态逐步恢复至正在运行。\n调度器中全部线程已经冻结 (XWUP_PM_STAGE_ALLFRZ) 最后一个线程完成冻结时，CPU处于调度器服务中断中，调度器会将滴答定时器关闭。 如果此刻出现唤醒事件，待CPU从调度器服务中断中退出后，会立即进入唤醒事件中断， 休眠流程切换为唤醒流程，并重新打开滴答定时器。 按照调度器的中断中的约束，唤醒事件中断的优先级 低于调度器服务中断，因此唤醒事件中断一定会在调度器服务中断退出后才开始执行， 滴答定时器一定会先关闭，然后再打开，顺序不会错乱。\n正在暂停 —— 正在恢复 (XWUP_PM_STAGE_SUSPENDING - XWUP_PM_STAGE_RESUMING) 当全部线程冻结后，调度器只能调度空闲任务，调度器会在空闲任务中执行用户 的suspend()回调函数。此时，如果出现唤醒事件，系统会在唤醒事件中断中将状态从 正在暂停切换为正在恢复，并执行用户的resume()回调函数。\n suspend()回调函数用于在休眠之前让用户关闭设备、配置SDRAM刷新模式、配置GPIO等； resume()回调函数用于在唤醒之前执行与suspend()回调函数相反的操作； 执行这两个函数时系统会关闭CPU总中断开关。如果正在执行suspend()回调函数时 出现了唤醒事件，唤醒事件中断会挂起，直到suspend()回调函数，系统 打开CPU总中断开关时才被处理，然后执行resume()回调函数；  已经暂停 (XWUP_PM_STAGE_SUSPENDED) 此阶段为休眠流程的最后一个阶段，也是唤醒流程的第一个阶段。 此阶段提供给用户的回调函数：\n sleep()：休眠SOC wakeup()：唤醒SOC  当空闲任务执行完上一阶段的suspend()回调函数后， 电源管理步骤切换到此阶段，并执行sleep()回调函数。SOC系统在sleep()回调函数 内部进入休眠状态，此时时钟停止，代码停止运行，sleep()回调函数不会返回。\nXWOS将sleep()回调函数设计在空闲任务中执行，是因为中断优先级的问题有可能 导致系统无法唤醒。例如基于ARM-m的单片机，如果在一个高优先级的中断中执行了 休眠指令（WFI），低优先级的唤醒中断无法把系统唤醒。\n当唤醒事件出现，wakeup()回调函数在唤醒事件中断中执行。\n回调函数sleep()与wakeup()之间没有锁的保护， 因此sleep()回调函数需要设计成能被wakeup()回调函数打断。\nAPI参考  文档未及时更新时，以头文件xwos/osal/pm.h中注释为准； API详细说明与示例：API手册  ","categories":"","description":"XWOS的电源管理\n","excerpt":"XWOS的电源管理\n","ref":"/docs/user-manual/pm/","tags":"","title":"电源管理"},{"body":"临界区管理 临界区是指访问共用资源的程序片段，传统RTOS中，通常使用以下几种方式保护临界区资源：\n 使用协作式内核：线程（任务）不主动放弃CPU不会发生调度，因此共享的资源在 线程（任务）中访问都是安全的。 关闭抢占：可用于保护被多个线程（任务）共享的资源。 关闭中断：可用于保护线程与线程、线程与中断共享的资源。 互斥锁：可用于保护被多个线程（任务）共享的资源。  XWOS内核是假定系统为MP来设计的（UP可以视为MP的特例）， 因此在进入临界区的方式与传统RTOS有些区别：\n 关闭抢占：使用自旋锁或其派生锁的lock与unlock形式的API； 关闭CPU总中断：使用自旋锁或其派生锁的lock_cpuirq与unlock_cpuirq形式的API。 若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用lock_cpuirqsv与unlock_cpuirqrs 形式的API来保存与恢复CPU总中断开关标志，防止内层锁解锁时意外地把CPU总中断打开； 关闭部分中断：使用自旋锁或其派生锁的lock_irqs与unlock_irqs形式的API， 若对临界区的访问需要获取多个自旋锁或其派生锁，应该使用lock_irqssv与unlock_irqsrs 形式的API来保存与恢复部分中断开关标志，防止内层锁解锁时意外地把这些中断打开； 关闭中断底半部：使用自旋锁或其派生锁的lock_bh与unlock_bh形式的API； 互斥锁：只能用于保护被多个线程共享的资源； 原子操作：XWOS中提供原子操作的函数库xwos/lib/xwaop.h，并抽象了std:atomic类似的内存模型。  ","categories":"","description":"XWOS的锁\n","excerpt":"XWOS的锁\n","ref":"/docs/user-manual/lock/","tags":"","title":"锁"},{"body":"玄武OS提供多种同步机制，它们统一称为同步对象：\n 信号量 条件量 事件标志 线程栅栏 信号选择器  信号量与条件量是操作系统最基本的两种同步机制， 其他复杂的同步机制都可基于这两种同步机制实现。\n","categories":"","description":"XWOS的同步\n","excerpt":"XWOS的同步\n","ref":"/docs/user-manual/sync/","tags":"","title":"同步"},{"body":"XWOS提供四种内存管理的算法。\n","categories":"","description":"XWOS的内存管理\n","excerpt":"XWOS的内存管理\n","ref":"/docs/user-manual/mm/","tags":"","title":"内存管理"},{"body":"","categories":"","description":"XWOS基本C函数库\n","excerpt":"XWOS基本C函数库\n","ref":"/docs/user-manual/xwlib/","tags":"","title":"XWOS基本C函数库"},{"body":"","categories":"","description":"XWOS的C/C++标准库\n","excerpt":"XWOS的C/C++标准库\n","ref":"/docs/user-manual/c-c++/","tags":"","title":"C/C++"},{"body":"XWOS内核只提供基本的同步机制（信号量、条件量、事件标志、线程栅栏、信号选择器）， 线程间通讯的机制是基于最基本的同步机制实现的，因此属于中间件XWMD。 XWMD除了提供消息队列、循环队列等线程间通讯机制外，还提供电路板上SOC芯片间的通讯机制， 因此被称为系统间通讯机制(ISC, Inter-System Communication)。\n","categories":"","description":"XWOS的系统间通讯机制\n","excerpt":"XWOS的系统间通讯机制\n","ref":"/docs/user-manual/isc/","tags":"","title":"通讯"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/note/","tags":"","title":"笔记"},{"body":"","categories":"","description":"XWOS的代码规范\n","excerpt":"XWOS的代码规范\n","ref":"/docs/criterion/","tags":"","title":"规范"},{"body":" XWOS核心代码  XWOS核心代码采用MPL-2.0发布； 适用范围：xwos、xwmd文件夹下的源码； MPL-2.0是对商业友好的协议，所有适用范围的源码文件只包含了 附录A中的声明，即Exhibit A - Source Code Form License Notice， 也就是说用户可以以任意形式（源码文件、静态库）将xwos、xwmd文件夹下 的源码集成到自己的商业的应用场景中， 在MPL-2.0中被称为Larger Work。   XWOS的外围代码  XWOS的外围代码采用Apache-2.0发布； 适用范围：xwcd、xwbd、xwam、xwbs文件夹下的源码。   第三方软件  适用范围：xwem文件夹下的源码以及xwbd中部分驱动源码； 免责声明：XWOS项目中集成的第三方开源软件仅供参考，用户需自行检查 这些软件的缺陷以及LICENSE，并自行承担相关的缺陷风险及法律风险。 XWOS项目组不承担任何法律责任。    ","categories":"","description":"XWOS的开源协议\n","excerpt":"XWOS的开源协议\n","ref":"/docs/license/","tags":"","title":"开源协议"},{"body":"  #td-cover-block-0 { background-image: url(/background_hu062828774b486a7a15cb350efbe296bc_655609_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/background_hu062828774b486a7a15cb350efbe296bc_655609_1920x1080_fill_q75_catmullrom_top.jpg); } }  XWOS 国产实时操作系统\n文档   码云   github           Photo by Alexandre P. Junior from Pexels     玄武操作系统是一款运行在嵌入式微控制器上的通用实时操作系统。\n    特性    CPU架构  支持PowerPC、ARM、RISC-V。\n   单核/多核  支持单核(UP)与多核(MP)两种内核。\n   电源管理  集成电源管理框架，提供休眠/唤醒的基本流程。\n更多 …\n   开发平台     Ubuntu  \n    Windows  \n     编译系统  集成编译系统，可与其他软件一起构建您的工程。\n更多 …\n   编译器     gcc  \n    llvm  \n     C/C++语言  支持C/C++混合开发。\n更多 …\n   Lua语言  支持Lua-5.4脚本化开发。\n更多 …\n   RUST语言  即将到来……。\n   命名空间  符号带有前缀，防止与其他软件发生命名冲突。\n   玄武内核模块  可在Linux内核中使用XWOS的API。\n更多 …\n     上手指南    STM32  更多 …\n   GD32  更多 …\n   GD32V  更多 …\n   NXP S32K  更多 …\n   示例  更多 …\n        QQ群：820392693       微信       邮箱  xwos@xwos.tech\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"XWOS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"搜索结果"}]